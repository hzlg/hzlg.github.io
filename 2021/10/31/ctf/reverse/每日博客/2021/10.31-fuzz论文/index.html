<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="论文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="之前那个要学机器学习，以为是测试来着，结果是开发一个自动化检测工具，emmm，换了一篇">
<meta property="og:type" content="article">
<meta property="og:title" content="10.31-fuzz论文">
<meta property="og:url" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/index.html">
<meta property="og:site_name" content="hzlg&#39;s blog">
<meta property="og:description" content="之前那个要学机器学习，以为是测试来着，结果是开发一个自动化检测工具，emmm，换了一篇">
<meta property="og:locale">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211103142012406.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211103183501212.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211104093005703.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211104201253288.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211104201522226.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211107131254034.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211107132000839.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211117132141336.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211113163411132.png">
<meta property="article:published_time" content="2021-10-30T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-25T16:00:00.000Z">
<meta property="article:author" content="hzlg">
<meta property="article:tag" content="论文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211103142012406.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hzlg.github.ioz/2021/10/31/ctf/reverse/每日博客/2021/10.31-fuzz论文/"/>





  <title>10.31-fuzz论文 | hzlg's blog</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzlg's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记、日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzlg.github.ioz/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzlg's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">10.31-fuzz论文</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-31T00:00:00+08:00">
                2021-10-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-26T00:00:00+08:00">
                2021-11-26
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前那个要学机器学习，以为是测试来着，结果是开发一个自动化检测工具，emmm，换了一篇</p>
<span id="more"></span>

<p>机器人车辆的策略引导模糊化</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="RV的重要性以及主要面临的安全问题"><a href="#RV的重要性以及主要面临的安全问题" class="headerlink" title="RV的重要性以及主要面临的安全问题"></a>RV的重要性以及主要面临的安全问题</h3><p>机器人车辆(rv)正在成为现代系统的重要工具，包括自动递送服务、公共交通和环境监测。尽管它们的部署多样化，但安全问题和安全问题限制了它们的广泛采用。</p>
<p>迄今为止，RV安全方面的大多数尝试都旨在提出防御措施，以加强其控制程序对<strong>语法错误</strong>、<strong>输入验证错误</strong>和<strong>外部传感器欺骗攻击</strong>的抵抗力。</p>
<h3 id="作用效果-以时间约束为指导-测量RV与策略违规的距离度量"><a href="#作用效果-以时间约束为指导-测量RV与策略违规的距离度量" class="headerlink" title="作用效果:以时间约束为指导,测量RV与策略违规的距离度量"></a>作用效果:以时间约束为指导,测量RV与策略违规的距离度量</h3><p>在本文中，我们介绍了PGFUZZ，一个策略指导的模糊框架，它验证RV是否<strong>遵守已识别的安全和功能策略</strong>，包括用户命令、配置参数和物理状态。pgfuzzz通过时序逻辑公式来表达所需的策略，并以时间约束作为指导，对分析的系统进行模糊处理。</p>
<p>具体地说，它生成模糊输入，最小化测量RV当前状态与策略违规“有多接近”的距离度量。</p>
<h3 id="作用范围-通过动静态分析筛选出影响策略的命令"><a href="#作用范围-通过动静态分析筛选出影响策略的命令" class="headerlink" title="作用范围:通过动静态分析筛选出影响策略的命令"></a>作用范围:通过动静态分析筛选出影响策略的命令</h3><p>此外，它使用<strong>静态和动态分析</strong>将模糊工作集中在那些影响任何已执行策略的“真值”的命令、参数和环境因素上。这两种技术的结合使pgfuzzz能够显著提高模糊过程的效率。</p>
<p>我们验证了PGFUZZon的三个RV控制程序，ArduPilot, PX4和Paparazzi，有56个独特的政策。pgfuzz发现了156个之前未知的bug，其中106个已经得到了开发者的认可。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>RV在工业和消费环境中越来越普遍。不幸的是，RV面临各种威胁，包括</p>
<p>(1)物理外部攻击，如传感器欺骗攻击</p>
<p>(2)由于浮点异常或内存损坏问题导致的软件崩溃</p>
<p>(3)内部攻击</p>
<p>(4)导致安全和功能问题的错误实现，这会导致rv中的不良行为。</p>
<p>以前在模糊方面的努力已经引入了技术来解决(1)、(2)和(3)，但(4)没有得到太多的关注。RV必须尊重安全和安全策略，以避免对其操作的环境或自身造成物理损害。</p>
<p>例如，RV通常配备有降落伞。出于安全考虑，R V的软件必须<strong>检查先决条件</strong>，以安全释放降落伞(例如，R V必须足够高，当展开降落伞)。然而，控制软件的粗心设计可能会允许RV在没有检查这些先决条件的情况下释放降落伞。</p>
<h3 id="以前的模糊方法无法检查RV违反策略问题"><a href="#以前的模糊方法无法检查RV违反策略问题" class="headerlink" title="以前的模糊方法无法检查RV违反策略问题"></a>以前的模糊方法无法检查RV违反策略问题</h3><p>正如最近报道的那样，这种违反安全的行为可能会导致灾难性的后果。例如，特斯拉的自动驾驶软件未能启动紧急刹车操作，波音-737 Max飞机坠毁是因为他们的软件不恰当地允许他们激活防失速系统。</p>
<p>不幸的是，由于以下两个原因，以前的模糊方法无法发现这种类型的违规。</p>
<p>首先，他们没有考虑RV<strong>控制软件的全部输入空间</strong>，包括用户命令、配置参数和环境因素。其次，他们只专注于寻找<strong>内存损坏bug</strong>或<strong>RV控制稳定性问题</strong>。因此，他们无法检测到违反安全政策的行为，例如，无人机在过低的高度展开了降落伞。</p>
<p>我们开发了pgfuzz，一个基于策略的模糊框架，旨在解决这些挑战。pgfuzzing包括三个相互关联的组件:(1)预处理，(2)策略引导的Fuzzing， (3) Bug后处理。</p>
<blockquote>
<p>(1) Pre-Processing, (2) Policy-GuidedFuzzing, and (3) Bug Post-Processing.</p>
</blockquote>
<h3 id="预处理阶段-寻找与策略相关的输入"><a href="#预处理阶段-寻找与策略相关的输入" class="headerlink" title="预处理阶段:寻找与策略相关的输入"></a>预处理阶段:寻找与策略相关的输入</h3><p>在Pre-Processing组件中，我们通过<strong>度量时间逻辑(MTL)<code> metric temporal logic</code>表示</strong>的策略来表达RV的正确操作。然后，我们通过寻找与测试策略相关的输入来最小化模糊空间，这些输入在发生变异时可能会触发策略违规。例如，给定一个自然语言的策略，声明“当引擎温度高于100°C时必须触发故障安全模式”，pgfuzz_用MTL公式表示该策略:?{(温度&gt;100°C)→(故障安全=on)}。然后，它将这个公式分解为温度和故障安全的适度，并识别模糊输入，如用户命令(例如，增加温度)和配置参数(例如，温度单位)，影响策略状态。</p>
<h3 id="策略引导-收集系统状态-计算距离度量"><a href="#策略引导-收集系统状态-计算距离度量" class="headerlink" title="策略引导:收集系统状态,计算距离度量,"></a>策略引导:收集系统状态,计算距离度量,</h3><p>然后，Policy-Guided Fuzzing改变由Pre-Processing组件标识的输入。它实现了两种距离度量，命题距离<code>propositional distances</code>用于引导突变引擎<code>mutation engine</code>，以及全局距离<code>global distance </code>用于检测策略违反的发生。</p>
<p>距离度量量化当前系统状态与策略违反的距离。正距离表示该策略有效，负距离表示该策略被违反。</p>
<p>因此，PGFUZZ变化输入以最小化全局距离。在每个<strong>输入被发送</strong>到控制软件后，控制软件<strong>在RV模拟器中运行</strong>，pgfuzzo<strong>收集系统状态并计算距离度量</strong>。输入对距离度量的影响(无论是增加还是减少)被用来决定下一个输入。<strong>当全局距离为负时，将检测到策略违规。</strong></p>
<p>切换到故障安全模式的例子，pgfuzzates输入增加温度大于100°C，并检查，同时，故障安全模式是否被激活。</p>
<h3 id="Bug后处理-排除无关输入-确认违规的根本原因"><a href="#Bug后处理-排除无关输入-确认违规的根本原因" class="headerlink" title="Bug后处理:排除无关输入,确认违规的根本原因"></a>Bug后处理:排除无关输入,确认违规的根本原因</h3><p>最后一个组件，Bug Post-Processing，通过排除与策略违反无关的输入，将触发Bug的输入序列最小化。然后使用最小化的输入序列来识别每个违规策略的根本原因。</p>
<p>为了验证pgfuzz算法的正确性和有效性,我们测试了ArduPilot, PX4，和Paparazzi，三种最流行的飞行控制软件包使用在许多商品旅行车。pgfuzz48小时内发现156个之前未知的bug 1。在156个bug中，开发人员确认了106个bug，其中9个bug已经被修复。我们将PGFUZZ的结果与之前设计用于查找RVs中bug的方法进行了比较，发现156个bug中有128个只能由PGFUZZ发现。 </p>
<h3 id="本篇论文做出了以下贡献"><a href="#本篇论文做出了以下贡献" class="headerlink" title="本篇论文做出了以下贡献"></a>本篇论文做出了以下贡献</h3><h4 id="用已知策略来寻找Bug"><a href="#用已知策略来寻找Bug" class="headerlink" title="用已知策略来寻找Bug"></a>用已知策略来寻找Bug</h4><p>我们确定了定义RV的安全性和功能需求的策略，并通过时序逻辑公式正式表示它们。pgfuzzz利用已识别的策略来查找允许违反这些策略的bug。</p>
<h4 id="Policy-Guided突变引擎。"><a href="#Policy-Guided突变引擎。" class="headerlink" title="Policy-Guided突变引擎。"></a>Policy-Guided突变引擎。</h4><p>pgfuzzz采用了一种新颖的模糊设计，通过</p>
<p>(i)改变输入/参数，试图否认已经认同的安全策略，并使用启发式的专用距离度量</p>
<p>(ii)最小化与分析策略相关的输入和参数的模糊空间，优化其错误搜索。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="RV的输入和输出。"><a href="#RV的输入和输出。" class="headerlink" title="RV的输入和输出。"></a>RV的输入和输出。</h3><p>当系统保持不希望的状态时，车辆会导致错误的操作或故障。例如，当车辆保持不正确的滚转、俯仰和偏航角度时，就会撞到地面。</p>
<p>rv通常定期遵循以下三个步骤(见图1)以确保其正确运行:</p>
<p>(1)控制算法读取由传感器(从①到②)测量的系统输出y(t)</p>
<p>(2)算法首先基于r(t)−y(t)计算误差e(t)，其中r(t)和(t)表示参考状态和当前时间</p>
<p>(3)比例-积分-微分<code>Proportional–Integral–Derivative</code>(PID)控制算法    通过e(t)(③)来导出系统输入u    (t)。</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211103142012406.png" alt="image-20211103142012406"> </p>
<p>RV主要有三种输入方式:配置参数(InputP)、用户命令(InputC)和环境因素(InputE)。</p>
<h4 id="调整控制算法-指定配置参数的范围"><a href="#调整控制算法-指定配置参数的范围" class="headerlink" title="调整控制算法:指定配置参数的范围"></a>调整控制算法:指定配置参数的范围</h4><p>(1) inputp允许用户配置rv如何运行的许多方面。如PID控制算法的KP、Ki、Kd表示比例项、积分项、导数项的整定参数。RVs指定配置参数的范围kp,Ki, kd来安全调整PID控制算法。</p>
<h4 id="动态操作RV-拒绝一些非法指令"><a href="#动态操作RV-拒绝一些非法指令" class="headerlink" title="动态操作RV:拒绝一些非法指令"></a>动态操作RV:拒绝一些非法指令</h4><p>(2) inputc可实现用户动态操作RV。当这些命令导致不希望的系统状态时，控制软件会拒绝一些inputc命令。例如，解除用户命令停止车辆的所有马达，当车辆在空中飞行时，控制软件不接受这样的命令。</p>
<h4 id="校正系统输出-控制传感器"><a href="#校正系统输出-控制传感器" class="headerlink" title="校正系统输出:控制传感器"></a>校正系统输出:控制传感器</h4><p>(3) InputE(如。如风和传感器噪声)也会影响系统输出y(t)。例如，当GPS信号被阻塞或显示有偏差的高度值时，控制软件会指定一个气压计传感器作为主要高度源。</p>
<h3 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><p>Fuzzing是一种自动测试技术，它随机或半随机地生成测试输入以发现程序中的错误。现有的模糊方法在处理两个主要的核心方面有所不同:<strong>输入生成</strong> 和 <strong>bug预言</strong>。</p>
<p>输入生成可以是完全随机的，也可以由一些<strong>启发式方法</strong>指导。例如，[5]、[44]、[48]等许多方法都使用<strong>代码覆盖率</strong>作为启发式方法。</p>
<p>关于bug预言，传统的模糊方法使用代码崩溃(通常由内存崩溃引起)来检测在分析的程序中触发错误的输入。</p>
<p>PGFUZZ这两个方面不同于传统的通用fuzzers。特别地，关于bug oracle，由于我们正在处理rv，我们主要的目标是发现关于rv物理状态的策略违规，以及控制软件中的软件崩溃。然后在模拟器中运行控制软件，该模拟器能够跟踪被测试的控制软件的物理状态。最后，我们定义一个度量标准来衡量我们有多“接近”违反这些策略之一。我们使用这个度量作为启发式来指导我们的输入生成。</p>
<h2 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h2><p>我们提供了一个pgfuzz瞄准的安全问题的例子。当ArduPilot无人机控制软件识别到无人机以不受控制的姿态坠落地面时，可以触发降落伞释放。此外，用户可以手动触发降落伞部署。在这两种情况下，ArduPilot官方文档都指出，要部署降落伞，同时保持无人机安全[13]，必须具备以下四个条件:(1)电机必须武装，(2)车辆不能处于FLIPorACROflight模式，(3)气压计必须显示车辆没有爬升，(4)车辆的当前高度必须高于theCHUTE_ALT_MIN 参数值。</p>
<p>基于这些需求，我们通过度量时间逻辑(MTL)来表达安全策略(A.CHUTE1)(详见章节v -A)<br>$$<br>?{(Parachute=on)}→{(Armed=true)∧(Mode_t≠FLIP/ACRO)∧(ALT_t≤ALT_t−1)∧(ALTt&gt;CHUTE-ALT-MIN)}<br>$$</p>
<p>t和ALT代表时间和海拔,?代表永远</p>
<p>针对程序崩溃的传统模糊技术显然不能检测到此类安全违规。此外，由于可能会有大量的命令和参数发生变异，因此随机向ArduPilot无人机模拟器发送命令无法有效地测试此策略。</p>
<p>此外，针对CPS的模糊方法无法发现此类安全违规，主要有两个原因。</p>
<p>首先，策略违规通常是由不同类型的系统输入的<strong>组合</strong>触发的。然而，这些方法只关注输入空间的单个部分，这意味着它们不考虑用户命令、配置参数和环境因素的统一行为。</p>
<p>其次，他们的错误预言器被设计用来检测特定的错误类型，比如偏离的飞行路径或不稳定。更详细地说，如果策略违反导致了意外的物理行为，例如，未能触发GPS故障安全模式，他们的错误oracle无法检测到这种不希望的行为，尽管失败的GPS故障安全模式导致了可能带来灾难性后果的意外状态。</p>
<p>为了解决这些限制，PGFUZZ使用 MTL公式来指导输入生成和检测安全违规。在安全策略的例子中，pgfuzz发出系统输入，触发公式的命题变量的突变。同时，它会在每次输入生成后检查是否违反了安全策略。通过使用pgfuzz，我们发现ArduPilot不正确地检查了前三个需求。这导致了违反政策，车辆在爬升时展开降落伞，导致它在地面上坠毁(详细情况见章节vii - c1)。</p>
<h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3><p>我们将设计缺陷(来自良性开发人员和用户)和恶意意图(来自对手)视为本文讨论的范围，这些缺陷可能会导致rv中的不安全或不希望的状态(例如，物理崩溃)。设计缺陷可能是由糟糕的参数文档、意外的环境条件(例如，传感器噪音和风)和错误代码造成的。我们假设开发者是良性的;然而，他们可能会错误地实现或错误地设计系统组件。此外，用户可能会在不恰当的时间发送命令或不恰当地更改配置参数，从而无意中造成安全问题。</p>
<p>在考虑恶意参与者时，我们假设对手知道导致策略违规的输入，并可以恶意触发这些输入。特别是，对手可以控制RV的三种输入。</p>
<p>(1)对手可以操纵房车的配置参数，要么在飞行前重写它们，要么在无人机起飞后更改它们(类似[41])。</p>
<p>(2)攻击者可以利用RV通信协议[43]，[58]中的已知漏洞，重放或欺骗发送给RV的用户命令。</p>
<p>(3)对手可以在发动攻击前操纵环境条件(或等待合适条件的满足)(类似[23]，[41])。</p>
<p>在第vii - b节中，我们详细说明了这些输入的每个子集的违规数量。例如，我们将展示对手仅通过更改RV的配置参数就能触发77%的策略违规。</p>
<p>对手的目标是通过暗中违反政策来影响RV的操作(例如，造成物理碰撞或扰乱RV的摄像头)。我们注意到，敌方也可以简单地通过发送恶意命令(例如，停止执行器)扔下或解除车辆;</p>
<p>然而，这些攻击不是隐形的。特别是，这种自破坏输入可以很容易地识别和防止由车辆和地面控制系统[25]，[46]执行的运行时任务监视工具。</p>
<p>相比之下，发送看似无辜的输入所引发的策略违规更隐蔽，也更难以被监控工具检测到。由于这些原因，我们不认为这些自我破坏的攻击在本文的范围内。</p>
<p>此外，物理传感器攻击(如GPS和陀螺仪欺骗)和恶意代码注入不在范围之内。主要原因是</p>
<p>(1)传感器攻击的根本原因是硬件部件(如对陀仪的声攻击[61])，而不是车辆控制程序中的代码bug;</p>
<p>(2)存在检测传感器和代码注入攻击[6]，[28]，[37]-[39]的有效技术。</p>
<p>最后，尽管pgfuzzis不是专门设计来查找浮点异常和控制器代码中的其他软件崩溃的，但是当被测试的输入触发时，它会报告它们。</p>
<h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p>在本节中，我们首先提出CPS模糊的设计挑战。然后我们提供PGFUZZ的概述。</p>
<h3 id="A-设计挑战"><a href="#A-设计挑战" class="headerlink" title="A.设计挑战"></a>A.设计挑战</h3><p>传统的模糊技术，包括那些用于CPS的 有两个主要的限制，阻止它们在现实系统中被采用为策略指导的模糊。首先，他们的bug预言不是设计来检测<strong>不希望</strong>的系统状态，这些状态不会导致系统崩溃、内存访问冲突或物理不稳定。为了解决这个限制，我们实现了行为感知<code>Behavior-aware Bug</code>Bug Oracle。我们的bug oracle通过MTL公式知道RVs的期望状态，并在模糊分析程序时检测这些公式是否被违反。</p>
<p>其次，传统fuzzers的变异引擎无法智能地为RVs<strong>生成输入</strong>。这是由于RVs的输入空间大，有几十个不同的参数和命令，每个参数和命令都可以有很宽的取值范围。为了解决这个问题，我们实现了策略引导的突变引擎。该引擎基于:</p>
<p>1)将策略的每个项与影响RV状态的输入连接起来的映射;</p>
<p>2)测量车辆当前状态与违反政策之间“距离”的距离度量。</p>
<p>突变引擎使用这些来引导输入突变走向那些更有可能生成策略违规的突变。</p>
<h3 id="B-PGFUZZ概述"><a href="#B-PGFUZZ概述" class="headerlink" title="B.PGFUZZ概述"></a>B.PGFUZZ概述</h3><p>pgfuzzing包括三个相互关联的组件，(1)预处理，(2)策略引导Fuzzing， (3) Bug后处理，如图2所示。</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211103183501212.png" alt="image-20211103183501212"> </p>
<blockquote>
<p>提取由MTL公式表示的策略    静态分析得到DFG   输入集  将这三样输入进分析引擎(确定策略)</p>
<p>关联每个政策和输入,确定哪些输入与每个政策相关(约束输入集)</p>
<p>再通过模拟器进行动态分析,提取输入和RV的状态关系</p>
</blockquote>
<blockquote>
<p>突变引擎从分析引擎中选择输入,发送到模拟器中,模拟器报告传感器测量的状态并进行噪声消除,之后计算”距离度量”</p>
<p>检查全局距离:判断是否违反策略</p>
<p>检查命题距离:改变输入,用于引导突变引擎,减少距离度量,使得输入最小化</p>
<p>导致策略违规的输入被报告给PGFUZZ的Bug后处理组件</p>
</blockquote>
<blockquote>
<p>将触发检测到的策略违规的输入序列最小化</p>
</blockquote>
<h4 id="预处理：确定策略（MTL公式），由分析引擎约束输入集（静态分析InputP，动态分析InputC和InputE）"><a href="#预处理：确定策略（MTL公式），由分析引擎约束输入集（静态分析InputP，动态分析InputC和InputE）" class="headerlink" title="预处理：确定策略（MTL公式），由分析引擎约束输入集（静态分析InputP，动态分析InputC和InputE）"></a>预处理：确定策略（MTL公式），由分析引擎约束输入集（静态分析InputP，动态分析InputC和InputE）</h4><p>在这一步中，我们<strong>确定并正式表示策略</strong>，并通过<strong>消除与确定的策略不相关的输入</strong>来减少较大的输入空间。</p>
<p>用户和开发人员通过研究RV文档，评估资产和限制资产,使用或操作的功能约束之间的联系，从而在目标系统中获得需求。然后，我们将确定的需求从自然语言转换为使用MTL公式(②)表示的策略。</p>
<p>PGFUZZ接下来运行它的<strong>分析引擎</strong>，该引擎为每个策略<strong>确定与目标策略相关的有限输入集</strong>Inputmin(即当发生突变时可能触发策略违规的有限输入集)。</p>
<p>为了实现这一点，我们首先展开配置参数(InputP)和RV物理状态之间的关系</p>
<p>(1)通过<strong>静态分析</strong>(如果RV的源代码可用)获得车辆的数据流图</p>
<p>(2)分析开发人员指南手册(③)</p>
<p>然而，使用静态分析和手册使分析用户命令(InputC)和环境因素(InputE)对状态的影响变得困难，因为</p>
<p>(1)inputc和inpute通过依赖关系间接地影响许多物理状态(例如，风影响了几乎所有的物理状态)，这些状态无法通过静态分析在源代码中捕获</p>
<p>(2)手册通常没有提到inputc和inpute对RV的状态的影响。因此，我们使用模拟器对inputc和inpute进行<strong>动态分析</strong>，以提取这些输入和RV物理状态之间的关系(④)。这个过程还使pgfuzz<strong>能够估计input_set中的每个输入所需的时间</strong>，以对RV产生物理影响。这个信息后来被PGFUZZ的突变引擎利用。</p>
<h4 id="Policy-Guided-Fuzzing：对有限的输入进行距离度量-判断是否违规"><a href="#Policy-Guided-Fuzzing：对有限的输入进行距离度量-判断是否违规" class="headerlink" title="Policy-Guided Fuzzing：对有限的输入进行距离度量,判断是否违规"></a>Policy-Guided Fuzzing：对有限的输入进行距离度量,判断是否违规</h4><p>此步骤根据计算的距离度量改变输入，并使用它们模糊分析程序，以发现策略违规。</p>
<p>突变引擎首先从Pre-Processing组件的分析引擎Inputmin(④-⑤)返回的输入中选择一个输入。这些测试输入被发送到运行系统的模拟器，并报告rv(⑥-⑦)的物理状态(例如，传感器和执行器值)。在这一步中，我们通过测量参考状态和当前系统状态之间的偏差来消除环境噪声(例如振动和风效应)(7)。然后我们计算两个独立的“距离度量”，正式定义系统与策略违规的距离(⑧):</p>
<p>(i)检查当前系统状态是否违反政策的全局距离;</p>
<p>(ii)一个命题距离，智能地改变输入，使系统更接近违反。最后，变异引擎决定特定的输入以使距离最小化。如果没有任何输入减少距离度量，则从输入策略映射中选择新的输入(⑤)。导致策略违规的输入被报告给PGFUZZ的Bug后处理组件(⑨⑩)。</p>
<h4 id="Bug后处理-将筛选出的输入输入序列最小化"><a href="#Bug后处理-将筛选出的输入输入序列最小化" class="headerlink" title="Bug后处理:将筛选出的输入输入序列最小化"></a>Bug后处理:将筛选出的输入输入序列最小化</h4><p>此步骤通过排除与策略违规无关的输入，将触发检测到的策略违规的输入序列最小化。此信息用于识别违规策略的根本原因。</p>
<h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p>在本节中，我们详细介绍了PGFUZZ, PreProcessing (SectionV -A)， Policy-Guided Fuzzing (SectionV -B)和Bug后处理(SectionV -C)的组件。</p>
<h3 id="A-预处理"><a href="#A-预处理" class="headerlink" title="A.预处理"></a>A.预处理</h3><p>预处理组件的目标是:</p>
<p>(1)推导MTL公式来表达策略</p>
<p>(2)构建一个分析引擎来缩小基于MTL公式的模糊空间。这允许我们获得最小的模糊空间(Inputmin)为策略指导的模糊组件(SectionV -B)。</p>
<h4 id="1-提取MTL政策"><a href="#1-提取MTL政策" class="headerlink" title="1)提取MTL政策"></a>1)提取MTL政策</h4><p>我们将政策称为系统必须满足的要求，才能认为车辆是安全的。</p>
<p>我们通过需求工程[20]来标识rv的策略，并用形式化逻辑表示这些策略，从而支持关于它们的形式化推理。这些策略用度量时间逻辑(MTL)[1]，[42]表示。与线性时间逻辑(LTL)[50]和计算树逻辑(CTL)[26]相比，MTL在时间约束下扩展了LTL的模式，更适合于表示RVs系统状态之间丰富的时间和因果关系。</p>
<blockquote>
<p>MTL formulas are composed of a set of atomic propositions (AP), propositional logic operators and temporal operators [42]. First,p∈APis a logical statement consisting of “terms”. A term can be a physical state of RVs, configuration parameter, or environmental factor. Turning back to theA.CHUTE1policy example in SectionIII,(ALTt&gt;CHUTE_ALT_MIN)is an AP , and the ALTtandCHUTE_ALT_MINare terms. Second, MTL supports the propositional logic operators such as conjunction (∧), disjunction (∨), and negation (¬). Third, the temporal operators include next (?I), always (?I), eventually (♦I), and until (UI) whereIdenotes any non-empty positive interval. Formally, MTL formulas can be defined as follows:ϕ::=&gt; |p| ¬ϕ|ϕ1∨ϕ2|ϕ1UIϕ2| ?Iϕ, wherep∈APand&gt;=true.</p>
</blockquote>
<p>MTL公式由一组原子命题(AP)、命题逻辑操作符和时间操作符组成。</p>
<p>首先，p∈ap是由条件“terms”组成的逻辑语句。条件可以是RV的物理状态、配置参数或环境因素。</p>
<p>转向第三节的A.CHUTE1policy的例子，(ALTt&gt;CHUTE_ALT_MIN)是一个AP，而ALTt和CHUTE_ALT_MIN是terms。</p>
<p>第二，MTL支持命题逻辑运算符，如合(∧)，析取(∨)，和否定(¬)。</p>
<p>第三，时间运算符包括next (○I)， always (□I)， eventually(♦I)， until (UI)。(I表示任何非空的正区间。)</p>
<p>形式上MTL公式可以定义为</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211104093005703.png" alt="image-20211104093005703"> </p>
<p>我们可以通过文档中定义的需求和流行的RVs、ArduPilot、PX4和Paparazzi源代码中的注释手动识别策略。用自然语言提取策略，然后用MTL公式表示。</p>
<p>为了使策略识别过程更容易，pgfuzzs为用户提供MTL模板来表达策略，如TableI所示，类似于之前的作品[29]，[66]。</p>
<p>例如，PX4的文档声明“如果在检测到GPS丢失后时间超过了com_pos_fs_delay秒, GPS故障安全必须被触发”被MTL表示为?{(GPSloss=on)→(♦[0,COM_POS_FS_DELAY+k]GPSfail=on)}(时间约束在章节7 - c4中详细说明)。</p>
<p>通过这个过程，我们为我们的目标房车确定了56个政策，ArduPilot为30个政策，PX4为21个政策，Paparazzi为5个政策(见表xiin附录)。我们测量了知识渊博的用户识别策略并将其表示为MTL公式所需的时间。特别是，两位作者花了7.5小时确定ArduPilot的政策，3.5小时确定PX4, 2.4小时确定Paparazzi。时间包括学习目标RV的官方文档/源代码，用自然语言编写策略，将它们从自然语言转换为MTL，并检测策略冲突并协调它们。</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211104201253288.png" alt="image-20211104201253288"> </p>
<h4 id="2-分析引擎"><a href="#2-分析引擎" class="headerlink" title="2)分析引擎"></a>2)分析引擎</h4><p>RV有较大的输入空间。例如，ArduPilot v.4.0.3支持1,140个配置参数(InputP)、58个user命令(InputC)、168个环境因子(InputE)。分析引擎旨在排除与模糊策略无关的输入，以减少这个巨大的输入空间。</p>
<p>图3显示了分析引擎的六个步骤。</p>
<ul>
<li>在第一步(①)中，我们将每个<strong>策略映射</strong>到一个术语列表中，其中每个术语表示RV的物理状态、配置参数或环境因素。例如,一个。“Achute1policy2”被分解为5个术语:(1)降落伞、武装、模式和高度是RV的物理状态;(2)“chute_alt_mini”是一个配置参数。我们将此映射称为policy-term (1a)。</li>
<li>其次，我们通过静态分析将<strong>inputp映射</strong> 到术语，来确定哪些策略术语与inputp(2)相关。我们将这个映射称为参数项(2a)。举例说明，ABS_PRESS配置参数是计算气压高度的偏移值。pgfuzz_testa在其模糊输入空间中包含了abs_presparameter。“CHUTE1policy”，用于计算高度状态。</li>
<li>第三，我们通过<strong>依赖分析</strong>来推导inputp,InputC, InputE这些输入和策略之间的关系(3)。例如，用户希望通过aparachuteccommand部署降落伞，需要更改echute_enabled配置参数(3a)。因此，确定了Parachuteuser命令和配置参数CHUTE_ENABLEDis之间的依赖关系。</li>
<li>第四，我们使用RV模拟器执行动态分析，从构造的参数项映射(2a)中<strong>排除只读和不支持的inputp</strong>。这一步对于减少参数项映射大小至关重要。然后我们通过<strong>动态分析</strong>(4)mapInputCandInputEinto策略条款。例如，A.CHUTE1policy包括海拔决定。pgfuzzs在其模糊空间中包含了wind_speed_环境参数(见input -term map (4b))，因为它改变了车辆的高度。这里，我们排除了abs_pressconfiguration参数。虽然它与策略的高度决定有关，但ABS_PRESS是一个只读参数</li>
<li>第五(5)，分析引擎首先从输入项映射4a、4b和4c中提取与每个策略相关的输入，然后<strong>构造输入策略映射</strong>(5a)。例如,theA.CHUTE1policy包括the altitude term。分析引擎发现与高度相关的输入，包括风速和降落伞，如图3所示。(SeeInputP-term map (4a))。</li>
<li>最后，分析了MTL公式(6)的未知时间约束。A.brake1policy3表示为?{(Modet=BRAKE)→(♦[0,k]Post=Post−1)}。为了检测真正的积极的政策违规，我们通过对输入政策图(5a)进行动态分析来<strong>获得未知的时间约束</strong>。</li>
</ul>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211104201522226.png" alt="image-20211104201522226"> </p>
<h5 id="将每个策略映射为术语-1-。-policy-terms映射"><a href="#将每个策略映射为术语-1-。-policy-terms映射" class="headerlink" title="将每个策略映射为术语(1)。(policy-terms映射)"></a>将每个策略映射为术语(1)。(policy-terms映射)</h5><p>一个策略由RV的物理状态、配置参数和环境因素组成。在这一步中，我们将每个策略分解成术语，并对每个术语进行进一步分析，以找到需要模糊的相关输入(详见下文)。</p>
<p>首先，我们通过研究RVs的手册手工构建一个物理状态列表(例如，高度，滚动角度)(完整的状态列表显示在tablexiappendix xa中)。如果策略包含这些状态之一，则将其标记为物理状态并添加到Policy-term映射中。转向A.CHUTE1policy，降落伞，武装，模式和高度都是物理状态，并添加到policy-term map (1a)中。</p>
<p>其次，策略可能包含配置参数(InputP)和环境因素(InputE)，因为车辆的操作取决于它们的值。我们搜索每个包含inputp和inpute 的术语，以找出一个策略是否包含它们。如果有匹配，我们以类似的方式将这些术语添加到policy-term映射中。例如,A.CHUTE1policy包含eschute_alt_min配置参数，没有环境因素作为术语;因此，将theCHUTE_ALT_MINis添加到策略-term映射中。</p>
<h5 id="缩小Fuzzing空间的静态分析-2-def-use链→Synonym-table"><a href="#缩小Fuzzing空间的静态分析-2-def-use链→Synonym-table" class="headerlink" title="缩小Fuzzing空间的静态分析(2) (def-use链→Synonym table)"></a>缩小Fuzzing空间的静态分析(2) (def-use链→Synonym table)</h5><p>静态分析用于识别与每个配置参数相关的术语(InputP,图3中的②和(2a))。我们使用两种互补的方法来识别相关术语:</p>
<p>(1)在LL VM中间表示(IR)级别进行静态分析</p>
<p>(2)解析车辆手册。</p>
<ol>
<li>首先，我们将RV<strong>手册上的每个配置参数映射</strong>到源代码中的一个变量。这允许我们知道控制程序是如何将参数导入源代码的。</li>
</ol>
<p>例如，我们的目标控制程序(如ArduPilot、PX4和Paparazzi)解析包含参数名称列表和有效范围的XML文件，然后在源代码中将它们转换为变量。图4显示了每个控制程序如何访问导入的配置参数。ArduPilot和PX4将参数存储为类的数据成员，并通过函数调用或直接访问数据成员访问参数。Paparazzi通过全局变量将参数的值加载到内存的数据部分。</p>
<ol start="2">
<li>其次，我们构建了已识别参数变量的def -use链，将每个参数映射到MTL公式中的相关术语(图2中的3)。我们使用LL VM来获取代码中定义这些术语的def-use链。加载我们前面确定的导入参数的代码可以作为构建这些def-use链的起点。对于标量，我们递归地执行加载和存储操作。对于指针，为了通过指针引用/解引用操作符识别数据流，我们执行一个过程间、路径不敏感和流敏感的点分析[62]。</li>
</ol>
<p>更准确地说,分析引擎运作三个步骤:</p>
<p>(1)执行Andersen的指针分析[8]以识别参数变量的别名</p>
<p>(2)将代码转换为单一静态分配形式[59]和构建数据流图(DFG)</p>
<p>(3)从构建的DFG中收集已识别参数变量的def-use链。</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211107131254034.png" alt="image-20211107131254034"> </p>
<blockquote>
<p>说明控制程序在将参数导入其源代码后如何访问参数的代码块。蓝色的变量表示参数。</p>
</blockquote>
<ol start="3">
<li>第三，我们手工构造一个同义词表(Synonym table)。</li>
</ol>
<p>这个表将源代码变量名映射到MTL公式中用作术语的名称。使用这个表和先前生成的def -use链，分析步骤可以确定哪个源代码变量对应于所考虑的MTL公式中的哪个项，然后，哪个输入影响哪个内部变量(图5)。通过这种方式，pgfuzzz知道应该对哪些输入进行突变，以影响所识别的MTL公式中的特定项。</p>
<p>例如，这个步骤发现try配置参数用于海拔状态，因为在320行的海拔读取temp参数，来自TEMP参数值。通过使用这些知识，pgfuzz_在测试A.CHUTE1policy时改变TEMP。由于该政策包括海拔状态(图3中的1a)。我们手动为ArduPilot、PX4和Paparazzi构建同义词表。</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211107132000839.png" alt="image-20211107132000839"> </p>
<blockquote>
<p>一个示例代码块和def -use链用于演示分析引擎的静态分析逻辑，该逻辑递归地搜索defu -use链的读访问，并将读访问中的变量名与同义词进行比较</p>
</blockquote>
<p>最后，分析引擎解析由RVs控制软件开发人员以XML文件格式提供的官方文档。本文档描述了每个配置参数的作用。它被设计用来帮助开发人员和/或用户。分析引擎首先从文档中每个参数的描述中提取所有单词，然后将提取的单词与同义词表进行匹配。</p>
<p>例如，ArduPilot的手册声明“这是一个角度限制(保持高度)时间常数”，以解释ATC_ANG_LIM_TCparameter的作用。我们的分析步骤将ATC_ANG_LIM_TC参数与海拔项匹配。</p>
<h5 id="输入之间的依赖性-3-。"><a href="#输入之间的依赖性-3-。" class="headerlink" title="输入之间的依赖性(3)。"></a>输入之间的依赖性(3)。</h5><p><strong>一些输入需要在其他输入之前执行</strong>。例如，只有当CHUTE_ENABLEDparameter为true时，才能触发parachuteccommand。在这个步骤中，我们首先找到这样的输入，除非有另一个输入在前面，否则这些输入是无效的。</p>
<p>然后，我们<strong>确定应该首先执行哪个输入来执行目标输入</strong>。此外，我们通过<strong>消除RV模拟器不支持的用户命令</strong>(InputC)和<strong>配置参数</strong>(InputP)来缩小模糊输入(图3中的4)。</p>
<p>首先，我们发现那些input和input，除非前面有另一个输入，否则它不能有效。为此，我们采取了以下步骤。(1)在每一操作模式(如FLIPflight模式)下，我们记录一分钟内所有状态值(如高度和滚转角度)，无需任何输入。然后，我们计算每个车辆状态的标准差(SD{state (i)})。(2)给inputjwhereinputj∈InputC∪InputP赋一个随机值(randj)，并在模拟器中执行。具体来说，当输入需要布尔值时，我们将随机赋值为真或假，当输入为连续值时，则赋值在车辆文档中指定的有效范围内。如果文档没有明确提到有效范围，我们将在-232−232范围内分配一个随机数。(3)然后我们记录每一种操作模式一分钟内的所有状态值。重复这三个步骤10次，计算每个车辆状态的标准差(SD{state (i,j)})。完成这些步骤后，我们得到两种状态:没有任何输入的状态和有inputj的状态。如果输入不影响任何状态值(|SD{state (i)}−SD{state (i,j)}|</p>
<p>其次，为了找到另一个使inputj被激活的输入，我们执行以下步骤:(1)选择另一个inputinputkwhereinputk∈InputC∪InputP。我们给输入赋一个随机值，然后在模拟器中执行它。(3)使飞行器处于稳定状态(即相同的位置和姿态)。(4)我们将之前的usedrandj分配给inputj并在模拟器中执行它，同时为每个操作模式记录一分钟的所有状态值。(5)我们检查inputjstill是否不影响任何状态值(即，|SD{state (i)}−SD{state (i,kj)}|SD{state (i)})，我们得出结论，inputjrequire inputkto被执行。然而，如果没有一个inputkcan使能inputj，我们推断模拟器不支持那个inputj。</p>
<h5 id="缩小模糊空间的动态分析-4-。"><a href="#缩小模糊空间的动态分析-4-。" class="headerlink" title="缩小模糊空间的动态分析(4)。"></a>缩小模糊空间的动态分析(4)。</h5><p>在这一步中，我们分析车辆的哪些状态根据执行的输入而改变。我们首先在执行前一步中描述的inputjas时收集所有状态值(输入之间的依赖关系(图3中的3in))。如果|SD{State(i)}−SD{State(i,j)}|&gt;SD{State(i)}，则可以得出inputjchanges theState。为了说明这一点，图6描述了ArduPilot中throttleuser命令的动态分析结果。节流阀用户命令影响车辆的四种状态:航向、节流阀、高度和爬升。图6还显示了根据飞行模式，节气门命令对飞行器的影响是不同的。这是因为飞行器会根据飞行模式对节气门指令做出不同的解释(或忽略)。例如，测试theA。chut1policy, pgfuzzate throttleccommand因为它影响飞行器的高度。</p>
<h5 id="提取与每个策略相关的输入-5-。"><a href="#提取与每个策略相关的输入-5-。" class="headerlink" title="提取与每个策略相关的输入(5)。"></a>提取与每个策略相关的输入(5)。</h5><p>在这一步中，我们首先从输入项映射4a、4b和4c中提取与每个策略相关的输入。然后，我们构造输入策略映射(5a)。它表示每个策略的一组输入，其中pgfuzzl将更改这些输入以测试每个策略。</p>
<h5 id="分析MTL公式-6-中的未知时间约束。"><a href="#分析MTL公式-6-中的未知时间约束。" class="headerlink" title="分析MTL公式(6)中的未知时间约束。"></a>分析MTL公式(6)中的未知时间约束。</h5><p>在这一步中，我们确定MTL公式中的未知时间限制(例如，当车辆处于inBRAKEmode时，它必须在think秒内停止:?{(Modet=BRAKE)→(♦[0,k]Post=Post−1)})。这确保检测到的策略违规是真实的阳性。为此，我们采取以下步骤:(1)将政策分解为条款，例如，theA。BRAKE1policy(上面定义的)由两个术语组成:模式和位置。这个过程在《将每个策略映射到条款》中有详细的解释。</p>
<p>(2)从图3中的input-policy map5中随机选择一个与策略相关的输入，</p>
<h3 id="B-Policy-Guided-Fuzzing"><a href="#B-Policy-Guided-Fuzzing" class="headerlink" title="B.Policy-Guided Fuzzing"></a>B.Policy-Guided Fuzzing</h3><p>policy - guided Fuzzing组件在给定最小的输入空间的情况下发现策略违规。</p>
<h4 id="Policy-Guided-Fuzzing概述"><a href="#Policy-Guided-Fuzzing概述" class="headerlink" title="Policy-Guided Fuzzing概述:"></a>Policy-Guided Fuzzing概述:</h4><p>算法1细化了Policy-Guided Fuzzing组件的步骤。</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211117132141336.png" alt="image-20211117132141336"> </p>
<p>算法重复进行如下操作:</p>
<p>(1) 从inputmin和15行的input-policy映射中随机选取一个输入</p>
<p>(2) 根据第16行的命题距离为所选输入赋值。</p>
<p>例如，当pgfuzz增加输入的值并导致命题距离的增加时，当pgfuzze再次选择输入时,继续给输入赋相同的值</p>
<p>(3) 在模拟器的第5行执行突变输入</p>
<p>(4) 消除第6行物理状态的环境噪声</p>
<p>(5) 根据第7行的状态变化计算距离</p>
<p>(6) 如果pgfuzz8在第8行检测到策略违规，它将所有突变的输入(input_seq)发送到第11行的Post Bug-Processing组件</p>
<p>pgfuzzs重复这些步骤，直到它检测到策略违规，或者达到用户定义的上限(τ)。</p>
<h4 id="Noise-Elimination"><a href="#Noise-Elimination" class="headerlink" title="Noise Elimination"></a>Noise Elimination</h4><p>例如，让我们假设突变引擎的目标是最小化高度(以触发策略违规)</p>
<p>在timeT=1时，Alt=15。</p>
<p>pgfuzz执行一个输入来降低电机的速度。</p>
<p>正常情况下，这个输入会降低高度。</p>
<p>但是，当输入同时出现强风和传感器噪声时，高度增加2米，T=2 时 Alt=17。</p>
<p>然后，PGFUZZ错误地确定执行输入来减速电机的速度从而增加了高度。</p>
<p>因此，在T=3时，发动机的速度增加，从而进一步增加高度。</p>
<p>为了解决这一问题，我们在飞行控制软件的控制算法中使用了参考状态值。</p>
<p>例如，ArduPilot的控制算法一直在计算参考高度ALTref，即没有噪声的预期高度值。</p>
<p>参考高度用于计算高度误差，如ALTerr = ALTref−ALTact，其中ALTact为传感器测量的高度。</p>
<p>因此，alt err表示测量高度和预期高度之间的差值。</p>
<p>控制程序通过滤波算法(如卡尔曼滤波)来计算参考状态。</p>
<p>然而，参考状态仍然包括恶劣环境条件下的噪声(例如，10m /s风速)。</p>
<p>为了处理这个问题，PGFUZZ还利用移动平均来消除环境噪声:Moving_average(State_iact+State_ierr) 其中state_i表示每个状态</p>
<h4 id="Policy-Checker"><a href="#Policy-Checker" class="headerlink" title="Policy Checker"></a>Policy Checker</h4><p>策略检查器在仿真中评估RV状态的MTL公式。</p>
<p>给定MTL公式和RV在执行模糊输入后的物理状态</p>
<p>策略检查器输出</p>
<p>(i)命题距离来引导突变引擎</p>
<p>(ii)全局距离来将违规的策略报告给bug oracle。</p>
<p>策略检查器首先将always形式的MTL公式转换为not eventually形式的MTL公式，然后用算术方法计算距离。</p>
<p>首先，策略检查器将“imply”运算符(→)转换为“and”运算符(∧)，并对“imply”运算符右侧的命题进行否定</p>
<p>其次，策略检查器导出命题距离作为一个标准化的差异，并使用它们来计算全局距离</p>
<p>如果命题为真，我们定义命题距离为正值，如果命题为假，则为负值。</p>
<p>特别地，如果命题中的条件是二元的(如Parachute=on)，当命题满足时，距离设为1，当命题不满足时，距离设为−1。</p>
<p>相比之下，数值距离是标准化/归一化来计算的</p>
<p>降落伞策略的命题距离(P1−P5)为:</p>
<p><img src="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-fuzz%E8%AE%BA%E6%96%87/image-20211113163411132.png" alt="image-20211113163411132"> </p>
<p>我们根据命题距离计算全局距离。</p>
<p>特别地，全局距离是通过将“not”、“and”、“or”转换为−1、min和max得到的</p>
<p>为了自动生成代码片段来计算命题距离和全局距离，策略检查器首先根据转换后的not eventually形式的MTL公式创建一个二进制表达式树，然后遍历树的节点。</p>
<p>最后，当全局距离为负时，策略检查器会标记策略违规。</p>
<h4 id="Mutation-Engine"><a href="#Mutation-Engine" class="headerlink" title="Mutation Engine"></a>Mutation Engine</h4><p>变异引擎将输入 输入 到模拟器以最小化全局距离，其中全局距离的负值表示策略违规。</p>
<p>我们注意到，最大化命题距离(并使它们为正)会导致最小化全局距离(并使其为负)，因为在计算全局距离时，命题距离是负的。</p>
<p>突变引擎进行以下步骤来最大化命题距离。</p>
<p>(1)它首先从目标策略的input min中随机选择一个输入，这个输入存储在input-policy映射中。然后，它随机选择一个值并将其分配给输入。</p>
<p>(2)在模拟器上执行选择的输入，计算命题距离和全局距离，如果全局距离变为负，标志策略违规。</p>
<p>(3)如果执行的输入增加了命题距离，突变引擎将输入存储为指定的值。</p>
<p>(4)当突变引擎再次随机选择存储的输入(如改变海拔高度)时，它将存储的值应用到输入中，而不是随机给输入赋一个新值。</p>
<p>突变引擎重复步骤(1)-(4)，直到发现策略违规。</p>
<p>如果PGFUZZ找不到策略违规，它将在输入序列的大小超过1,000或模糊时间超过2小时时停止模糊。</p>
<p>然后，将目标策略更改为另一个策略。</p>
<h3 id="C-Bug-Post-Processing"><a href="#C-Bug-Post-Processing" class="headerlink" title="C. Bug Post-Processing"></a>C. Bug Post-Processing</h3><p>PGFuzz执行错误后处理以查找导致策略冲突的最小输入序列。</p>
<p>最小化的序列稍后可用于分析违规的根本原因。</p>
<p>Bug后处理包括Bug池和输入最小化步骤。</p>
<p>bug池首先使用导致策略冲突的输入序列存储冲突策略（policyV）。</p>
<p>输入序列由每对输入和变异值（input i，value i）组成，其中inputi∈Inputmin。</p>
<p>输入序列包括从模糊策略开始到发现策略冲突的所有输入和值。</p>
<p>因此，它可能包含一些不会导致策略冲突i的输入(可以在不执行某些输入的情况下触发相同的策略冲突。)</p>
<p>例如，输入序列{（mode=ACRO），（wind=5），（campole=on）}违反了a。Chute1政策5。但是，（风=5）不会导致违反政策。</p>
<p>为了找到导致策略冲突的输入，输入最小化步骤的操作如下</p>
<p>（1） 创建一个新进程来执行一个单独的模拟器。</p>
<p>（2） 从导致冲突的原始输入序列（input（1，…，n））中排除输入（input i）来创建新的输入序列。</p>
<p>（3） 将新的输入序列在模拟器中执行</p>
<p>（4） 如果新的输入序列不会导致相同的策略冲突，则被去掉的输入值一定违反策略。</p>
<p>重复步骤（2）到（4），直到输入最小化步骤找到一个最小化的输入序列，该序列仍然导致相同的策略冲突。</p>
<p>用户可以根据违反策略的最小化输入序列轻松执行根本原因分析。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E8%AE%BA%E6%96%87/" rel="tag"># 论文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/27/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.27-%E6%A0%88%E6%BA%A2%E5%87%BAbuu1/" rel="next" title="10.27-栈溢出buu1">
                <i class="fa fa-chevron-left"></i> 10.27-栈溢出buu1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/31/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.31-SMC/" rel="prev" title="10.31-SMC">
                10.31-SMC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">95</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RV%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">RV的重要性以及主要面临的安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E6%95%88%E6%9E%9C-%E4%BB%A5%E6%97%B6%E9%97%B4%E7%BA%A6%E6%9D%9F%E4%B8%BA%E6%8C%87%E5%AF%BC-%E6%B5%8B%E9%87%8FRV%E4%B8%8E%E7%AD%96%E7%95%A5%E8%BF%9D%E8%A7%84%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">作用效果:以时间约束为指导,测量RV与策略违规的距离度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4-%E9%80%9A%E8%BF%87%E5%8A%A8%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%AD%9B%E9%80%89%E5%87%BA%E5%BD%B1%E5%93%8D%E7%AD%96%E7%95%A5%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">作用范围:通过动静态分析筛选出影响策略的命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E5%89%8D%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E6%A3%80%E6%9F%A5RV%E8%BF%9D%E5%8F%8D%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">以前的模糊方法无法检查RV违反策略问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5-%E5%AF%BB%E6%89%BE%E4%B8%8E%E7%AD%96%E7%95%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BE%93%E5%85%A5"><span class="nav-number">2.2.</span> <span class="nav-text">预处理阶段:寻找与策略相关的输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E5%BC%95%E5%AF%BC-%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81-%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">策略引导:收集系统状态,计算距离度量,</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bug%E5%90%8E%E5%A4%84%E7%90%86-%E6%8E%92%E9%99%A4%E6%97%A0%E5%85%B3%E8%BE%93%E5%85%A5-%E7%A1%AE%E8%AE%A4%E8%BF%9D%E8%A7%84%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.4.</span> <span class="nav-text">Bug后处理:排除无关输入,确认违规的根本原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AF%87%E8%AE%BA%E6%96%87%E5%81%9A%E5%87%BA%E4%BA%86%E4%BB%A5%E4%B8%8B%E8%B4%A1%E7%8C%AE"><span class="nav-number">2.5.</span> <span class="nav-text">本篇论文做出了以下贡献</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E5%B7%B2%E7%9F%A5%E7%AD%96%E7%95%A5%E6%9D%A5%E5%AF%BB%E6%89%BEBug"><span class="nav-number">2.5.1.</span> <span class="nav-text">用已知策略来寻找Bug</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Policy-Guided%E7%AA%81%E5%8F%98%E5%BC%95%E6%93%8E%E3%80%82"><span class="nav-number">2.5.2.</span> <span class="nav-text">Policy-Guided突变引擎。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RV%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E3%80%82"><span class="nav-number">3.1.</span> <span class="nav-text">RV的输入和输出。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">3.1.1.</span> <span class="nav-text">调整控制算法:指定配置参数的范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%93%8D%E4%BD%9CRV-%E6%8B%92%E7%BB%9D%E4%B8%80%E4%BA%9B%E9%9D%9E%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.2.</span> <span class="nav-text">动态操作RV:拒绝一些非法指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%A1%E6%AD%A3%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%87%BA-%E6%8E%A7%E5%88%B6%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">校正系统输出:控制传感器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fuzzing"><span class="nav-number">3.2.</span> <span class="nav-text">Fuzzing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B"><span class="nav-number">4.</span> <span class="nav-text">典型案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">威胁模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">5.</span> <span class="nav-text">方法概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-%E8%AE%BE%E8%AE%A1%E6%8C%91%E6%88%98"><span class="nav-number">5.1.</span> <span class="nav-text">A.设计挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-PGFUZZ%E6%A6%82%E8%BF%B0"><span class="nav-number">5.2.</span> <span class="nav-text">B.PGFUZZ概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%9A%E7%A1%AE%E5%AE%9A%E7%AD%96%E7%95%A5%EF%BC%88MTL%E5%85%AC%E5%BC%8F%EF%BC%89%EF%BC%8C%E7%94%B1%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E%E7%BA%A6%E6%9D%9F%E8%BE%93%E5%85%A5%E9%9B%86%EF%BC%88%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90InputP%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90InputC%E5%92%8CInputE%EF%BC%89"><span class="nav-number">5.2.1.</span> <span class="nav-text">预处理：确定策略（MTL公式），由分析引擎约束输入集（静态分析InputP，动态分析InputC和InputE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Policy-Guided-Fuzzing%EF%BC%9A%E5%AF%B9%E6%9C%89%E9%99%90%E7%9A%84%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%BF%9D%E8%A7%84"><span class="nav-number">5.2.2.</span> <span class="nav-text">Policy-Guided Fuzzing：对有限的输入进行距离度量,判断是否违规</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bug%E5%90%8E%E5%A4%84%E7%90%86-%E5%B0%86%E7%AD%9B%E9%80%89%E5%87%BA%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-number">5.2.3.</span> <span class="nav-text">Bug后处理:将筛选出的输入输入序列最小化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.</span> <span class="nav-text">组件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">6.1.</span> <span class="nav-text">A.预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8F%90%E5%8F%96MTL%E6%94%BF%E7%AD%96"><span class="nav-number">6.1.1.</span> <span class="nav-text">1)提取MTL政策</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E"><span class="nav-number">6.1.2.</span> <span class="nav-text">2)分析引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%AF%8F%E4%B8%AA%E7%AD%96%E7%95%A5%E6%98%A0%E5%B0%84%E4%B8%BA%E6%9C%AF%E8%AF%AD-1-%E3%80%82-policy-terms%E6%98%A0%E5%B0%84"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">将每个策略映射为术语(1)。(policy-terms映射)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%A9%E5%B0%8FFuzzing%E7%A9%BA%E9%97%B4%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90-2-def-use%E9%93%BE%E2%86%92Synonym-table"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">缩小Fuzzing空间的静态分析(2) (def-use链→Synonym table)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E6%80%A7-3-%E3%80%82"><span class="nav-number">6.1.2.3.</span> <span class="nav-text">输入之间的依赖性(3)。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%A9%E5%B0%8F%E6%A8%A1%E7%B3%8A%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90-4-%E3%80%82"><span class="nav-number">6.1.2.4.</span> <span class="nav-text">缩小模糊空间的动态分析(4)。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E4%B8%8E%E6%AF%8F%E4%B8%AA%E7%AD%96%E7%95%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BE%93%E5%85%A5-5-%E3%80%82"><span class="nav-number">6.1.2.5.</span> <span class="nav-text">提取与每个策略相关的输入(5)。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%9E%90MTL%E5%85%AC%E5%BC%8F-6-%E4%B8%AD%E7%9A%84%E6%9C%AA%E7%9F%A5%E6%97%B6%E9%97%B4%E7%BA%A6%E6%9D%9F%E3%80%82"><span class="nav-number">6.1.2.6.</span> <span class="nav-text">分析MTL公式(6)中的未知时间约束。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Policy-Guided-Fuzzing"><span class="nav-number">6.2.</span> <span class="nav-text">B.Policy-Guided Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Policy-Guided-Fuzzing%E6%A6%82%E8%BF%B0"><span class="nav-number">6.2.1.</span> <span class="nav-text">Policy-Guided Fuzzing概述:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Noise-Elimination"><span class="nav-number">6.2.2.</span> <span class="nav-text">Noise Elimination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Policy-Checker"><span class="nav-number">6.2.3.</span> <span class="nav-text">Policy Checker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutation-Engine"><span class="nav-number">6.2.4.</span> <span class="nav-text">Mutation Engine</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Bug-Post-Processing"><span class="nav-number">6.3.</span> <span class="nav-text">C. Bug Post-Processing</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzlg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
