<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="论文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="IDA动调 之前有个老师组里招人,报名了,今天给了篇论文 虽然现在感觉好忙,但是先试试吧">
<meta property="og:type" content="article">
<meta property="og:title" content="10.26-Rex论文">
<meta property="og:url" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/index.html">
<meta property="og:site_name" content="hzlg&#39;s blog">
<meta property="og:description" content="IDA动调 之前有个老师组里招人,报名了,今天给了篇论文 虽然现在感觉好忙,但是先试试吧">
<meta property="og:locale">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027135244559.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027134915786.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027135035036.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027142725042.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027145628319.png">
<meta property="article:published_time" content="2021-10-26T10:36:50.175Z">
<meta property="article:modified_time" content="2021-10-27T14:14:36.522Z">
<meta property="article:author" content="hzlg">
<meta property="article:tag" content="论文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027135244559.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hzlg.github.ioz/2021/10/26/每日博客/10.26-Rex论文/"/>





  <title>10.26-Rex论文 | hzlg's blog</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzlg's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记、日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzlg.github.ioz/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzlg's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">10.26-Rex论文</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-26T18:36:50+08:00">
                2021-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>IDA动调</p>
<p>之前有个老师组里招人,报名了,今天给了篇论文</p>
<p>虽然现在感觉好忙,但是先试试吧</p>
<span id="more"></span>

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>Abstract<br>Large services experience extremely frequent changes to code and configuration. In many cases, these changes are correlated across files.<br>For example, an engineer introduces a new feature following which they also change a configuration file to enable the feature only on a small number of experimental machines. This example captures only one of numerous types of correlations that emerge organically in large services.<br>Unfortunately, in almost all such cases, no documentation or specification guides engineers on how to make correlated changes and they often miss making them. Such misses can be vastly disruptive to the service.<br>We have designed and deployed Rex, a tool that, using a combination of machine learning and program analysis, learns change-rules that capture such correlations.<br>When an engineer changes only a subset of files in a change-rule, Rex suggests additional changes to the engineer based on the change-rule.<br>Rex has been deployed for 14 months on 360 repositories within Microsoft that hold code and configuration for services such as Office 365 and Azure. Rex has so far positively affected 4926 changes without which, at the very least, codequality would have degraded and, in some cases, the service would have been severely disrupted.</p>
</blockquote>
<p>大型服务会经历极其频繁的代码和配置更改。在许多情况下，这些更改与文件相关。<br>例如，工程师引入了一个新功能，然后他们还更改了配置文件，以仅在少数实验机器上启用该功能。此示例仅捕获在大型服务中自然出现的众多关联类型中的一种。不幸的是，在几乎所有这些情况下，没有文档或规范指导工程师如何进行相关的更改，而且他们经常错过进行更改。此类未命中可能会极大地破坏服务。<br>我们设计并部署了 Rex，这是一种工具，它<strong>结合使用机器学习和程序分析，学习捕获此类相关性的更改规则</strong>。<br>当工程师仅更改更改规则中的一部分文件时，Rex 会根据更改规则向工程师建议其他更改。<br>Rex 已在 Microsoft 内部的 360 存储库中部署了 14 个月，这些存储库包含 Office 365 和 Azure 等服务的代码和配置。到目前为止，Rex 已经对 4926 次更改产生了积极影响，如果没有这些更改，至少会降低代码质量，并且在某些情况下，服务会严重中断。</p>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote>
<p>Introduction</p>
<p>Large-scale services run on a foundation of very large codebases and configuration repositories. To run uninterrupted, a service not only depends on correct code, but also on correct network and security configuration, and suitable deployment specification. This causes various dependencies both within and across components/sources of the service which emerge organically. When an engineer changes a certain region of code or configuration, these dependencies require them to make changes to other code or configuration regions.<br>For instance, when an engineer adds a new feature to a service, they may need to add a function to test the feature. Also, they may need to configure the service to deploy the new feature only to a small set of machines to test it further. Similarly, when an engineer renames a service API, they must also change firewall rule specifications so that the rules apply to the now renamed API rather than to the old one.</p>
</blockquote>
<h3 id="大规模服务组件和源之间有依赖关系"><a href="#大规模服务组件和源之间有依赖关系" class="headerlink" title="大规模服务组件和源之间有依赖关系"></a>大规模服务组件和源之间有依赖关系</h3><p>大规模服务在非常大的代码库和配置存储库的基础上运行。 要不间断地运行，服务不仅取决于正确的代码，还取决于正确的<strong>网络和安全配置以及合适的部署规范</strong>。 这导致在服务的组件/源之间和内部<strong>出现的各种依赖关系</strong>有机地出现。 当工程师更改代码或配置的某个区域时，这些依赖项要求他们对其他代码或配置区域进行更改。<br>例如，当工程师向服务添加新功能时，他们可能需要添加功能来测试该功能。 此外，他们可能需要配置服务以仅将新功能部署到一小组机器以进一步测试。 同样，当工程师重命名服务 API 时，他们还必须更改防火墙规则规范，以便规则适用于现在重命名的 API，而不是旧的 API。</p>
<blockquote>
<p>Such correlations can occur between code files across components, between code and configuration files, or between configuration files. Unfortunately, unlike pure code, which goes through compilation, reviewing and systematic testing to weed out bugs, these correlations are often not specified, checked for, and are left undocumented. Consequently engineers, with no documentation or specification to go by, often miss making necessary changes to code or configuration files.<br>This can delay deployment, increase security risks and, in some cases, even disrupt the service completely. Disruptions due to such correlations are surprisingly frequent [12].<br>For instance, an engineer recently caused a disruption at Salesforce because they did not perform all necessary dependent configuration changes related to a change they initiated [22].<br>To address this problem, we present Rex, a tool that learns these correlations using a combination of machine learning and program analysis. Using association rule mining on many months of file changes, Rex determines sets of files that often change together. Rex also uses differential syntax analysis to learn change-rules: each change-rule captures a set of correlated changes across files. When an engineer makes a file change, Rex analyzes the change and uses the changerules to suggest additional changes if required.</p>
</blockquote>
<h3 id="依赖关系没有规定来指导-未进行全面的修改可能造成严重后果-Rex通过机器学习来提出建议"><a href="#依赖关系没有规定来指导-未进行全面的修改可能造成严重后果-Rex通过机器学习来提出建议" class="headerlink" title="依赖关系没有规定来指导,未进行全面的修改可能造成严重后果,Rex通过机器学习来提出建议"></a>依赖关系没有规定来指导,未进行全面的修改可能造成严重后果,Rex通过机器学习来提出建议</h3><p>这种关联可能发生在跨组件的代码文件之间、代码和配置文件之间或配置文件之间。不幸的是，与经过编译、审查和系统测试以消除错误的纯代码不同，这些相关性通常没有指定、检查和未记录。因此，没有文档或规范可供参考的工程师经常错过对代码或配置文件进行必要的更改。<br>这可能会延迟部署、增加安全风险，并且在某些情况下甚至会完全中断服务。由于这种相关性而造成的中断出奇地频繁 [12]。<br>例如，一位工程师最近在 Sales force 中造成了中断，因为他们没有执行与他们发起的更改相关的所有必要的相关配置更改 [22]。<br>为了解决这个问题，我们提出了 Rex，这是一种结合机器学习和程序分析来学习这些相关性的工具。 Rex 对数月的文件更改使用关联规则挖掘，确定经常一起更改的文件集。 Rex 还使用差异语法分析来学习更改规则：每个更改规则捕获一组跨文件的相关更改。当工程师进行文件更改时，Rex 会分析更改并在需要时使用更改规则来建议其他更改。</p>
<blockquote>
<p>While the idea of using association rule mining to determine correlations in code and configuration has been proposed before [6, 35, 37], previous work has not concentrated on generalizing the algorithm. To the best of our knowledge, Rex is the first tool that combines association rule mining with syntactic analysis to determine change-rules. Moreover, Rex takes the crucial step of making correlated change analysis generalize well to multiple file-types and services, and deploying it at a large-scale. We do this through three key observations made by studying the characteristics of services:</p>
</blockquote>
<h3 id="Rex将规则挖掘和句法分析结合-在大量部署并观察后提出三个结果"><a href="#Rex将规则挖掘和句法分析结合-在大量部署并观察后提出三个结果" class="headerlink" title="Rex将规则挖掘和句法分析结合,在大量部署并观察后提出三个结果"></a>Rex将规则挖掘和句法分析结合,在大量部署并观察后提出三个结果</h3><p>虽然在[6,35,37]之前已经提出了使用关联规则挖掘来确定代码和配置中的相关性的想法，但之前的工作并未集中在算法的泛化上。 据我们所知，Rex 是第一个将关联规则挖掘与句法分析相结合以确定更改规则的工具。 此外，Rex 采取了关键步骤，使相关变更分析能够很好地推广到多种文件类型和服务，并进行大规模部署。 我们通过研究服务的特征得出的三个关键观察结果来做到这一点： </p>
<blockquote>
<ol>
<li>Correlations occur in a multitude of unpredictable ways.<br>Consequently, Rex’s algorithm should not rely on any hardcoded domain knowledge, neither should it depend on any manual configuration or tuning.</li>
<li>Configuration management practice varies widely across services and projects. Every service has distinct configuration management and maintenance strategies as a result of which machine learning models have to be service or projectspecific, with no extrapolation from one to the other. To make matters even more challenging, even a single service or project can change characteristics significantly over time. Hence, Rex’s models have to be periodically retrained so that its suggestions can be accurate.</li>
<li>Care has to be taken while applying association rule mining on large code and configuration files. Services depend upon a large amount of code and configuration. Applying rule mining which is exponential in the size of the input at the level of individual code and configuration constructs is simply not feasible. We realized this early in the design process and therefore apply rule-mining at the file-level.</li>
</ol>
</blockquote>
<h4 id="不可预测、不可适配、不可分析超大型代码"><a href="#不可预测、不可适配、不可分析超大型代码" class="headerlink" title="不可预测、不可适配、不可分析超大型代码"></a>不可预测、不可适配、不可分析超大型代码</h4><ol>
<li>相关性以多种不可预测的方式发生。<br>因此，Rex 的算法不应该依赖于任何硬编码的领域知识，也不应该依赖于任何手动配置或调整。</li>
<li>配置管理实践因服务和项目而异。每项服务都有不同的配置管理和维护策略，因此机器学习模型必须是特定于服务或项目的，不能从一个到另一个外推。更具有挑战性的是，即使是单个服务或项目也会随着时间的推移显着改变特征。因此，Rex 的模型必须定期重新训练，以便其建议准确无误。</li>
<li>在对大型代码和配置文件应用关联规则挖掘时必须小心。服务依赖于大量的代码和配置。在单个代码和配置结构级别应用输入大小呈指数增长的规则挖掘根本不可行。我们在设计过程的早期就意识到了这一点，因此在文件级别应用规则挖掘。</li>
</ol>
<h3 id="本文结构"><a href="#本文结构" class="headerlink" title="本文结构"></a>本文结构</h3><blockquote>
<p>Rex is deployed on 360 Microsoft repositories which hold code and configuration for services such as Exchange Online, OneDrive, Azure, Dynamics CRM and Skype. We are currently scaling out Rex at a fast pace, on-boarding almost one repository per day. Till date, Rex has suggested 4926 changes to engineers that, if not made, may have adversely affected our services in many ways.<br>In this paper, we make the following contributions:<br>• We demonstrate different types of correlations that exist<br>across code and configuration of large services.<br>• We describe a novel two-step algorithm to perform correlated change analysis involving file-level association rule mining followed by differential syntactic analysis of the changes made to the files.<br>• We have implemented and deployed Rex and provide an<br>evaluation based on our deployments.<br>• We have performed an extensive user study to understand<br>how useful Rex is in practice.<br>Section 2 describes different types of correlations Rex has<br>found across many services. Section 3 provides an overview<br>of Rex’s approach, limitations, and challenges. Section 4 explains the algorithms Rex uses to suggest changes. Section 5<br>and Section 6 provide specifics on its implementation and<br>deployment. Finally, Sections 7 and 8 describe a thorough<br>evaluation and user study respectively.</p>
</blockquote>
<p>Rex 部署在 360 Microsoft 存储库中，这些存储库包含 Exchange Online、OneDrive、Azure、Dynamics CRM 和 Skype 等服务的代码和配置。我们目前正在快速扩展 Rex，每天加入几乎一个存储库。迄今为止，Rex 已向工程师提出了 4926 项更改建议，如果不这样做，可能会在许多方面对我们的服务产生不利影响。<br>在本文中，我们做出以下贡献：<br>• 我们展示了存在的不同类型的相关性<br>跨大型服务的代码和配置。<br>• 我们描述了一种新的两步算法来执行相关变化分析，涉及文件级关联规则挖掘，然后对文件所做的变化进行差异句法分析。<br>• 我们已经实施并部署了 Rex 并提供了一个<br>基于我们的部署进行评估。<br>• 我们进行了广泛的用户研究以了解<br>Rex 在实践中有多有用。<br>第 2 节描述了 Rex 具有的不同类型的相关性<br>在许多服务中找到。第 3 节概述<br>Rex 的方法、局限性和挑战。第 4 节解释了 Rex 用来建议更改的算法。第 5 节<br>第 6 节提供了有关其实施和<br>部署。最后，第 7 节和第 8 节详细描述了<br>分别是评价和用户研究。</p>
<h1 id="2-相关变化的原因"><a href="#2-相关变化的原因" class="headerlink" title="2.相关变化的原因"></a>2.相关变化的原因</h1><blockquote>
<p>2 Reasons for Correlated Change<br>Correlations occur due to various reasons. In this section, we describe several categories of correlations we found through our deployments. Table 1 shows a sample of correlated changes that engineers missed making and<br>Rex flagged at commit-time. We note that though these examples are specific to our deployments, the problem of correlated configuration is generic and extends to other organizations as well [14,22,27].<br>We now describe these categories of correlations with the help of the examples in Table 1.</p>
</blockquote>
<p>2 相关变化的原因<br>由于各种原因会出现相关性。在本节中，我们描述了通过部署发现的几类相关性。表 1 显示了工程师遗漏的相关变更示例，以及<br>Rex 在提交时被标记。我们注意到，尽管这些示例特定于我们的部署，但相关配置的问题是通用的，并且也扩展到其他组织 [14,22,27]。<br>我们现在借助表 1 中的示例来描述这些类别的相关性。</p>
<h3 id="2-1-飞行-选择性的对用户发布新功能来测试软件"><a href="#2-1-飞行-选择性的对用户发布新功能来测试软件" class="headerlink" title="2.1 飞行(选择性的对用户发布新功能来测试软件)"></a>2.1 飞行(选择性的对用户发布新功能来测试软件)</h3><blockquote>
<p>2.1 Flighting<br>When an engineer adds a new feature, they use canary-testing<br>or “flighting” to deploy it in stages. They first deploy it to a small subset of machines to ensure that the feature works as planned and does not cause disruptions. Once they ensure this, they deploy the feature more widely. Hence, when the engineer adds code to implement a new feature, they also need to add configuration to files that define the set of machines that will test this feature. Services implement flighting in many different ways. Example 3 shows an instance where the engineer who develops the new feature decides which set of machines to run the feature on. Example 7, for a different<br>service, shows an instance of a change where the engineer who develops the new feature does not directly turn on the feature: they provide a “code switch” which other engineers can use to turn on flighting. These two examples again illustrate why Rex needs to learn such varied change-rules from data and why rule-based engines would not work across services.</p>
</blockquote>
<p>当工程师添加新功能时，他们使用金丝雀测试或“飞行”以分阶段部署。他们首先将其<strong>部署到一小部分机器</strong>上，以确保该功能按计划运行并且不会造成中断。一旦他们确保这一点，他们就会更广泛地部署该功能。因此，当工程师添加代码以实现新功能时，他们还需要<strong>将配置添加到定义将测试此功能的机器集的文件中</strong>。服务以许多不同的方式实现飞行。示例 3 显示了一个实例，其中开发新功能的工程师决定在哪一组机器上运行该功能。例 7，对于不同的服务，显示了一个变化的实例，其中开发新功能的工程师没有直接打开该功能：他们提供了一个“代码开关”，其他工程师可以使用它来打开飞行。这两个例子再次说明了为什么 Rex 需要从数据中学习如此多样的变化规则，以及为什么基于规则的引擎不能跨服务工作。</p>
<h4 id="功能集文件更新设置文件以运行新特性"><a href="#功能集文件更新设置文件以运行新特性" class="headerlink" title="功能集文件更新设置文件以运行新特性"></a>功能集文件更新设置文件以运行新特性</h4><blockquote>
<p>3功能集定义(INI)</p>
<p>飞行定义(INI)</p>
<p>工程师为一项服务添加了一个新功能。她在部署中通过更新设置文件启用了该特性。此外，她还必须指定如何“运行”更改，即在新特性上运行的机器子集。文件2包含了每个特性的飞行配置。</p>
<p>该特性在工程师更改File 2之前不会部署。</p>
</blockquote>
<h4 id="网页设计代码开关"><a href="#网页设计代码开关" class="headerlink" title="网页设计代码开关"></a>网页设计代码开关</h4><blockquote>
<p>一个工程师在文件1中做了一个网页设计上的改变，想要在一小部分机器上运行它。文件2包含了“代码开关”的定义，工程师可以使用它来开启新的设计变更。</p>
<p>如果没有合适的代码开关，工程师就无法启动设计更改，因此，这将导致不必要的新外观部署延迟</p>
</blockquote>
<blockquote>
<p> <img src="/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027135244559.png" alt="image-20211027135244559"> </p>
<p><img src="/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027134915786.png" alt="image-20211027134915786"> </p>
<p><img src="/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027135035036.png" alt="image-20211027135035036"> </p>
</blockquote>
<h3 id="2-2-在不同的框架下复制导致只修改了部分"><a href="#2-2-在不同的框架下复制导致只修改了部分" class="headerlink" title="2.2 在不同的框架下复制导致只修改了部分"></a>2.2 在不同的框架下复制导致只修改了部分</h3><blockquote>
<p>2.2 Replicating Code and Configuration<br>While clearly not recommended, we find that engineers sometimes replicate files and file contents across different logical boundaries of the service. They do this since, without replication, there will be a larger number of dependencies across files and components. This in turn will lead to less modular code-bases which may take longer to test, debug, and deploy.<br>Example 2 shows an instance where a configuration file is replicated across different alerting frameworks. An engineer changed one, without knowing that a replica existed within the other alerting framework. Rex flagged this file and the engineer immediately changed the other file as well.</p>
</blockquote>
<p>2.2 复制代码和配置<br>虽然显然不推荐，但我们发现工程师有时会跨服务的不同逻辑边界复制文件和文件内容。他们这样做是因为如果没有复制，文件和组件之间将会有大量的依赖关系。这反过来会导致模块化代码库更少，这可能需要更长的时间来测试、调试和部署。<br>示例 2 显示了跨不同警报框架复制配置文件的实例。一名工程师在不知道另一个警报框架中存在副本的情况下更改了一个。 Rex 标记了这个文件，工程师也立即更改了另一个文件。</p>
<h4 id="不同框架下修改组件"><a href="#不同框架下修改组件" class="headerlink" title="不同框架下修改组件"></a>不同框架下修改组件</h4><blockquote>
<p>组件定义(c#)</p>
<p>组件定义(c#)</p>
<p>一个工程师修改了文件1中一组组件定义中的一个参数。警报框架使用文件1来确定探测哪些组件并发出警报。文件2非常类似于文件1，它由不同的警报框架出于同样的原因使用。因此，工程师也必须对文件2进行相同的更改。</p>
<p>第二个警报框架将出现故障，导致错误地抑制警报。</p>
</blockquote>
<h3 id="2-3-复杂配置导致有关联部分忘记修改"><a href="#2-3-复杂配置导致有关联部分忘记修改" class="headerlink" title="2.3 复杂配置导致有关联部分忘记修改"></a>2.3 复杂配置导致有关联部分忘记修改</h3><blockquote>
<p>2.3 Complex Configuration<br>Configuring services is a complex task and, as a result, several correlations show up between configuration files. Example 4 shows an instance where an engineer renamed a microservice, but forgot to change the name of the service in the file that contained its firewall rules. This could have caused a security issue. Example 8 shows another instance where hardware configuration files are correlated, and missing this change could have caused a service disruption.</p>
</blockquote>
<p>2.3 复杂配置<br>配置服务是一项复杂的任务，因此，配置文件之间会出现多种相关性。示例 4 显示了一个实例，其中工程师重命名了微服务，但忘记更改包含其防火墙规则的文件中的服务名称。这可能会导致安全问题。示例 8 显示了另一个硬件配置文件相关的实例，如果缺少此更改可能会导致服务中断。</p>
<h4 id="防火墙配置规则改变"><a href="#防火墙配置规则改变" class="headerlink" title="防火墙配置规则改变"></a>防火墙配置规则改变</h4><blockquote>
<p>4Microservice Registry (XML)</p>
<p>防火墙规则定义(XML)</p>
<p>工程师在microservice注册表中更改了一个微服务的名称。文件2保存了从一组微服务到应用于它们的防火墙规则的映射，因此工程师也需要在文件2中更改微服务的名称。</p>
<p>所要求的防火墙规则将不适用于重命名的微服务，从而造成安全威胁。</p>
</blockquote>
<h4 id="数据中心配置文件被函数调用时出错"><a href="#数据中心配置文件被函数调用时出错" class="headerlink" title="数据中心配置文件被函数调用时出错"></a>数据中心配置文件被函数调用时出错</h4><blockquote>
<p>8Config文件 维护数据中心机器的SKU信息(XML)</p>
<p>维护数据中心机架定义(XML)</p>
<p>当数据中心引入一组新的机器时，操作人员更新文件1。如果部署了新机器，还需要更新文件2，该文件指定每个机架中有哪些机器。其他几个函数使用这些配置文件。</p>
<p>数据中心配置错误，可能导致业务无法正常运行，业务中断。</p>
</blockquote>
<h3 id="2-4-增加代码需要增加测试文件"><a href="#2-4-增加代码需要增加测试文件" class="headerlink" title="2.4 增加代码需要增加测试文件"></a>2.4 增加代码需要增加测试文件</h3><blockquote>
<p>2.4 Testing<br>Example1shows that, when an engineer adds a new feature<br>to code, they should consider adding a new test for that feature<br>in a separate file that contains only tests. While this is fairly<br>common across multiple code-bases and services, each code-<br>base has its own organization structure for separating test code<br>from the main production code. Rex automatically detects<br>such structures withoutany manual input.</p>
</blockquote>
<p>2.4测试example1表明，当工程师向代码中添加一个新特性时，他们应该考虑在一个单独的只包含测试的文件中为该特性添加一个新测试。虽然这在多个代码库和服务中是相当常见的，但每个代码库都有自己的组织结构，用于将测试代码与主生产代码分离。Rex无需任何人工输入就能自动检测这些结构。</p>
<h4 id="添加测试文件避免错误"><a href="#添加测试文件避免错误" class="headerlink" title="添加测试文件避免错误"></a>添加测试文件避免错误</h4><blockquote>
<p>1源代码(JS)</p>
<p>测试文件(JS)</p>
<p>一个工程师在源代码中添加了新的功能，需要添加一个单元测试来测试这个功能到另一个文件。</p>
<p>如果没有测试，文件1中的错误可能不会被注意到。</p>
</blockquote>
<h3 id="2-5-脚本之间的依赖关系"><a href="#2-5-脚本之间的依赖关系" class="headerlink" title="2.5 脚本之间的依赖关系"></a>2.5 脚本之间的依赖关系</h3><blockquote>
<p>2.5 Scripting Often, administrators use scripts to test and deploy services. These scripts can have complex inter-dependencies which, unlike compiled code, can go unchecked at commit-time. For instance, in Example6, an engineer changed function definition in one script and hence they had to change the way the function was called in another script. Rex caught this issue, while existing IDEs and compilers could not.</p>
</blockquote>
<p>2.5脚本化通常情况下，管理员会使用脚本来测试和部署服务。这些脚本可能具有复杂的相互依赖关系，与已编译代码不同，这些关系可以在提交时进行检查。例如，在Example6中，工程师更改了一个脚本中的函数定义，因此他们必须更改另一个脚本中调用该函数的方式。Rex发现了这个问题，而现有的ide和编译器却不能。</p>
<h4 id="改了脚本导致出错"><a href="#改了脚本导致出错" class="headerlink" title="改了脚本导致出错"></a>改了脚本导致出错</h4><blockquote>
<p>Shell脚本(PS1)</p>
<p>文件1定义了一个函数，文件2调用它。工程师更改了文件1中的函数名和参数，所以他们必须更改文件2调用函数的方式。如果这段代码是编译的而不是解释的，编译器就会捕获错误。</p>
<p>脚本决定了服务是如何部署的，因此这个错误会导致部署失败。</p>
</blockquote>
<h3 id="2-6-记录漏洞的文件因为代码的增加而混杂了"><a href="#2-6-记录漏洞的文件因为代码的增加而混杂了" class="headerlink" title="2.6 记录漏洞的文件因为代码的增加而混杂了"></a>2.6 记录漏洞的文件因为代码的增加而混杂了</h3><blockquote>
<p>2.6 Miscellaneous Apart from the categories we have mentioned so far, Rex also flags somewhat rare cases of correlation which can have high impact. In Example5, File 2 maintains a list of line-numbers of vulnerable code across different files in the code-base. The idea is to maintain a record of all vulnerabilities that have already been found and vetted by engineers. Thus, when an engineer addsnlines of code to File 1, they also changed the line number of the vulnerable code in File 1. Hence they need to increment the line number in File 2 by n. While such categories of correlations are rare, we notice multiple such rare cases. This further confirms the value of using a learning-based approach. Note that, for simplicity, the table shows examples that involved only two files. In reality, change-rules can contain more than two files.Moreover, the correlations for similar tasks are very different for different services. Example3and Example7in Section2.1talks about two different ways of flighting a feature. Even within a service, the correlations are dynamic and keep changing with time.We believe no existing syntactic or semantic analysis techniquesor heuristic based modelcould have effectively and efficiently captured such diverse and complex correlations.</p>
</blockquote>
<p>除了我们到目前为止提到的类别外，Rex还指出了一些可能产生高影响的罕见相关性案例。在Example5中，File 2在代码库的不同文件中维护一个易受攻击代码的行号列表。这样做的目的是保存工程师已经发现并审查过的所有漏洞的记录。因此，当工程师向文件1添加代码行时，他们也改变了文件1中脆弱代码的行号。因此，他们需要在文件2 by n中增加行号。虽然这种类型的相关性很少见，但我们注意到很多这样的罕见案例。这进一步证实了使用基于学习的方法的价值。请注意，为了简单起见，该表显示了只涉及两个文件的示例。实际上，更改规则可以包含两个以上的文件。此外，类似任务的相关性在不同的服务中也有很大的不同。在第2.1节中，example3和example7讨论了两种不同的处理特性的方法。即使在服务中，相关性也是动态的，并随时间不断变化。我们认为，没有现有的语法或语义分析技术或启发式的模型能够有效和有效地捕获如此多样化和复杂的相关性。</p>
<h1 id="3-Rex要解决的问题、方法、困难"><a href="#3-Rex要解决的问题、方法、困难" class="headerlink" title="3.Rex要解决的问题、方法、困难"></a>3.Rex要解决的问题、方法、困难</h1><blockquote>
<p>3 Problem Overview In this section, we define the problem that Rex solves, the approach to it, and describe some limitations of the approach. Finally, we lay out the challenges we faced as we designed and deployed Rex.</p>
</blockquote>
<p>在本节中，我们将定义Rex要解决的问题，以及解决问题的方法，并描述该方法的一些局限性。最后，我们介绍了在设计和部署Rex时所面临的挑战。</p>
<h2 id="3-1方法-发现关联-细化类型"><a href="#3-1方法-发现关联-细化类型" class="headerlink" title="3.1方法-发现关联,细化类型"></a>3.1方法-发现关联,细化类型</h2><p>3.1方法Rex对提交月份日志应用关联规则挖掘，发现相关的变更。关联规则挖掘基本上是一种指数算法。寻找单个配置参数和代码结构(如变量和函数)之间的相关性将是非常昂贵的，因为这种结构的数量非常多[28,33,35]。因此，为了更好地扩展，我们决定在文件级别挖掘更改规则。虽然该方法是粗粒度的，并不能完美地捕捉相关性，但它使解决方案可以大规模部署。Rex通过两个步骤学习更改规则:更改规则发现和更改规则细化。在发现步骤中，它使用关联规则挖掘来查找“频繁”一起更改的文件集。一组参数确定Rex学习变更规则时需要更改文件的频率。章节4.2提供了关于该算法的更多细节，章节4.5展示了我们如何通过改变服务的特征来调整其参数以保持有效性。在发现变更规则之后，Rex运行第二步，即变更规则细化。其思想是使每个变更规则(在文件级别上是粗粒度的)更加精确。Rex分析变更规则的每个文件中的变更，以确定哪些类型的变更是相关的。第4.3节进一步描述了这个过程。最后，Rex根据学习到的规则向工程师提出建议。</p>
<h2 id="3-2设计目标-通用-有效-不打扰"><a href="#3-2设计目标-通用-有效-不打扰" class="headerlink" title="3.2设计目标-通用,有效,不打扰"></a>3.2设计目标-通用,有效,不打扰</h2><p>Rex的设计是由两个因素驱动的。首先，它需要是通用的:它的技术需要跨文件类型、服务类型和编程语言很好地工作。其次，它需要是有效的:它应该发现现有工具无法捕捉到的微妙的错误配置和bug。为了实现这些目标，我们的解决方案具有以下特点:没有手动输入:Rex的主要目标是帮助工程师尽早发现错误配置和bug，同时尽量减少对他们已经很忙的日程的干扰。因此，我们设计它与现有的系统和日志一起工作，不需要任何额外的日志记录或来自工程师的输入。我们相信这是Rex在我们的组织中通过多种服务被广泛采用的主要原因之一。相关性，而不是因果关系:Rex标记相关性，但不检测因果关系，因为任何日志都可能无法捕获一组特定的相关更改的原因。例如，考虑表1中的example2:更改一个组件定义文件不会导致另一个组件定义文件的更改。一个工程师将警报基础架构扩展到更多的组件，这导致需要更改这两个文件。</p>
<h2 id="3-3范围-冗余提醒"><a href="#3-3范围-冗余提醒" class="headerlink" title="3.3范围-冗余提醒"></a>3.3范围-冗余提醒</h2><p>与任何基于机器学习的方法一样，Rex是一种最努力的服务。有时它可能会错过建议所需要的更改(假阴性)，相反，它也会在不需要更改时建议更改(假阳性)。正如我们在第4节中所描述的，我们对Rex进行了优化，以便它能够捕获尽可能多的错误配置，即使这可能会以大量的假阳性为代价。例如:只有当文件1中一个易受攻击的代码片段的行号发生变化时，我们才需要更改文件2。对于通用技术来说，学习这个特定关联的特定语义是非常困难的。相反，Rex建议工程师在更改文件1时更改文件2，即使文件1中的行号没有更改。这样的建议将是假阳性</p>
<h2 id="3-4-挑战-发生错误不一定会报错-价格不能贵"><a href="#3-4-挑战-发生错误不一定会报错-价格不能贵" class="headerlink" title="3.4 挑战-发生错误不一定会报错,价格不能贵"></a>3.4 挑战-发生错误不一定会报错,价格不能贵</h2><p>确定正确的相关性集有几个与之相关的挑战。不完美的地面真相:我们在设计Rex时面临的最大挑战是不完美的地面真相。原因有很多。首先，相关性通常很微妙，并不一定会导致编译错误、部署失败或立即服务停机。考虑表1 (Example1)中的问题，工程师需要为新添加的特性添加一个测试。这并不是必须的，但绝对是推荐的。然而，工程师通常很难快速提交和部署，因此可能不会添加测试。因此，Rex使用的提交日志可能并不总是看到添加了特性的两个文件和测试一起更改。因此，Rex可能不会学习包含这两个文件的更改规则。性能:Rex目前运行在360存储库上，它的采用正在迅速增加。因此，我们需要确保不涉及手动步骤。此外，我们需要确保规则挖掘算法不会变得过于昂贵。</p>
<p><img src="/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027142725042.png" alt="image-20211027142725042"> </p>
<h1 id="4系统设计-组件介绍"><a href="#4系统设计-组件介绍" class="headerlink" title="4系统设计-组件介绍"></a>4系统设计-组件介绍</h1><p>在本节中，我们将概述Rex的不同组件。然后我们详细描述每个组件。</p>
<h3 id="4-1总体设计"><a href="#4-1总体设计" class="headerlink" title="4.1总体设计"></a>4.1总体设计</h3><p>图1展示了Rex的总体设计。Rex规则学习引擎定期学习更改规则，这些更改规则捕获哪些文件一起更改以及如何更改。它使用几个月的提交日志来完成这一操作。对于每次提交，提交日志都包含关于哪些文件更改了，以及它们如何更改的信息。Rex的规则学习引擎运行两个流程来学习规则:变更规则发现(章节4.2)和变更规则细化(章节4.3)。Rex建议引擎在使用Rex的客户端和规则学习引擎之间提供接口。当工程师更改文件时，Rex客户端将更改通知建议引擎。建议引擎查找适用的更改规则，以确定工程师是否可能错过了对相关文件的更改。如果是，建议引擎将额外的文件更改建议回给客户端。我们目前对Rex客户端的实现是针对各种版本控制系统构建的，比如Git[29]。每当需要时，在每次提交pull-request之后，它都会添加建议作为pullrequest注释。更多细节见第5节。当Rex客户端将建议反馈给工程师时，他们要么通过编辑建议文件来接受建议，要么不接受建议。Rex将这种行为作为对规则学习引擎的反馈。利用这种隐式反馈，Rex自动调整用于学习变化规则的参数。第4.5节提供了关于调优模块的更多细节，以及为什么这对跨数百个存储库扩展Rex至关重要。很少有工程师通过回复或解决评论来提供明确的反馈，我们不使用这种方式，因为这种反馈非常有限，而且本质上倾向于负面的例子。图2:变更规则发现步骤中的一些示例规则。注意，规则不仅限于文件对。示例c)显示了在LHS上学习两个文件的示例。</p>
<h3 id="4-2-变化规则发现"><a href="#4-2-变化规则发现" class="headerlink" title="4.2 变化规则发现"></a>4.2 变化规则发现</h3><p>在本节中，我们将描述学习规则的第一步，即发现变化规则。我们使用6个月的提交数据进行规则挖掘。首先，Rex删除提交日志，以排除由合并分支(压缩更改)或跨分支移植一组提交引起的较小提交的聚合。由于这些提交将一组较小的提交放在一起，这些提交彼此之间可能没有任何关系，所以它们不能捕获文件之间的真正相关性。此外，如此大的委托使得采矿规则的成本高得令人望而却步。图2显示了Rex学到的一些规则示例。Rex运行规则挖掘算法，将每次提交视为一个事务。首先，它使用FP-Growth算法[13]发现频繁项集。频繁项集是一组经常一起更改的文件。在数学上，我们定义一个频繁项集asF={f1，…其中filesf1到fnhave至少在最短时间内一起改变。Sminis为模型定义的最小支持。频繁项集sF的支持定义为文件f1throughfnchange的次数。因此,科幻小说≥股市。接下来，算法从频繁项集生成变更规则。由频繁项- setf可知，X = Ysuch thatX⊂F,Y⊂F,X∩Y=φ，X∪Y=F。规则的置信度是所有文件一起inFchange的次数(支持file-setF)除以所有文件一起inXchange的次数(支持file-setX)。因此，该规则的置信度为x∪Y/sX。因此，setsXandYchange中的文件越多，规则的置信度就越高。只有当它的置信度高于最小的confidence ecmin时，Rex才会学习规则。</p>
<h3 id="4-3-变化规则细化"><a href="#4-3-变化规则细化" class="headerlink" title="4.3 变化规则细化"></a>4.3 变化规则细化</h3><p>在本节中，我们将描述更改规则的细化过程。目前，我们的实现支持配置文件，但它也可以扩展以支持代码文件。在我们的描述中，我们专注于xml文件，但同样的技术也适用于其他文件类型，如json。考虑以下部署中出现的例子:</p>
<p><img src="/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.26-Rex%E8%AE%BA%E6%96%87/image-20211027145628319.png" alt="image-20211027145628319"> </p>
<blockquote>
<p>图3:rulenetwork_dc1.xml=俺们network_dc2.xml的更改规则细化步骤。对一个配置文件进行三次独立的提交。每个属性都添加了一个XML属性tenetwork，但是值不同。从这三者中，雷克斯学会了不同的树来编码添加的东西。所有这些差异树都被输入到反统一算法中，反统一算法输出这种类型加法的泛化结果。</p>
</blockquote>
<h4 id="命令对数据中心1和2都起作用的话就要建议-只对1起作用就不建议"><a href="#命令对数据中心1和2都起作用的话就要建议-只对1起作用就不建议" class="headerlink" title="命令对数据中心1和2都起作用的话就要建议,只对1起作用就不建议"></a>命令对数据中心1和2都起作用的话就要建议,只对1起作用就不建议</h4><blockquote>
<p>例1。网络配置:工程师向fileNetConfig_dc1添加新命令。配置数据中心1中的机架的xml。这些更改需要应用到所有数据中心，因此，工程师也必须为其他数据中心更改类似的配置文件sayNetConfig_dc2.xml。因此，如果工程师不做这些更改，Rex应该建议。然而，在许多情况下，工程师会对NetConfig_dc1进行更改。仅应用于数据中心1而不应用于数据中心2的xml。例如，他们可能只向数据中心1添加一个新的子网。在这种情况下，Rex不应该建议changingNetConfig_dc2.xml。仅更改规则发现并不能区分这两种情况。</p>
</blockquote>
<h4 id="定义新角色还是修改旧角色"><a href="#定义新角色还是修改旧角色" class="headerlink" title="定义新角色还是修改旧角色"></a>定义新角色还是修改旧角色</h4><blockquote>
<p>例2。基于角色的访问控制:我们的几个服务实现了基于角色的访问控制。工程师通常在fileroledef .xml中定义一个新角色。当它们这样做时，还应该使用changerolemmembership .xml，它指定与新角色相关联的用户或组。但是，如果工程师只是修改roledefn .xml中已经存在的角色定义，那么他们不需要修改RoleMembership.xml。</p>
</blockquote>
<h4 id="给一个配置文件xc-学习文件操作-用xc中属于x的规则来完善在变化规则发现中的规则x-gt-y上"><a href="#给一个配置文件xc-学习文件操作-用xc中属于x的规则来完善在变化规则发现中的规则x-gt-y上" class="headerlink" title="给一个配置文件xc,学习文件操作,用xc中属于x的规则来完善在变化规则发现中的规则x-&gt;y上"></a>给一个配置文件xc,学习文件操作,用xc中属于x的规则来完善在变化规则发现中的规则x-&gt;y上</h4><blockquote>
<p>这些示例表明，在某些情况下，对于ruleX= Y,Ychanges仅以特定的方式更改ifXchanges。虽然对于代码，编译器通常会捕捉到这样的相关性和依赖关系，但配置文件却缺乏一个等效的安全网。更改规则细化由两部分组成。首先，给定一个配置filexC，它学习所有在toxC中添加、删除和修改的泛化，其中泛化是以正则表达式的形式出现的。接下来，对于xC∈X的变化规则发现所学习到的任何变化规则X=根y，它将进一步细化该规则。现在我们详细描述这两个步骤。</p>
</blockquote>
<h3 id="4-3-1"><a href="#4-3-1" class="headerlink" title="4.3.1"></a>4.3.1</h3><p>创建一个修改xc的提交集合C,对于每个请求,构建一个差分树来计算差异</p>
<blockquote>
<p>图3显示了一个示例。Rex创建了一组所有的commitsCthat modifyxC。对于每个提交inC, Rex计算xc新旧版本之间的语法差异。为了做到这一点，Rex为两个版本都构建了稀疏树，然后使用一种新的差分算法来计算两棵解析树之间的差异，我们称之为差分树。例如，在图3中，在三个不同的提交中添加了三个更改。每次更改都添加了一个名为network的XML节点，但是属性值不同。在每种情况下，Rex的差分算法都会输出一个差分树来捕获差分。带阴影的顶点是XML节点，而未带阴影的顶点是XML属性。</p>
</blockquote>
<p>从差分树将更改一般化</p>
<blockquote>
<p>接下来，从差异树中，Rex学习对配置文件所做的更改的一般化。为了提取这些概括，Rex使用了反统一过程[15,23]。反统一算法学习的正则表达式是差异树的最具体的一般化。在图3中所示的三个更改中，xmlattributeracktypes都有不同的值。xmlattributeCommandConfigtoo具有不同的文本值。反统一算法以这三棵差分树为输入，输出广义差分树，从而得到这三种变化最具体的泛化。虽然图3描述了一个一般化示例，但filexce可能有更多这样的一般化示例。Rex学习所有这些对配置文件filexC的添加、删除和修改的一般化。设这个集合是G(xC) ={g1,g2，…, gn}。</p>
</blockquote>
<h3 id="4-3-2"><a href="#4-3-2" class="headerlink" title="4.3.2"></a>4.3.2</h3><p>符合一般化才改变y</p>
<blockquote>
<p>接下来，给定在变化规则发现过程中学习到的规则X=拍卖会Y, wherexC∈X, Rex学习到更细粒度的规则，形式为{X，(xC,gi)}=拍卖会Y,gi∈G(xC)。该规则表示，当所有文件都在xchange时，只有当对filexCmatches generalizationi的更改时，Rex才会建议更改y。</p>
</blockquote>
<p>xc一般化,y变了是n    ,x一般化 y不变是n~ .n占的比例大于一个阈值(0.75)则将xc和g 添加到规则  ,xc和g匹配时才建议,此举减少了假阳性(不需要修改时不建议修改了)</p>
<blockquote>
<p>接下来，给定在变化规则发现过程中学习到的规则X=宗Y, wherexC∈X, Rex学习到更细粒度的规则，形式为{X，(xC,gi)}=宗Y,gi∈G(xC)。该规则表示，当所有文件都在xchange时，只有当对filexCmatches generalizationi的更改时，Rex才会建议更改y。这是通过以下方法完成的。例如filexmatchesgian和所有文件在ychange中的变化次数为n。相反地，例如filexCmatchesgian和文件在ydo notchange中的变化次数为。Ifn/(n+ ~ n)&gt;t，其中有一个阈值，我们称之为细化阈值，Rex通过将元组(xC,gi)添加到规则的左侧来细化规则。这意味着Rex现在只在更改toxc与正则表达式gi匹配时才提出建议。因此，修改规则的细化减少了假阳性建议。在我们所有的部署中，我们设置为0.75。</p>
</blockquote>
<p>不仅配置文件,代码文件也行</p>
<p>尽管差分算法的实现是特定于配置文件的，但我们也可以将其扩展到代码文件。代码差分算法可以学习“添加函数”、“改变条件”等语法特征。我们可以使用这些特性来完善代码规则。基于我们在检查变更规则发现生成的真阳性和假阳性时进行的仔细的实证研究，我们观察到代码文件的许多问题已经由编译器解决了。因此，当工程师提交更改时，我们不会看到很多代码文件的假阳性，因为在大多数情况下，工程师在编译代码后提交更改。在下一节4.4中，我们将详细说明如何使用这些规则。在工程师提交更改后，Rex使用这些规则对丢失的文件提出建议。如果建议是在IDE(集成开发环境)级别提出的，那么这样的代码文件工具将对开发人员很有帮助。我们把这个留到以后再谈。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E8%AE%BA%E6%96%87/" rel="tag"># 论文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/26/C++/" rel="next" title="C++笔记">
                <i class="fa fa-chevron-left"></i> C++笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/27/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/10.27-%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="prev" title="10.27-栈溢出">
                10.27-栈溢出 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">1.介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6%E5%92%8C%E6%BA%90%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">2.0.1.</span> <span class="nav-text">大规模服务组件和源之间有依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%B2%A1%E6%9C%89%E8%A7%84%E5%AE%9A%E6%9D%A5%E6%8C%87%E5%AF%BC-%E6%9C%AA%E8%BF%9B%E8%A1%8C%E5%85%A8%E9%9D%A2%E7%9A%84%E4%BF%AE%E6%94%B9%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E4%B8%A5%E9%87%8D%E5%90%8E%E6%9E%9C-Rex%E9%80%9A%E8%BF%87%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9D%A5%E6%8F%90%E5%87%BA%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.0.2.</span> <span class="nav-text">依赖关系没有规定来指导,未进行全面的修改可能造成严重后果,Rex通过机器学习来提出建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rex%E5%B0%86%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E5%92%8C%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90%E7%BB%93%E5%90%88-%E5%9C%A8%E5%A4%A7%E9%87%8F%E9%83%A8%E7%BD%B2%E5%B9%B6%E8%A7%82%E5%AF%9F%E5%90%8E%E6%8F%90%E5%87%BA%E4%B8%89%E4%B8%AA%E7%BB%93%E6%9E%9C"><span class="nav-number">2.0.3.</span> <span class="nav-text">Rex将规则挖掘和句法分析结合,在大量部署并观察后提出三个结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%B5%8B%E3%80%81%E4%B8%8D%E5%8F%AF%E9%80%82%E9%85%8D%E3%80%81%E4%B8%8D%E5%8F%AF%E5%88%86%E6%9E%90%E8%B6%85%E5%A4%A7%E5%9E%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">不可预测、不可适配、不可分析超大型代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">2.0.4.</span> <span class="nav-text">本文结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E5%8F%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.</span> <span class="nav-text">2.相关变化的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%A3%9E%E8%A1%8C-%E9%80%89%E6%8B%A9%E6%80%A7%E7%9A%84%E5%AF%B9%E7%94%A8%E6%88%B7%E5%8F%91%E5%B8%83%E6%96%B0%E5%8A%9F%E8%83%BD%E6%9D%A5%E6%B5%8B%E8%AF%95%E8%BD%AF%E4%BB%B6"><span class="nav-number">3.0.1.</span> <span class="nav-text">2.1 飞行(选择性的对用户发布新功能来测试软件)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E9%9B%86%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%A5%E8%BF%90%E8%A1%8C%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">3.0.1.1.</span> <span class="nav-text">功能集文件更新设置文件以运行新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81%E5%BC%80%E5%85%B3"><span class="nav-number">3.0.1.2.</span> <span class="nav-text">网页设计代码开关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B8%8B%E5%A4%8D%E5%88%B6%E5%AF%BC%E8%87%B4%E5%8F%AA%E4%BF%AE%E6%94%B9%E4%BA%86%E9%83%A8%E5%88%86"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.2 在不同的框架下复制导致只修改了部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6"><span class="nav-number">3.0.2.1.</span> <span class="nav-text">不同框架下修改组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%A4%8D%E6%9D%82%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4%E6%9C%89%E5%85%B3%E8%81%94%E9%83%A8%E5%88%86%E5%BF%98%E8%AE%B0%E4%BF%AE%E6%94%B9"><span class="nav-number">3.0.3.</span> <span class="nav-text">2.3 复杂配置导致有关联部分忘记修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99%E6%94%B9%E5%8F%98"><span class="nav-number">3.0.3.1.</span> <span class="nav-text">防火墙配置规则改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A2%AB%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E5%87%BA%E9%94%99"><span class="nav-number">3.0.3.2.</span> <span class="nav-text">数据中心配置文件被函数调用时出错</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"><span class="nav-number">3.0.4.</span> <span class="nav-text">2.4 增加代码需要增加测试文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E9%81%BF%E5%85%8D%E9%94%99%E8%AF%AF"><span class="nav-number">3.0.4.1.</span> <span class="nav-text">添加测试文件避免错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E8%84%9A%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">3.0.5.</span> <span class="nav-text">2.5 脚本之间的依赖关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E4%BA%86%E8%84%9A%E6%9C%AC%E5%AF%BC%E8%87%B4%E5%87%BA%E9%94%99"><span class="nav-number">3.0.5.1.</span> <span class="nav-text">改了脚本导致出错</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%AE%B0%E5%BD%95%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%96%87%E4%BB%B6%E5%9B%A0%E4%B8%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A2%9E%E5%8A%A0%E8%80%8C%E6%B7%B7%E6%9D%82%E4%BA%86"><span class="nav-number">3.0.6.</span> <span class="nav-text">2.6 记录漏洞的文件因为代码的增加而混杂了</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Rex%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%9B%B0%E9%9A%BE"><span class="nav-number">4.</span> <span class="nav-text">3.Rex要解决的问题、方法、困难</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E6%96%B9%E6%B3%95-%E5%8F%91%E7%8E%B0%E5%85%B3%E8%81%94-%E7%BB%86%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">3.1方法-发现关联,细化类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87-%E9%80%9A%E7%94%A8-%E6%9C%89%E6%95%88-%E4%B8%8D%E6%89%93%E6%89%B0"><span class="nav-number">4.2.</span> <span class="nav-text">3.2设计目标-通用,有效,不打扰</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E8%8C%83%E5%9B%B4-%E5%86%97%E4%BD%99%E6%8F%90%E9%86%92"><span class="nav-number">4.3.</span> <span class="nav-text">3.3范围-冗余提醒</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%8C%91%E6%88%98-%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E4%B8%8D%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%8A%A5%E9%94%99-%E4%BB%B7%E6%A0%BC%E4%B8%8D%E8%83%BD%E8%B4%B5"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 挑战-发生错误不一定会报错,价格不能贵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.</span> <span class="nav-text">4系统设计-组件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.0.1.</span> <span class="nav-text">4.1总体设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%8F%98%E5%8C%96%E8%A7%84%E5%88%99%E5%8F%91%E7%8E%B0"><span class="nav-number">5.0.2.</span> <span class="nav-text">4.2 变化规则发现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%8F%98%E5%8C%96%E8%A7%84%E5%88%99%E7%BB%86%E5%8C%96"><span class="nav-number">5.0.3.</span> <span class="nav-text">4.3 变化规则细化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%831%E5%92%8C2%E9%83%BD%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%AF%9D%E5%B0%B1%E8%A6%81%E5%BB%BA%E8%AE%AE-%E5%8F%AA%E5%AF%B91%E8%B5%B7%E4%BD%9C%E7%94%A8%E5%B0%B1%E4%B8%8D%E5%BB%BA%E8%AE%AE"><span class="nav-number">5.0.3.1.</span> <span class="nav-text">命令对数据中心1和2都起作用的话就要建议,只对1起作用就不建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B0%E8%A7%92%E8%89%B2%E8%BF%98%E6%98%AF%E4%BF%AE%E6%94%B9%E6%97%A7%E8%A7%92%E8%89%B2"><span class="nav-number">5.0.3.2.</span> <span class="nav-text">定义新角色还是修改旧角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6xc-%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E7%94%A8xc%E4%B8%AD%E5%B1%9E%E4%BA%8Ex%E7%9A%84%E8%A7%84%E5%88%99%E6%9D%A5%E5%AE%8C%E5%96%84%E5%9C%A8%E5%8F%98%E5%8C%96%E8%A7%84%E5%88%99%E5%8F%91%E7%8E%B0%E4%B8%AD%E7%9A%84%E8%A7%84%E5%88%99x-gt-y%E4%B8%8A"><span class="nav-number">5.0.3.3.</span> <span class="nav-text">给一个配置文件xc,学习文件操作,用xc中属于x的规则来完善在变化规则发现中的规则x-&gt;y上</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1"><span class="nav-number">5.0.4.</span> <span class="nav-text">4.3.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2"><span class="nav-number">5.0.5.</span> <span class="nav-text">4.3.2</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzlg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
