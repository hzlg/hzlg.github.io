<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="C++笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记">
<meta property="og:url" content="https://hzlg.github.ioz/2021/10/26/C++/index.html">
<meta property="og:site_name" content="hzlg&#39;s blog">
<meta property="og:description" content="C++笔记">
<meta property="og:locale">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123151005885.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123151623873.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211116140932694.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211116141513869.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123101733433.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123102101741.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123102247652.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211116143541758.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211116143704921.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123104024025.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123104702909.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123104727196.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123105116492.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123105208762.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123112822338.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123112803830.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225134503013.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211224235921687.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211224225516341.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211224232513817.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123150514219.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123145040660.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211202205443153.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211202231333236.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211202231350967.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211202231435395.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211202231906885.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211202231910552.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211203083719797.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211203083952722.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211203090148538.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211203100211433.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225135843365.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225140021736.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225001757748.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225192958919.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225211801536.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225150209701.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225150230147.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225150943750.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225195957226.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225194715164.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225194924623.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225195022805.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225195336043.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225211523710.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225210224997.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225205331501.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225211136221.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225211223262.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225210127368.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225205729149.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225212823167.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225214804484.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225214821179.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225214853543.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225214945679.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225215050801.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229170937349.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229183521710.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230130914175.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229172805899.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229173151224.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229174634548.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229182721160.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230133857492.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230133903984.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230133910441.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230132531431.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229183455469.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20220310214949246.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211229182721160.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230133910441.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230140004446.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230143947362.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225225525502.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225225758491.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225232352881.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225232858686.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225233258665.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225233403930.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026140341738.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026140948113.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026141031296.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026141110864.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026141222256.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026141609926.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026141653360.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026141930910.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026142727240.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026143132511.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230163522913.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230163555763.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026143821550.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026143654444.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026144431086.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026144433862.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026144242305.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026144459112.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026144652423.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026144746378.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026145320837.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026145800654.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026151227636.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026151708033.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211026152122833.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230183553360.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230183632098.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230183826501.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230183918139.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230184717939.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230184905842.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230185007695.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230185513079.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230185525098.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230192139151.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230195110647.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230201328284.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230195336447.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230195821764.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211230200612479.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211225201332485.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20220310224439745.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20220310224447170.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20220310224542678.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20220310224612369.png">
<meta property="article:published_time" content="2021-10-26T06:02:30.080Z">
<meta property="article:modified_time" content="2022-03-11T03:26:55.066Z">
<meta property="article:author" content="hzlg">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzlg.github.ioz/2021/10/26/C++/image-20211123151005885.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hzlg.github.ioz/2021/10/26/C++/"/>





  <title>C++笔记 | hzlg's blog</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzlg's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记、日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzlg.github.ioz/2021/10/26/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzlg's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-26T14:02:30+08:00">
                2021-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>C++笔记</p>
<span id="more"></span>

<h2 id="C-初探"><a href="#C-初探" class="headerlink" title="C++初探"></a>C++初探</h2><h3 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="*C++内存管理"></a>*C++内存管理</h3><blockquote>
<p>堆:空间分配</p>
<p>栈:临时变量(函数参数等)</p>
<p>全局:全局变量和静态变量(未初始化的全局变量在bbs段)</p>
<p>常量:字符串常量/const修饰的变量等</p>
<p>代码:函数等</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211123151005885.png" alt="image-20211123151005885">  </p>
<p><img src="/2021/10/26/C++/image-20211123151623873.png" alt="image-20211123151623873">  </p>
<h3 id="简单的程序"><a href="#简单的程序" class="headerlink" title="简单的程序"></a>简单的程序</h3><p><img src="/2021/10/26/C++/image-20211116140932694.png" alt="image-20211116140932694"> </p>
<blockquote>
<p>使用标准命名空间，即导入其中声明的所有命令、函数等 </p>
<p>• C++ 源程序由一个或多个源文件组成； </p>
<p>• 每个源文件可由一个或多个函数组成； </p>
<p>• 一个源程序有且只能有一个 main 函数，即主函数；</p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-data-types.html">数据类型</a></h3><h4 id="基本类型（int-short-long-float…）"><a href="#基本类型（int-short-long-float…）" class="headerlink" title="基本类型（int short long float…）"></a>基本类型（int short long float…）</h4><p><img src="/2021/10/26/C++/image-20211116141513869.png" alt="image-20211116141513869">  </p>
<h4 id="类型限定符（const-volatile-restrict）"><a href="#类型限定符（const-volatile-restrict）" class="headerlink" title="//类型限定符（const volatile restrict）"></a>//类型限定符（const volatile restrict）</h4><p><img src="/2021/10/26/C++/image-20211123101733433.png" alt="image-20211123101733433"> </p>
<h4 id="别名（typedef-int-abcname）"><a href="#别名（typedef-int-abcname）" class="headerlink" title="别名（typedef int abcname）"></a>别名（typedef int abcname）</h4><p><img src="/2021/10/26/C++/image-20211123102101741.png" alt="image-20211123102101741"> </p>
<h4 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="//枚举（enum）"></a>//枚举（enum）</h4><p><img src="/2021/10/26/C++/image-20211123102247652.png" alt="image-20211123102247652">  </p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="1-自动转换-隐式转换：-­"><a href="#1-自动转换-隐式转换：-­" class="headerlink" title="(1) 自动转换/隐式转换： ­"></a>(1) 自动转换/隐式转换： ­</h4><ul>
<li><p>相同类型的数据进行运算时，其结果仍然是同一数据类型，如 <strong>3/2 的结果是 1</strong>；</p>
</li>
<li><p>不同类型的数据进行运算时，需要先转换成同一数据类型，然后再进行相应的运算；</p>
</li>
<li><p>转换按数据长度增加的方向进行，以尽可能地保证精度不会降低； ­ 所有的浮点运算都是以双精度进行的；</p>
</li>
<li><p>char 型数据和 short 型数据进行运算时，需转换成 int 型； ­ </p>
</li>
<li><p>赋值号两边的数据类型不同时，需先将<strong>右边表达式的值转换为左边数据的类型</strong>，然后再 赋值；</p>
</li>
<li><p>字符变量直接参与算术运算时，先转化为相应的 ASCII 码，然后进行运算。 </p>
<p>char ‐‐&gt; short ‐‐&gt; int ‐‐&gt; unsigned ‐‐&gt; long ‐‐&gt; unsigned long ‐‐&gt; double &lt;‐‐ float </p>
</li>
</ul>
<h4 id="2-强制转换-显式转换"><a href="#2-强制转换-显式转换" class="headerlink" title="(2)强制转换/显式转换"></a>(2)强制转换/显式转换</h4><p>类型标识符(表达式) // C++风格，将表达式的值转化为指定的数据类型</p>
<p>(类型标识符)表达式 // C 语言风格，作用同上</p>
<p><img src="/2021/10/26/C++/image-20211116143541758.png" alt="image-20211116143541758">  </p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><blockquote>
<p>赋值号两边的数据类型不同时，需先将<strong>右边表达式的值转换为左边数据的类型</strong>，然后再赋值</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211116143704921.png" alt="image-20211116143704921"> </p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="//逗号运算符"></a>//逗号运算符</h4><p><img src="/2021/10/26/C++/image-20211123104024025.png" alt="image-20211123104024025"> </p>
<blockquote>
<p>a = 15 , b = 25</p>
</blockquote>
<h4 id="求字节数运算符（sizeof）"><a href="#求字节数运算符（sizeof）" class="headerlink" title="求字节数运算符（sizeof）"></a>求字节数运算符（sizeof）</h4><p><img src="/2021/10/26/C++/image-20211123104702909.png" alt="image-20211123104702909"> </p>
<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="//数学函数"></a>//数学函数</h4><p><img src="/2021/10/26/C++/image-20211123104727196.png" alt="image-20211123104727196"> </p>
<h4 id="输入输出（cin-cout）"><a href="#输入输出（cin-cout）" class="headerlink" title="输入输出（cin cout）"></a>输入输出（cin cout）</h4><p><img src="/2021/10/26/C++/image-20211123105116492.png" alt="image-20211123105116492"> </p>
<p>操纵符（格式控制符 如 endl ）</p>
<p><img src="/2021/10/26/C++/image-20211123105208762.png" alt="image-20211123105208762"> </p>
<p><img src="/2021/10/26/C++/image-20211123112822338.png" alt="image-20211123112822338"> </p>
<p><img src="/2021/10/26/C++/image-20211123112803830.png" alt="image-20211123112803830"> </p>
<h4 id="时间函数"><a href="#时间函数" class="headerlink" title="//时间函数"></a>//时间函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long Second, Minute, Hour;</span><br><span class="line"></span><br><span class="line">    Second = time(NULL); //头文件 ctime 中函数 time(0) 或 time(NULL) 返回当前时间与 1970 年 1 月 1 日零时的时间差（格林威治时间，以秒为单位）</span><br><span class="line">    Minute = Second / 60;</span><br><span class="line">    Hour = Minute / 60;</span><br><span class="line">    cout &lt;&lt; &quot;当前北京时间是 &quot;;</span><br><span class="line">    cout &lt;&lt; (Hour + 8) % 24 &lt;&lt; &quot;:&quot; &lt;&lt; Minute % 60 //北京时间：格林威治时间 + 8 小时。</span><br><span class="line">         &lt;&lt; &quot;:&quot; &lt;&lt; Second % 60 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x1 = 1, x2 = 2, x3 = 3;</span><br><span class="line">    bool b1, b2, b3;</span><br><span class="line"></span><br><span class="line">    b1 = (x1 &lt; x2) &amp;&amp; (x2 &lt; x3); // 正确写法</span><br><span class="line">    cout &lt;&lt; &quot;b1=&quot; &lt;&lt; b1 &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    b2 = x1 &lt; x2 &lt; x3; // 有没有问题？</span><br><span class="line">    cout &lt;&lt; &quot;b2=&quot; &lt;&lt; b2 &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    b3 = x3 &gt; x2 &gt; x1; // 有没有问题？</span><br><span class="line">    cout &lt;&lt; &quot;b3=&quot; &lt;&lt; b3 &lt;&lt; &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 1 1 0 应该是先判断前面的,拿判断完的值和后面的判断</span><br></pre></td></tr></table></figure>

<h2 id="函数-引用-内联-命名空间与C不同"><a href="#函数-引用-内联-命名空间与C不同" class="headerlink" title="函数(引用,内联,命名空间与C不同)"></a>函数(引用,内联,命名空间与C不同)</h2><ul>
<li>数据的作用域<ul>
<li>什么是作用域，局部作用域 </li>
<li>*局部变量，全局变量 ­ (extern)</li>
<li>作用域解析运算符 :: ，命名空间 ­ </li>
<li>生存期，静态变量 ­ (static)</li>
<li>形参带缺省值的函数，函数重载</li>
</ul>
</li>
<li>编译预处理与多文件结构 ­ <ul>
<li>头文件 ­ 符号常量 ­ </li>
<li>条件编译 ­ </li>
<li>多文件结构 ­ </li>
<li>外部变量，外部函数</li>
</ul>
</li>
<li>系统函数</li>
</ul>
<h3 id="参数传递-引用传递-C的指针变量-对比"><a href="#参数传递-引用传递-C的指针变量-对比" class="headerlink" title="*参数传递(引用传递/C的指针变量 对比)"></a>*参数传递(引用传递/C的指针变量 对比)</h3><p>传递方式一：值传递 </p>
<p>*传递方式二：引用传递</p>
<p>(1) 引用的声明与使用：&amp; </p>
<p>(2) 引用是一种特殊类型的变量，可看作是变量的<strong>别名</strong>；</p>
<p>(3) 声明一个引用时<strong>必须初始化</strong>，指向一个存在的对象； </p>
<p>(4) 引用一旦初始化就不能改变，即不能再作为其它对象的引用（别名）； </p>
<p>(5) 若引用作为形参，则函数<strong>被调用时才会被初始化</strong>，此时形参是实参的一个别名，对形参的任何操作也会直接作用于实参，也就是说，如果形参的值被改变则实参的值也会被改变。</p>
<p>(6) 引用不是变量,不占空间</p>
<blockquote>
<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。没有没主人的名字，名字必须有主人</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。（名字不可以改，指针可以改）</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。（起名字时就要找好主人）</li>
<li>引用是通过const指针来实现的</li>
</ul>
<img src="/2021/10/26/C++/image-20211225134503013.png" alt="image-20211225134503013" style="zoom:80%;"> 
</blockquote>
<blockquote>
<p>在c++中，*和&amp;在不同的地方有着不同的意义。&amp;是引用,*是解引用,即解释引用,(在指针操作时*是指针的声明,&amp;是取地址)</p>
<p>说的通俗一点就是，<strong>直接去寻找指针所指的地址里面的内容</strong>(c指向a,c存着a的地址,c的解引用*c就是a的地址上存的值)，此内容可以是任何数据类型(?应该只能是指针吧)，当然也可以是指针。</p>
<p>p是指针,   <code>a = 6; p = &amp;a; </code>  p就是地址, *p就是6</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="number">321</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> *c = &amp;a;</span><br><span class="line">    cout &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//123</span></span><br><span class="line"><span class="comment">//321</span></span><br><span class="line"><span class="comment">//0x61fe08</span></span><br><span class="line"><span class="comment">//0x61fe14</span></span><br><span class="line"><span class="comment">//0x61fe14</span></span><br><span class="line"><span class="comment">//321</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="引用做参数"><a href="#引用做参数" class="headerlink" title="引用做参数"></a>引用做参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_old</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 值传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_new</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> <span class="comment">// 引用传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap: x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_old</span>(x, y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap_old: x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_new</span>(x, y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap_new: x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Before swap: x=5, y=8</span></span><br><span class="line"><span class="comment">//After swap_old: x=5, y=8</span></span><br><span class="line"><span class="comment">//After swap_new: x=8, y=5</span></span><br></pre></td></tr></table></figure>

<h4 id="引用做返回值"><a href="#引用做返回值" class="headerlink" title="引用做返回值"></a>引用做返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> vals[] = &#123;<span class="number">10.1</span>, <span class="number">12.6</span>, <span class="number">33.1</span>, <span class="number">24.1</span>, <span class="number">50.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> &amp;<span class="title">setValues</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> &amp;ref = vals[i];</span><br><span class="line">    <span class="keyword">return</span> ref; <span class="comment">// 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要调用上面定义函数的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;改变前的值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vals[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setValues</span>(<span class="number">1</span>) = <span class="number">20.23</span>; <span class="comment">// 改变第 2 个元素，相当于vals[1] = 20.23</span></span><br><span class="line">    <span class="built_in">setValues</span>(<span class="number">3</span>) = <span class="number">70.8</span>;  <span class="comment">// 改变第 4 个元素，相当于vals[3] = 70.8</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;改变后的值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vals[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变前的值</span></span><br><span class="line"><span class="comment">// vals[0] = 10.1</span></span><br><span class="line"><span class="comment">// vals[1] = 12.6</span></span><br><span class="line"><span class="comment">// vals[2] = 33.1</span></span><br><span class="line"><span class="comment">// vals[3] = 24.1</span></span><br><span class="line"><span class="comment">// vals[4] = 50</span></span><br><span class="line"><span class="comment">// 改变后的值</span></span><br><span class="line"><span class="comment">// vals[0] = 10.1</span></span><br><span class="line"><span class="comment">// vals[1] = 20.23</span></span><br><span class="line"><span class="comment">// vals[2] = 33.1</span></span><br><span class="line"><span class="comment">// vals[3] = 70.8</span></span><br><span class="line"><span class="comment">// vals[4] = 50</span></span><br></pre></td></tr></table></figure>

<h3 id="内联函数-C里没有"><a href="#内联函数-C里没有" class="headerlink" title="内联函数(C里没有)"></a>内联函数(C里没有)</h3><p>内联函数 </p>
<p>(1) 关键字：inline </p>
<p>(2) 编译时在调用处用函数体进行替换； </p>
<p>(3) 使用内联函数能节省参数传递、控制转移等开销，提高代码的执行效率； </p>
<p>(4) 内联函数通过应该功能简单、规模小、使用频繁； </p>
<p>(5) 内联函数体内不建议使用循环语句和 switch 语句； </p>
<p>(6) 有些函数无法定义成内联函数，如递归调用函数等。</p>
<blockquote>
<p>C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
<p>在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须<strong>重新编译</strong>。因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
<p>用关键字 inline 放在函数定义(注意是<strong>定义而非声明</strong>)的前面即可将函数指定为内联函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Foo(int x, int y);  </span><br><span class="line">inline void Foo(int x, int y)   // inline 与函数定义体放在一起</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果已定义的函数多于一行，编译器会忽略 inline 限定符。</strong></p>
<p>在<strong>类定义中的定义的函数都是内联函数</strong>，即使没有使用 <strong>inline</strong> 说明符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123; </span><br><span class="line">	public:</span><br><span class="line"> 	void Foo(int x, int y) &#123; ... &#125;   // 自动地成为内联函数 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为什么要设置内联函数 ?</p>
<p>下列有关内联函数的叙述中，正确的是______。</p>
<p>(A)内联函数在调用时发生控制转移</p>
<p>(B)内联函数只能通过关键字inline来定义</p>
<p>(C)内联函数是通过编译器来实现的</p>
<p>(D)内联函数函数体的最后一条语句必须是return语句</p>
<p>正确答案<br>C</p>
<p>答案解析<br>[解析] 此题考查的是内联函数的概念．</p>
<p>在调用时，<strong>内联函数会像宏函数一样地层开</strong>，将调用表达式用内联函数体来替换，所以它<strong>没有一般函数的参数压栈和退栈操作</strong>，所以选项A) 错误；</p>
<p>即使没有使用inline说明，编译器也会将在<strong>类的说明部分定义的函数</strong>认定为内联函数，所以选项B) 错误;</p>
<p>内联函数只是比普通函数有<strong>更高的执行效率</strong>。对于类型为void的函数，它不需要返回任何函数值，所以在函数体中既可以使用return语句，也可以不使用，选项D) 错误。</p>
</blockquote>
<blockquote>
<p>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p>
<p>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p>
<p>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
</blockquote>
<h3 id="头文件和extern"><a href="#头文件和extern" class="headerlink" title="?头文件和extern"></a>?头文件和extern</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/extern-head-h-different.html">https://www.runoob.com/w3cnote/extern-head-h-different.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuqian123455/article/details/102856728">https://blog.csdn.net/yuqian123455/article/details/102856728</a></p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211224235921687.png" alt="image-20211224235921687"> </p>
<blockquote>
<p>#include命令就是原封不同的把头文件中的内容搬到#include的位置 , 所以头文件里<strong>放声明,不要定义</strong>,比如全局变量,不然会重复定义,想重复使用的话就在一个c文件里正常<strong>定义</strong>(分配空间),另一个C文件<strong>声明</strong>全局变量(告诉编译器名字),表示在外部已经定义</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211224225516341.png" alt="image-20211224225516341"> </p>
<p><img src="/2021/10/26/C++/image-20211224232513817.png" alt="image-20211224232513817"> </p>
<blockquote>
<p> 头文件用来放结构体定义好些,在C文件里就只用extern,不用占内存</p>
</blockquote>
<h3 id="全局变量和局部变量-extern"><a href="#全局变量和局部变量-extern" class="headerlink" title="?全局变量和局部变量(extern)"></a>?全局变量和局部变量(extern)</h3><p><img src="/2021/10/26/C++/image-20211123150514219.png" alt="image-20211123150514219"> </p>
<p>先定义再使用 就不用加extern</p>
<p>先使用再定义 就加extern表示是外部变量</p>
<p>extern用在变量声明中常常有这样一个作用:</p>
<p>你在<code>.c</code>文件中<strong>声明</strong>了一个全局的变量，这个全局的变量如果要被引用，就放在<code>.h</code>中并用<code>extern</code>来声明。????</p>
<blockquote>
<p>在定义变量的时候，extern可以被省略(定义时，默认均省略)；在声明变量的时候，这个extern必须添加在变量前</p>
<p>所以有时会让你搞不清楚到底是声明还是定义。或者说，变量前有extern不一定就是声明，而变量前无extern就只能是定义。</p>
</blockquote>
<blockquote>
<p>extern 和 static</p>
<p>(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.<br>(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.</p>
<p>static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是<strong>extern可以被其他的对象用extern 引用</strong>,而static 不可以,<strong>只允许对象本身用它</strong>. </p>
<p>具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量<strong>声明与定义同时进行</strong>，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；</p>
<p>最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它</p>
</blockquote>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><img src="/2021/10/26/C++/image-20211123145040660.png" alt="image-20211123145040660"> </p>
<h3 id="作用域解析运算符-区分空间中的局部变量和全局变量"><a href="#作用域解析运算符-区分空间中的局部变量和全局变量" class="headerlink" title="*作用域解析运算符 :: (区分空间中的局部变量和全局变量)"></a>*作用域解析运算符 :: (区分空间中的局部变量和全局变量)</h3><p>若存在同名的局部变量和全局变量，则<strong>缺省</strong>引用<strong>局部</strong>变量</p>
<p>若需引用<strong>全局</strong>变量，需在变量名 前加 <code>::</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">7</span>;                 <span class="comment">// 局部变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="comment">// i=7，局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i;            <span class="comment">// i=5，局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量 i=&quot;</span> &lt;&lt; ::i; <span class="comment">// 引用全局变量，i=2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间-区分空间"><a href="#命名空间-区分空间" class="headerlink" title="*命名空间(区分空间)"></a>*命名空间(区分空间)</h3><p>不同模块中的类和函数可能存在重名。为解决这个问题，C++ 引入命名空间概念。</p>
<p><img src="/2021/10/26/C++/image-20211202205443153.png" alt="image-20211202205443153"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> mynames</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">my_max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> mynames::k;</span><br><span class="line">    <span class="keyword">using</span> mynames::my_max;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;pi=&quot; &lt;&lt; pi &lt;&lt; &quot;\n&quot; &lt;&lt; endl; // ERROR</span></span><br><span class="line">    y = <span class="built_in">my_max</span>(x, k); <span class="comment">// OK</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mynames::my_max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> mynames ::k;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;k after change in func(main) = &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生存期-静态-amp-动态"><a href="#生存期-静态-amp-动态" class="headerlink" title="生存期 (静态&amp;动态)"></a>生存期 (静态&amp;动态)</h3><p>(1) 静态生存期：生存期与程序的运行期相同，即一直有效； (静态变量和全局变量)</p>
<p>(2) 动态生存期：当对象所在的程序块执行完后即消失； (动态变量,局部变量缺省为动态变量)</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>(1) 静态变量的声明 static 类型标识符 变量名;</p>
<p>(2) 静态局部变量不会随函数的调用结束而消失，下次调用该函数时，该变量会保持上次调用结束后的值； </p>
<p>(3) 没有初始化的静态变量会自动初始化为 0；</p>
<p>(4) 静态变量<strong>只能初始化一次</strong>。</p>
<blockquote>
<p>extern 和 static</p>
<p> (1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.<br> (2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.</p>
<p>  static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它</p>
</blockquote>
<p>声明和定义同时进行</p>
<p>作用域是本身的编译单元 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// 全局变量，静态生存期，缺省值为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;k=&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; endl; <span class="comment">// 没有初始化的静态变量自动赋值为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">my_plus</span><span class="params">(<span class="keyword">int</span> x)</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x+i=&quot;</span> &lt;&lt; <span class="built_in">my_plus</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x+i=&quot;</span> &lt;&lt; <span class="built_in">my_plus</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_plus</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 静态局部变量，初值为 5，只能初始化一次</span></span><br><span class="line">    <span class="comment">// 第二次调用不再初始化，而是直接使用上一次调用结束后的值，即 i=10</span></span><br><span class="line"></span><br><span class="line">    i = x + i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="形参带缺省值"><a href="#形参带缺省值" class="headerlink" title="//形参带缺省值"></a>//形参带缺省值</h3><p>先声明再定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">1</span>, <span class="keyword">int</span> y = <span class="number">2</span>)</span></span>; <span class="comment">// 声明,在该作用域中先出现,所以缺省值在此时设定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">3</span>, <span class="keyword">int</span> y = <span class="number">4</span>)</span></span>; <span class="comment">// 不同作用域的声明可设定不同的缺省值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main: add()=&quot;</span> &lt;&lt; <span class="built_in">add</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In fun: add()=&quot;</span> &lt;&lt; <span class="built_in">add</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 定义,不能再设置缺省值了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//In main: add()=7</span></span><br><span class="line"><span class="comment">//In fun: add()=3</span></span><br></pre></td></tr></table></figure>

<p>先定义再声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">1</span>, <span class="keyword">int</span> y = <span class="number">2</span>)</span> <span class="comment">// 定义时设定缺省值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;<span class="comment">//不能有缺省值,这一句其实可以去掉吧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">3</span>, <span class="keyword">int</span> y = <span class="number">4</span>)</span></span>; <span class="comment">// 不同作用域的声明可设定不同的缺省值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main: add()=&quot;</span> &lt;&lt; <span class="built_in">add</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main: add(11)=&quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">11</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main: add(11,12)=&quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">11</span>, <span class="number">12</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int add(int x = 5, int y = 6); // 不同作用域的声明可设定不同的缺省值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In fun: add()=&quot;</span> &lt;&lt; <span class="built_in">add</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In fun: add(11)=&quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">11</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main: add(11,12)=&quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">11</span>, <span class="number">12</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="预编译处理与多文件结构"><a href="#预编译处理与多文件结构" class="headerlink" title="//预编译处理与多文件结构"></a>//预编译处理与多文件结构</h3><ul>
<li>头文件</li>
</ul>
<p><img src="/2021/10/26/C++/image-20211202231333236.png" alt="image-20211202231333236"> </p>
<p><img src="/2021/10/26/C++/image-20211202231350967.png" alt="image-20211202231350967"> </p>
<ul>
<li>定义宏</li>
</ul>
<p><img src="/2021/10/26/C++/image-20211202231435395.png" alt="image-20211202231435395"> </p>
<ul>
<li>条件编译</li>
</ul>
<p><img src="/2021/10/26/C++/image-20211202231906885.png" alt="image-20211202231906885"> </p>
<p><img src="/2021/10/26/C++/image-20211202231910552.png" alt="image-20211202231910552"> </p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组初始化"><a href="#一维数组初始化" class="headerlink" title="一维数组初始化"></a>一维数组初始化</h3><blockquote>
<p> 一维数组的初始化：在声明时可以同时赋初值。</p>
<p>(1) 全部元素都初始化时可以不指定数组长度，系统会根据所给的数据自动确定数组的长度，如 int x[]={0,2,4,6,8};</p>
<p>(2) 可以部分初始化，即只给部分元素赋初值，如 int x[5]={0,2,4}; </p>
<p>(3) 若数组声明时进行了部分初始化，则没有初始化的元素自动赋值为 0；</p>
<p>(4) 声明数组时，若长度为一个表达式，且含有变量，则不能初始化！ </p>
<ul>
<li>只能对数组元素赋值，不能对数组名赋值！</li>
<li>若数组元素没有赋值，则其值是不确定的（静态类型数据除外）； </li>
<li>注意数组声明与数组引用的区别； </li>
<li>注意数组初始化与数组赋值的区别。(初始化包括赋值)</li>
</ul>
</blockquote>
<h3 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h3><p><img src="/2021/10/26/C++/image-20211203083719797.png" alt="image-20211203083719797"> </p>
<h3 id="数组做函数参数"><a href="#数组做函数参数" class="headerlink" title="*数组做函数参数"></a>*数组做函数参数</h3><p><img src="/2021/10/26/C++/image-20211203083952722.png" alt="image-20211203083952722"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 代表一维数组的形参可以省略维数，但需添加一个形参传递数组大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> x[n] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, y[n] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; x[i] &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;y[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; y[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_swap</span>(x, y, n); <span class="comment">// 调用时只需传递数组名（首地址）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; x[i] &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;y[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; y[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p><img src="/2021/10/26/C++/image-20211203090148538.png" alt="image-20211203090148538"> </p>
<p>数组名相当于一个常量指针,指针本身的值不能修改(数组的首地址)</p>
<h3 id="指针与二维数组-A与A-0-的区别"><a href="#指针与二维数组-A与A-0-的区别" class="headerlink" title="指针与二维数组(A与A[0] 的区别)"></a>指针与二维数组(A与A[0] 的区别)</h3><p><img src="/2021/10/26/C++/image-20211203100211433.png" alt="image-20211203100211433"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A和A[0]都是数组首地址,A是二维数组,A[0]是一维数组&#123;1,2,3&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;A[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*A与A[0]等价&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; **A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *A[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态数组-new-delete"><a href="#动态数组-new-delete" class="headerlink" title="//动态数组(new/delete)"></a>//动态数组(new/delete)</h3><p> <img src="/2021/10/26/C++/image-20211225135843365.png" alt="image-20211225135843365"> </p>
<p><img src="/2021/10/26/C++/image-20211225140021736.png" alt="image-20211225140021736">  </p>
<img src="/2021/10/26/C++/image-20211225001757748.png" alt="image-20211225001757748" style="zoom:80%;"> 

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="*面向对象"></a>*面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>成员包括数据和函数</p>
<p>成员的访问属性 : (缺省是private)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公有</span></span><br><span class="line">    <span class="comment">//公有成员（外部接口）</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有</span></span><br><span class="line">    <span class="comment">//私有成员</span></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// 保护</span></span><br><span class="line">    <span class="comment">//保护型成员</span></span><br><span class="line">&#125;;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">public</span>（公有、外部接口）：任何外部函数都可以访问公有类型的数据和函数。</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">private</span>（私有）：只能被本类中的函数成员访问，任何来自外部的访问都非法。</span><br><span class="line">(<span class="number">3</span>) <span class="keyword">protected</span>（保护）：与私有类似，区别在于继承过程中的影响不同，将在后面章节中详细解</span><br><span class="line">释。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明一个类时，并没有为这个类分配内存，而只是告诉编译器这个类是什么，即包含哪些 数据，有什么功能。</p>
</blockquote>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>对象创建 : (声明对象就是实例化)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数成员在内存中只占一份空间，不会在每个对象中存储副本</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211225192958919.png" alt="image-20211225192958919"> </p>
<blockquote>
<p>动态建立得到一个指针,可以用<code>-&gt;</code>访问元素(public的前提下)</p>
<p><img src="/2021/10/26/C++/image-20211225211801536.png" alt="image-20211225211801536"> </p>
<p>静态建立得到一个对象相当于一种新的数据类型,用<code>.</code>可以访问元素(public的前提下)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPoint1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> x, y;</span><br><span class="line">   <span class="built_in">TPoint1</span>(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span><br><span class="line">   &#123; <span class="comment">//构造函数</span></span><br><span class="line">      x = x1;</span><br><span class="line">      y = y1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dispoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="comment">//输出点的信息</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">TPoint1 <span class="title">a</span><span class="params">(<span class="number">12</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">   TPoint1 *p = <span class="keyword">new</span> <span class="built_in">TPoint1</span>(<span class="number">5</span>, <span class="number">12</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;First point: &quot;</span>;</span><br><span class="line">   a.<span class="built_in">dispoint</span>();</span><br><span class="line">   cout &lt;&lt; a.x &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;second point: &quot;</span>;</span><br><span class="line">   p-&gt;<span class="built_in">dispoint</span>();</span><br><span class="line">   cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; p-&gt;x &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &amp;(p-&gt;x) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &amp;(p-&gt;y) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>成员的访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名</span><br><span class="line">对象名.函数成员名(参数列表</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>类的成员函数</strong>可以访问所有的数据,<strong>外部函数</strong>只能访问共有成员</p>
</blockquote>
<p>成员函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> // 时钟类的声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 外部接口，公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> h=<span class="number">0</span>, <span class="keyword">int</span> m=<span class="number">0</span>, <span class="keyword">int</span> s=<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有数据成员</span></span><br><span class="line">    <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在类中可以直接定义函数,也可以只声明函数原型，函数的具体实现可以在类外部定义；(名字是类名 :: 函数名)</p>
</blockquote>
<h3 id="构造函数-对象初始化"><a href="#构造函数-对象初始化" class="headerlink" title="构造函数(对象初始化)"></a>构造函数(对象初始化)</h3><blockquote>
<p>• 对象的初始化：创建对象时，设置数据成员的值。 </p>
<p>• 构造函数：负责对象的初始化，即创建对象时，对其数据成员进行初始化。 </p>
<p>• 对象创建的过程：</p>
<p>​        (1) 申请<strong>内存空间</strong>（用于存放数据成员）； </p>
<p>​        (2) <strong>初始化</strong>：自动调用构造函数初始化数据成员。 </p>
<p>• 构造函数几点说明： </p>
<p>​        (1) 构造函数的<strong>函数名与类的名称</strong>相同； </p>
<p>​        (2) 构造函数<strong>没有返回值</strong>，前面也不需要带任何返回数据类型； </p>
<p>​        (3) 构造函数在对象创建时会被系统<strong>自动调用</strong>； </p>
<p>​        (4) 缺省构造函数：若用户没有定义构造函数，则系统会自动生成构造函数，形参和函数体都为 空（如 Clock() { }），但如果用户自己定义了构造函数，则系统不再提供缺省构造函数； </p>
<p>​        (5) 构造函数可以是内联函数，形参可以带缺省值； </p>
<p>​        (6) 使用不带参数的构造函数初始化对象时<strong>不需要加小括号</strong>。 </p>
<p>• 构造函数可以重载，即可定义多个构造函数</p>
</blockquote>
<blockquote>
<p><strong>全是缺省值</strong>不要小括号.<strong>没有参数</strong>也不要小括号</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Clock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Clock();                    // 不带形参的构造函数</span><br><span class="line">    Clock(int x, int y, int z); // 带三个形参的构造函数</span><br><span class="line">    void ShowTime();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不带形参的构造函数</span><br><span class="line">Clock::Clock()</span><br><span class="line">&#123;</span><br><span class="line">    hour = 0;</span><br><span class="line">    minute = 0;</span><br><span class="line">    second = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 带三个形参的构造函数</span><br><span class="line">Clock::Clock(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    hour = x;</span><br><span class="line">    minute = y;</span><br><span class="line">    second = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void Clock::ShowTime()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() // 主函数</span><br><span class="line">&#123;</span><br><span class="line">    Clock c1;             // 调用不带形参的构造函数初始化 c1</span><br><span class="line">    Clock c2(16, 12, 25); // 调用带形参的构造函数初始化 c2</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;c1: &quot;;</span><br><span class="line">    c1.ShowTime();</span><br><span class="line">    cout &lt;&lt; &quot;c2: &quot;;</span><br><span class="line">    c2.ShowTime();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制构造函数-将已经有的对象值复制给其他对象"><a href="#复制构造函数-将已经有的对象值复制给其他对象" class="headerlink" title="//复制构造函数(将已经有的对象值复制给其他对象)"></a>//复制构造函数(将已经有的对象值复制给其他对象)</h4><blockquote>
<p>浅拷贝 : 复制空间不复制资源,改了一个另一个也会变</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211225150209701.png" alt="image-20211225150209701"> </p>
<p><img src="/2021/10/26/C++/image-20211225150230147.png" alt="image-20211225150230147"> </p>
<p><img src="/2021/10/26/C++/image-20211225150943750.png" alt="image-20211225150943750"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 复制构造函数</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point // Point 类的声明</span><br><span class="line">&#123;</span><br><span class="line">public:                         // 外部接口</span><br><span class="line">    Point(int a = 0, int b = 0) // 构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(const Point &amp;); // 复制构造函数，常引用（对象的常引用将在后面介绍）</span><br><span class="line">    int Getx() &#123; return x; &#125;</span><br><span class="line"></span><br><span class="line">private: // 私有数据</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 复制构造函数</span><br><span class="line">Point::Point(const Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    x = p.x;</span><br><span class="line">    y = p.y;</span><br><span class="line">    cout &lt;&lt; &quot;自定义复制构造函数被调用!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 形参为 Point 类对象的函数</span><br><span class="line">void f(Point p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;x=&quot; &lt;&lt; p.Getx() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回值为 Point 类对象的函数</span><br><span class="line">Point g()</span><br><span class="line">&#123;</span><br><span class="line">    Point A(1, 2);</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() // 主函数</span><br><span class="line">&#123;</span><br><span class="line">    Point A(4, 5); // 第一个对象A</span><br><span class="line"></span><br><span class="line">    // 情况一：用 A 初始化 B(注意不是赋值)，调用自定义复制构造函数</span><br><span class="line">    cout &lt;&lt; &quot;Point B(A): &quot;;</span><br><span class="line">    Point B(A); // 或 Point B=A;</span><br><span class="line">    cout &lt;&lt; &quot;x=&quot; &lt;&lt; B.Getx() &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 情况二：对象 B 作为函数的实参，形参和实参之间值传递时调用自定义复制构造函数</span><br><span class="line">    cout &lt;&lt; &quot;f(B): &quot;;</span><br><span class="line">    f(B);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 自定义的复制构造函数不改变赋值号的行为</span><br><span class="line">    cout &lt;&lt; &quot;C=A: &quot;;</span><br><span class="line">    Point C;</span><br><span class="line">    C = A; // 赋值：调用缺省的复制构造函数</span><br><span class="line">    cout &lt;&lt; &quot;x=&quot; &lt;&lt; C.Getx() &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;C=g(): &quot;;</span><br><span class="line">    C = g(); // 赋值：调用缺省的复制构造函数</span><br><span class="line">    cout &lt;&lt; &quot;x=&quot; &lt;&lt; C.Getx() &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Point B(A): 自定义复制构造函数被调用!</span><br><span class="line">x=4</span><br><span class="line"></span><br><span class="line">f(B): 自定义复制构造函数被调用!</span><br><span class="line">x=4</span><br><span class="line"></span><br><span class="line">C=A: x=4</span><br><span class="line"></span><br><span class="line">C=g(): x=1</span><br></pre></td></tr></table></figure>

<h3 id="析构函数-负责对象释放时的一些清理工作"><a href="#析构函数-负责对象释放时的一些清理工作" class="headerlink" title="析构函数(负责对象释放时的一些清理工作)"></a>析构函数(负责对象释放时的一些清理工作)</h3><blockquote>
<p>• 析构函数的一般形式：</p>
<p>~类名() { 函数体 }</p>
<p>(1) 析构函数的函数名由类名前加“~”组成 </p>
<p>(2) 析构函数<strong>没有返回值</strong>，也不需要加返回值数据类型 </p>
<p>(3) 析构函数在对象生存期即将结束时被<strong>自动调用</strong> </p>
<p>(4) 析构函数<strong>不接收任何参数</strong> </p>
<p>(5) 若没有析构函数，系统会<strong>自动生成</strong>一个析构函数（函数体为空）</p>
</blockquote>
<h3 id="面向对象1作业"><a href="#面向对象1作业" class="headerlink" title="面向对象1作业"></a>面向对象1作业</h3><p>9.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 设计一个名为 Rectangle 的类：表示矩形，这个类包括：</span><br><span class="line">// ? 两个 double 型数据成员：width 和 height，分别表示宽和高</span><br><span class="line">// ? 一个不带形参的构造函数，用于创建缺省矩形：宽和高都为 1</span><br><span class="line">// ? 一个带形参的构造函数，用于创建指定宽度和高度的矩形</span><br><span class="line">// ? 成员函数 setwh(double, double)，用于更改矩形的宽度和高度</span><br><span class="line">// ? 成员函数 getw()，用于获取矩形的宽度</span><br><span class="line">// ? 成员函数 geth()，用于获取矩形的高度</span><br><span class="line">// ? 成员函数 getArea()，返回矩形的面积</span><br><span class="line">// ? 成员函数 getPerimeter()，返回矩形的周长</span><br><span class="line">// 实现这个类，并在主函数中测试这个类：创建两个 Rectangle 对象：R1 和 R2，其中 R1 的宽和</span><br><span class="line">// 高分别为 4 和 40，R2 的宽和高分别为 3.5 和 35.9，并在屏幕上输出 R1 和 R2 的面积和周长。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Rectangle</span><br><span class="line">&#123;</span><br><span class="line">public: //要加，缺省是private，只有本类里的函数能访问,外部访问非法（比如main函数）</span><br><span class="line">   Rectangle();</span><br><span class="line">   Rectangle(double a, double b);</span><br><span class="line">   void setwh(double a, double b);</span><br><span class="line">   double getw();</span><br><span class="line">   double geth();</span><br><span class="line">   double getArea();</span><br><span class="line">   double getPer();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">   double width, height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle()</span><br><span class="line">&#123;</span><br><span class="line">   width = 1;</span><br><span class="line">   height = 1;</span><br><span class="line">&#125;</span><br><span class="line">Rectangle::Rectangle(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">   width = a;</span><br><span class="line">   height = b;</span><br><span class="line">&#125;</span><br><span class="line">void Rectangle::setwh(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">   width = a;</span><br><span class="line">   height = b;</span><br><span class="line">&#125;</span><br><span class="line">double Rectangle::getw()</span><br><span class="line">&#123;</span><br><span class="line">   return width;</span><br><span class="line">&#125;</span><br><span class="line">double Rectangle::geth()</span><br><span class="line">&#123;</span><br><span class="line">   return height;</span><br><span class="line">&#125;</span><br><span class="line">double Rectangle::getArea()</span><br><span class="line">&#123;</span><br><span class="line">   return width * height;</span><br><span class="line">&#125;</span><br><span class="line">double Rectangle::getPer()</span><br><span class="line">&#123;</span><br><span class="line">   return 2 * (width + height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   Rectangle R1(4, 40);</span><br><span class="line">   Rectangle R2(3.5, 35.9);</span><br><span class="line">   cout &lt;&lt; R1.getArea() &lt;&lt; endl</span><br><span class="line">        &lt;&lt; R1.getPer() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; R2.getArea() &lt;&lt; endl</span><br><span class="line">        &lt;&lt; R2.getPer() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="*面向对象进阶"></a>*面向对象进阶</h2><h3 id="组合类-要有初始化列表-初始化内嵌对象"><a href="#组合类-要有初始化列表-初始化内嵌对象" class="headerlink" title="组合类(要有初始化列表,初始化内嵌对象)"></a>组合类(要有初始化列表,初始化内嵌对象)</h3><p>创建类的对象时,类的数据成员包括别的类的对象(内嵌对象),内嵌对象先被自动创建</p>
<p><img src="/2021/10/26/C++/image-20211225195957226.png" alt="image-20211225195957226"> </p>
<blockquote>
<p>不想初始化列表的话就需要构造函数带缺省值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> // 声明类 <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:                                     <span class="comment">// 外部接口</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> newx = <span class="number">0</span>, <span class="keyword">double</span> newy = <span class="number">0</span>) <span class="comment">// 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = newx;</span><br><span class="line">        y = newy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 获取横坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125; <span class="comment">// 获取纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//私有数据成员</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> // 声明类 <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:                                                          <span class="comment">// 外部接口</span></span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">double</span> xA, <span class="keyword">double</span> yA, <span class="keyword">double</span> xB, <span class="keyword">double</span> yB) : <span class="built_in">A</span>(xA, yA) <span class="comment">// 构造函数,初始化列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        B = <span class="built_in">Point</span>(xB, yB);<span class="comment">//构造函数带缺省值才行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getlength</span><span class="params">()</span></span>; <span class="comment">// 计算线段的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有数据成员</span></span><br><span class="line">    Point A, B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getlength</span><span class="params">()</span> <span class="comment">// 计算线段的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> xx, yy;</span><br><span class="line">    xx = B.<span class="built_in">getx</span>() - A.<span class="built_in">getx</span>();</span><br><span class="line">    yy = B.<span class="built_in">gety</span>() - A.<span class="built_in">gety</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(xx * xx + yy * yy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// 主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Line <span class="title">AB</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线段长度: &quot;</span> &lt;&lt; AB.<span class="built_in">getlength</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p><img src="/2021/10/26/C++/image-20211225194715164.png" alt="image-20211225194715164"> </p>
<p><img src="/2021/10/26/C++/image-20211225194924623.png" alt="image-20211225194924623"> </p>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p><img src="/2021/10/26/C++/image-20211225195022805.png" alt="image-20211225195022805"> </p>
<blockquote>
<p>为啥要引入静态成员函数？</p>
<p>设计背景：有些方法需要在不实例化的情况下调用</p>
<p>静态成员变量可以视为一种全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。</p>
<p>静态成员函数可视为一种全局函数。</p>
<p>设置静态成员（包括变量以及函数）这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</p>
</blockquote>
 <img src="/2021/10/26/C++/image-20211225195336043.png" alt="image-20211225195336043" style="zoom:150%;">

<blockquote>
<p>在实例化前就调用了静态函数,得到了对象的总数</p>
</blockquote>
<h3 id="面向对象2作业"><a href="#面向对象2作业" class="headerlink" title="面向对象2作业"></a>面向对象2作业</h3><p>10.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">类的组合：</span><br><span class="line">(a) 设计一个名为 Score 的类，表示成绩，这个类包括：</span><br><span class="line">• 两个 int 型数据成员：math 和 eng，分别表示数学成绩和英语成绩</span><br><span class="line">• 一个带两个形参的构造函数，用给定的分数初始化 math 和 eng</span><br><span class="line">• 成员函数 show()，输出数学成绩和英语成绩</span><br><span class="line">(b) 设计一个名为 Student 的类，表示学生，这个类包括：</span><br><span class="line">• 两个数据成员：stuid（int 型，表示学号）和 mark（Score 对象）</span><br><span class="line">• 一个带三个形参的构造函数，对数据成员进行初始化</span><br><span class="line">• 成员函数 stushow()，输出学号和相应的成绩</span><br><span class="line"></span><br><span class="line">实现这两个类，并在主函数中测试这个类：创建一个学生：学号为 2017007，数学成绩为 98，英</span><br><span class="line">语成绩为 85，在屏幕上输出该生的学号和成绩。（程序取名 hw10_01.cpp）</span><br><span class="line">（注：若没有特别说明，所有数据成员都是 private，所有函数成员都是 public）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class score</span><br><span class="line">&#123;</span><br><span class="line">	int math, eng;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	score(int a, int b);</span><br><span class="line">	void show();</span><br><span class="line">&#125;;</span><br><span class="line">class student</span><br><span class="line">&#123;</span><br><span class="line">	int stuid;</span><br><span class="line">	score mark;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	student(int a, int b, int c);</span><br><span class="line">	void stushow();</span><br><span class="line">&#125;;</span><br><span class="line">score::score(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	math = a;</span><br><span class="line">	eng = b;</span><br><span class="line">&#125;</span><br><span class="line">void score::show()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; math &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; eng &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">student::student(int a, int b, int c) : mark(b, c)</span><br><span class="line">&#123;</span><br><span class="line">	stuid = a;</span><br><span class="line">&#125;</span><br><span class="line">void student::stushow()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; stuid &lt;&lt; endl;</span><br><span class="line">	mark.show();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	student a(2017007, 98, 85);</span><br><span class="line">	a.stushow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象提高"><a href="#面向对象提高" class="headerlink" title="*面向对象提高"></a>*面向对象提高</h2><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p><img src="/2021/10/26/C++/image-20211225211523710.png" alt="image-20211225211523710"> </p>
<blockquote>
<p>const 右边的是int就是修饰变量</p>
<p>const 右边的是指针名则修饰指针</p>
<p>或者 const在*左边,指针指向常量,const在*右边,指针为常量</p>
<p>const 修饰类对象就不能修改成员变量的值,不能调用非const成员方法</p>
</blockquote>
 <img src="/2021/10/26/C++/image-20211225210224997.png" alt="image-20211225210224997" style="zoom:80%;">

<blockquote>
<p>只读,要初始化</p>
<p>const int * ptr 指向const变量</p>
<p>int * const ptr const指针</p>
<p>修饰对象如下</p>
</blockquote>
<h3 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a>const对象</h3><p><img src="/2021/10/26/C++/image-20211225205331501.png" alt="image-20211225205331501"> </p>
<blockquote>
<p>不能改,所以要初始化</p>
<p>常对象不能改变成员变量,也不能调用非const成员函数</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211225211136221.png" alt="image-20211225211136221"> </p>
<blockquote>
<p>常数据成员要初始化,不能赋值</p>
</blockquote>
<p> <img src="/2021/10/26/C++/image-20211225211223262.png" alt="image-20211225211223262"></p>
<blockquote>
<p>在名字后面加const</p>
<p>可以访问变量,不能修改</p>
<p>普通对象 + 常函数(√) , 普通对象 + 普通函数(√)</p>
<p>常对象 + 常函数(√) , 常对象 + 普通函数(×)</p>
</blockquote>
<h3 id="class和struct区别"><a href="#class和struct区别" class="headerlink" title="//class和struct区别"></a>//class和struct区别</h3><img src="/2021/10/26/C++/image-20211225210127368.png" alt="image-20211225210127368" style="zoom:80%;"> 



<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><img src="/2021/10/26/C++/image-20211225205729149.png" alt="image-20211225205729149"> </p>
<p><img src="/2021/10/26/C++/image-20211225212823167.png" alt="image-20211225212823167"> </p>
<blockquote>
<p>成员函数的参数 和 成员变量 同名,可以用this 区分</p>
<p>指针要用-&gt;来访问变量/函数</p>
<p>const指针指向的东西不变</p>
</blockquote>
<h3 id="向量类-字符串类…课上没讲"><a href="#向量类-字符串类…课上没讲" class="headerlink" title="向量类,字符串类…课上没讲"></a>向量类,字符串类…课上没讲</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2021/10/26/C++/image-20211225214804484.png" alt="image-20211225214804484"> </p>
<h4 id="输入输出用cin-gt-gt-、cout-lt-lt"><a href="#输入输出用cin-gt-gt-、cout-lt-lt" class="headerlink" title="输入输出用cin&gt;&gt;、cout&lt;&lt;"></a>输入输出用cin&gt;&gt;、cout&lt;&lt;</h4><p><img src="/2021/10/26/C++/image-20211225214821179.png" alt="image-20211225214821179"> </p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><img src="/2021/10/26/C++/image-20211225214853543.png" alt="image-20211225214853543"> </p>
<h4 id="和数组字符串"><a href="#和数组字符串" class="headerlink" title="和数组字符串"></a>和数组字符串</h4><p><img src="/2021/10/26/C++/image-20211225214945679.png" alt="image-20211225214945679"> </p>
<h4 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h4><p><img src="/2021/10/26/C++/image-20211225215050801.png" alt="image-20211225215050801"> </p>
<h3 id="面向对象3作业"><a href="#面向对象3作业" class="headerlink" title="面向对象3作业"></a>面向对象3作业</h3><p>11.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 设计一个名为 Rectangle2D 的类，表示平面坐标下的一个矩形，这个类包括</span><br><span class="line">// ? 四个 double 型数据成员 x, y, width, height，分别表示矩形中心坐标、宽和高</span><br><span class="line">// ? 一个不带形参的构造函数，用于创建缺省矩形 (x,y)=(0,0), width=height=1</span><br><span class="line">// ? 一个带形参的构造函数</span><br><span class="line">// Rectangle2D(double x, double y, double width, double height);</span><br><span class="line">// ? 成员函数 getAera()，返回矩形面积</span><br><span class="line">// ? 成员函数 contains(double x, double y)，当给定点 (x,y) 在矩形内时返回 true，否</span><br><span class="line">// 则返回 false，如下页图 a)</span><br><span class="line">// ? 成员函数 contains(const Rectangle2D &amp; r)，当给定矩形在当前矩形内时返回 true，</span><br><span class="line">// 否则返回 false，如下页图 b)</span><br><span class="line">// ? 成员函数 overlaps(const Rectangle2D &amp; r)，当给定矩形与当前矩形有重叠时返回</span><br><span class="line">// true，否则返回 false，如下页图 c)</span><br><span class="line">// 实现这个类，并在主函数中测试这个类 创建 r1(2,2,5.4,4.8), r2(4,5,10.6,3.3) 和</span><br><span class="line">// r3(3,5,2.2,5.5)，输出 r1 的面积，以及 r1.contains(3,3)，r1.contains(r2)和</span><br><span class="line">// r1.overlaps(r3) 的结果。（程序取名 hw11_01.cpp）</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Rectangle2D</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    double x, y, width, height;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Rectangle2D()</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">        y = 0;</span><br><span class="line">        width = 1;</span><br><span class="line">        height = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle2D(double x, double y, double width, double height);</span><br><span class="line">    double getAera() &#123; return width * height; &#125;</span><br><span class="line">    const bool contains(double x, double y); //当给定点 (x,y) 在矩形内时返回 true</span><br><span class="line">    bool contains(const Rectangle2D &amp;r);     //当给定矩形在当前矩形内时返回 true</span><br><span class="line">    bool overlaps(const Rectangle2D &amp;r);     //当给定矩形与当前矩形有重叠时返回true</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle2D ::Rectangle2D(double x, double y, double width, double height)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;x = x;</span><br><span class="line">    this-&gt;y = y;</span><br><span class="line">    this-&gt;width = width;</span><br><span class="line">    this-&gt;height = height;</span><br><span class="line">&#125;</span><br><span class="line">const bool Rectangle2D ::contains(double x, double y)</span><br><span class="line">&#123;</span><br><span class="line">    if ((this-&gt;x - width / 2 &lt; x &amp;&amp; this-&gt;x + width / 2 &gt; x) &amp;&amp; (this-&gt;y - height / 2 &lt; y &amp;&amp; this-&gt;y + height / 2 &gt; y))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">bool Rectangle2D ::contains(const Rectangle2D &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    //参数是常对象，不能用非const函数</span><br><span class="line">    if (this-&gt;contains(r.x - r.width / 2, r.y + r.height / 2) &amp;&amp; this-&gt;contains(r.x + r.width / 2, r.y + r.height / 2) &amp;&amp; this-&gt;contains(r.x - r.width / 2, r.y - r.height / 2) &amp;&amp; this-&gt;contains(r.x - r.width / 2, r.y - r.width / 2))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">bool Rectangle2D ::overlaps(const Rectangle2D &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    if (this-&gt;contains(r.x - r.width / 2, r.y + r.height / 2) || this-&gt;contains(r.x + r.width / 2, r.y + r.height / 2) || this-&gt;contains(r.x - r.width / 2, r.y - r.height / 2) || this-&gt;contains(r.x - r.width / 2, r.y - r.width / 2))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Rectangle2D r1(2, 2, 5.4, 4.8), r2(4, 5, 10.6, 3.3), r3(3, 5, 2.2, 5.5);</span><br><span class="line">    cout &lt;&lt; r1.getAera() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; r1.contains(3, 3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; r1.contains(r2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; r1.overlaps(r3) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第七周继承与派生"><a href="#第七周继承与派生" class="headerlink" title="*第七周继承与派生"></a>*第七周继承与派生</h2><p>• 类的派生：在已有类的基础上产生新类的过程； </p>
<p>• 类的继承：派生类继承了父类的特性，包括数据成员和函数成员；</p>
<p><img src="/2021/10/26/C++/image-20211229170937349.png" alt="image-20211229170937349"> </p>
<p><img src="/2021/10/26/C++/image-20211229183521710.png" alt="image-20211229183521710"> </p>
<p>派生过程 ： </p>
<blockquote>
<p>(1) 吸收父类成员：派生类包含父类中<strong>除构造函数和析构函数外的所有非静态成员</strong> (构造函数，析构函数和静态成员不能被继承。)</p>
<p>(2) 改造父类成员：通过继承方式改变父类成员的访问控制 ­ 对父类成员的<strong>屏蔽</strong>（如果新成员与父类成员同名，则缺省只能访问新成员） </p>
<p>(3) 添加新成员：根据实际需要，添加新的数据成员或函数成员</p>
</blockquote>
<p>访问控制(缺省的派生方式为private)</p>
<blockquote>
<p>公有继承（public） ­       父类的公有和保护成员的访问属性<strong>保持不变</strong> ­ 父类的私有成员不可直接访问 </p>
<p>私有继承（private） ­     父类的公有和保护成员<strong>都成为派生类的私有成员</strong> ­ 父类的私有成员不可直接访问 </p>
<p>保护继承（protected） 父类的公有和保护成员<strong>都成为派生类的保护成员</strong> ­ 父类的私有成员不可直接访问</p>
<p><img src="/2021/10/26/C++/image-20211230130914175.png" alt="image-20211230130914175"> </p>
</blockquote>
<h3 id="派生类的构造函数-派生对象初始化"><a href="#派生类的构造函数-派生对象初始化" class="headerlink" title="派生类的构造函数(派生对象初始化)"></a>派生类的构造函数(派生对象初始化)</h3><p>派生类不能继承父类的构造和析构函数，必须自己定义</p>
<p>派生类对象的初始化： ­ 创建派生类对象时,对新的数据成员进行初始化.</p>
<p>派生类的构造函数<strong>只负责新增数据成员的初始化</strong> ­ 从父类继承的成员需通过调用父类的构造函数进行初始化 </p>
<p><img src="/2021/10/26/C++/image-20211229172805899.png" alt="image-20211229172805899"> </p>
<blockquote>
<p>总参数列表右边相当于内嵌函数的成员 ? 要被父类的构造函数初始化<img src="/2021/10/26/C++/image-20211229173151224.png" alt="image-20211229173151224"></p>
<p>次序 : </p>
<p>­调用父类的构造函数，按被继承时声明的顺序执行 ­ </p>
<p>对派生类新增对象成员初始化，按它们在类中声明的顺序执行 ­ </p>
<p>执行派生类的构造函数体的内容</p>
</blockquote>
<p>构造函数初始化顺序例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class B1 // 类 B1，构造函数有参数</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B1(int i) &#123; cout &lt;&lt; &quot;constructing B1 &quot; &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B2 // 类 B2，构造函数有参数</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B2(int j) &#123; cout &lt;&lt; &quot;constructing B2 &quot; &lt;&lt; j &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B3 // 类 B3，构造函数无参数</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B3() &#123; cout &lt;&lt; &quot;constructing B3 *&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public B2, public B1, public B3 // 派生类 C，注意父类的顺序</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    C(int a, int b, int c, int d) : B1(a), memberB2(d), memberB1(c), B2(b) //先按继承的顺序执行父类的构造函数,再按照初始化列表的顺序初始化派生类的成员,最后执行派生构造函数体</span><br><span class="line">    //先B2,B1,B3的构造函数,再初始化memberB1,memberB2,memberB3</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">    void Showx() &#123; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    B1 memberB1;</span><br><span class="line">    B2 memberB2;</span><br><span class="line">    B3 memberB3;</span><br><span class="line">    int x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    C obj(1, 2, 3, 4); //创建一个参数为1,2,3,4,名字为obj的C对象</span><br><span class="line"></span><br><span class="line">    obj.Showx();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructing B2 2</span><br><span class="line">constructing B1 1</span><br><span class="line">constructing B3 *</span><br><span class="line">constructing B1 3</span><br><span class="line">constructing B2 4</span><br><span class="line">constructing B3 *</span><br><span class="line">x=1</span><br></pre></td></tr></table></figure>

<p>访问控制例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person // 父类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(string &amp;str, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        name = str;</span><br><span class="line">        this-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    void show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string name; // 姓名</span><br><span class="line">    int age;     // 年龄</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student : public Person // 派生类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Student(string &amp;str, int age, int stuid) : Person(str, age)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;stuid = stuid;</span><br><span class="line">    &#125;</span><br><span class="line">    void showStu()</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;show(); // 不能直接访问 name 和 age,是父类的私有成员</span><br><span class="line">        cout &lt;&lt; &quot;Stuid: &quot; &lt;&lt; stuid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int stuid; // 学号</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str = &quot;Xi Jiajia&quot;;</span><br><span class="line">    Student stu1(str, 18, 20150108);</span><br><span class="line"></span><br><span class="line">    stu1.showStu();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="派生类成员的标识与访问"><a href="#派生类成员的标识与访问" class="headerlink" title="派生类成员的标识与访问"></a>派生类成员的标识与访问</h3><p>同名的话父类会被屏蔽 , 不管参数表是不是一样(只要同名,重载也会被屏蔽)</p>
<p>访问被屏蔽的成员 :</p>
<p><img src="/2021/10/26/C++/image-20211229174634548.png" alt="image-20211229174634548"> </p>
<blockquote>
<p>上面的例子改成Person::show就行了</p>
</blockquote>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>只负责新增数据成员的清理工作</p>
<h3 id="类型兼容规则-子类is-a-父类"><a href="#类型兼容规则-子类is-a-父类" class="headerlink" title="类型兼容规则(子类is a 父类)"></a>类型兼容规则(子类is a 父类)</h3><p>  <img src="/2021/10/26/C++/image-20211229182721160.png" alt="image-20211229182721160">         </p>
<blockquote>
<p>子类is a 父类,所以  </p>
<ul>
<li><p>子类对象可以当作父类对象使用<img src="/2021/10/26/C++/image-20211230133857492.png" alt="image-20211230133857492"> </p>
</li>
<li><p>子类对象可以直接<strong>赋值</strong>给父类对象<img src="/2021/10/26/C++/image-20211230133903984.png" alt="image-20211230133903984"> </p>
</li>
<li><p>父类指针可以直接<strong>指向</strong>子类对象<img src="/2021/10/26/C++/image-20211230133910441.png" alt="image-20211230133910441"> </p>
</li>
<li><p>父类引用可以直接<strong>引用</strong>子类对象                                         </p>
</li>
</ul>
</blockquote>
<h3 id="虚父类-解决菱形继承二义性"><a href="#虚父类-解决菱形继承二义性" class="headerlink" title="虚父类(解决菱形继承二义性)"></a>虚父类(解决菱形继承二义性)</h3><p><img src="/2021/10/26/C++/image-20211230132531431.png" alt="image-20211230132531431"> </p>
<blockquote>
<p>两个成员都来自爷爷,子类本身中同名成员的二义性</p>
<p>子类和父类之间同名成员的访问二义性</p>
</blockquote>
<p>多重继承时,可能会保留同名成员(菱形继承),标识符重名了而且占用空间,我们其实只需要一个成员副本</p>
<p>虚父类： 当某个类的部分或全部父类是从另一个共同父类派生而来时，可以将这个<strong>共同父类设置成虚父类</strong>， 这时从不同路径继承来的同名数据成员在内存中只存放一个副本，同一个函数名也只有一个映射。</p>
<p><img src="/2021/10/26/C++/image-20211229183455469.png" alt="image-20211229183455469"> </p>
<blockquote>
<p>不是声明父类时声明的,是声明派生类时,指定继承方式时声明的</p>
<p>为了保证虚父类成员在派生类中只继承一次，应当在该父类的所有直接派生类中声明其为虚父类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person // 公共父类 Person,有name和age</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const string &amp;str, int a) // 构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        name = str;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected: // 保护成员</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Teacher : virtual public Person // 声明 Person 为公用继承的虚父类，新增了title</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Teacher(const string &amp;str, int a, const string &amp;tit) : Person(str, a)</span><br><span class="line">    &#123;</span><br><span class="line">        title = tit;</span><br><span class="line">    &#125; // 虚父类的构造函数带有参数，因此必须包含虚父类构造函数的直接调用</span><br><span class="line">protected:</span><br><span class="line">    string title; // 职称</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student : virtual public Person // 声明 Person 为公用继承的虚父类，新增了score</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Student(const string &amp;str, int a, float sco) // 构造函数</span><br><span class="line">        : Person(str, a), score(sco)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125; // 必须包含虚父类构造函数的直接调用</span><br><span class="line">protected:</span><br><span class="line">    float score; // 成绩</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Graduate : public Teacher, public Student // 多重继承</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Graduate(const string &amp;str, int a, const string &amp;tit, float sco, float w) : Person(str, a), Teacher(str, a, tit), Student(str, a, sco), wage(w) &#123;&#125;</span><br><span class="line">    // 必须包含虚父类构造函数的直接调用</span><br><span class="line">    void show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;title:&quot; &lt;&lt; title &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;wage:&quot; &lt;&lt; wage &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    float wage; // 工资</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graduate grad(&quot;Xi Jiajia&quot;, 24, &quot;assistant&quot;, 89.5, 1234.5);</span><br><span class="line">    grad.show();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在初始化 Graduate 类的对象时，只会通过 Graduate 的构造函数中的 Person(str,a) 来初始化从 Person 类继承的数据成员，Teacher(str,a,tit) 和 Student(str,a,sco) 中对 Person 构造函数的直接调用会被忽略。改成Teacher(“str”, a, tit), Student(“123”, a, sco)也行</p>
</blockquote>
<h3 id="继承作业"><a href="#继承作业" class="headerlink" title="继承作业"></a>继承作业</h3><p>13.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//设计一个名为 Point 的类，表示平面坐标下的一个点，这个类包括：</span><br><span class="line">//• 两个 double 型数据成员：x, y，分别表示横坐标和纵坐标</span><br><span class="line">//• 一个不带形参的构造函数，用于创建原点：(0,0)</span><br><span class="line">//• 一个带形参的构造函数：Point(double x, double y)</span><br><span class="line">//• 成员函数 getx()，返回横坐标</span><br><span class="line">//• 成员函数 gety()，返回纵坐标</span><br><span class="line">//• 成员函数 dist(const Point&amp; p)，返回当前点与给定点的距离</span><br><span class="line">//实现这个类，并在主函数中测试这个类：创建点 A(0,0) 和 B(4,5.6)，并输出它们之间的距离。</span><br><span class="line"></span><br><span class="line">//在 Point 类的基础上定义派生类 Point3D，表示三维空间的一个点，包括：</span><br><span class="line">//• 一个 double 型数据成员：z，表示 z­坐标</span><br><span class="line">//• 一个不带形参的构造函数，用于创建原点：(0,0,0)</span><br><span class="line">//• 一个带形参的构造函数：Point3D(double x, double y, double z)</span><br><span class="line">//• 成员函数 getz()，返回 z­坐标</span><br><span class="line">//• 成员函数 dist(const Point3D&amp; p)，返回当前点与给定点的距离</span><br><span class="line">//实现这个类，并在主函数中测试这个类：创建点 A(0,0,0) 和 B(4,5.6,7.8)，并输出它们之</span><br><span class="line">//间的距离。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Point()</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">        y = 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    Point(double x, double y)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">        this-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    double getx() const &#123; return x; &#125;; //之后常对象要调用父类中的getx,访问private中的x,所以设置为常函数</span><br><span class="line">    double gety() const &#123; return y; &#125;; //设置为常函数</span><br><span class="line">    double dist(const Point &amp;p) &#123; return sqrt((this-&gt;x - p.x) * (this-&gt;x - p.x) + (this-&gt;y - p.y) * (this-&gt;y - p.y)); &#125;</span><br><span class="line">    //形参是常对象，不能改变成员变量，也不能调用非const函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Point3D : public Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Point3D() : Point(0, 0) &#123; z = 0; &#125;</span><br><span class="line">    Point3D(double x, double y, double z) : Point(x, y) &#123; this-&gt;z = z; &#125;</span><br><span class="line">    double getz() const &#123; return z; &#125;; //设置为常函数</span><br><span class="line">    double dist(const Point3D &amp;p);     //屏蔽了父类的dist</span><br><span class="line">private:</span><br><span class="line">    double z;</span><br><span class="line">&#125;;</span><br><span class="line">double Point3D::dist(const Point3D &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    //不能访问父类的私有变量，只能通过公有函数访问</span><br><span class="line">    return sqrt((this-&gt;getx() - p.getx()) * (this-&gt;getx() - p.getx()) + (this-&gt;gety() - p.gety()) * (this-&gt;gety() - p.gety()) + (this-&gt;getz() - p.getz()) * (this-&gt;getz() - p.getz()));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Point3D A, B;</span><br><span class="line">    B = Point3D(4, 5.6, 7.8);</span><br><span class="line">    cout &lt;&lt; A.dist(B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八周多态"><a href="#第八周多态" class="headerlink" title="*第八周多态"></a>*第八周多态</h2><p>一种接口,多种方法</p>
<p><strong>重载多态，包含多态</strong>，参数多态(模板)，强制多态(老师也不太知道)</p>
<p>重载 : 在<strong>同一个作用域下,同名不同参</strong>的函数构成重载</p>
<p>按照类实现时机分为 : 编译时多态(静态多态,通过重载函数实现)和运行时多态(动态多态,通过虚函数实现)</p>
<p>绑定先跳过,直接看包含多态</p>
<p>先回顾一下二义性问题与类型兼容规则</p>
<blockquote>
<p> <img src="/2021/10/26/C++/image-20220310214949246.png" alt="image-20220310214949246"> </p>
<p>  <img src="/2021/10/26/C++/image-20211229182721160.png" alt="image-20211229182721160"> </p>
</blockquote>
<p>我们知道，用<strong>派生类对象替代父类的对象后，只能发挥父类的功能</strong>。比如父类中定义了成员函数 show，派生类中也有成员函数 show，则用派生类对象替代父类对象后，只能发挥父类的 show 功 能。但能否仍然发挥派生类的 show 功能呢？C++ 中的 虚函数 就是用来解决这个问题。</p>
<blockquote>
<p>定义了shape,有一个getarea,又定义了Rectangle和Circle,各自都有getarea,然后写了个area_cal(Shape *s),调用s-&gt;getarea().传入Rectangle r 的地址&amp;r后,面积是0(调用的是父类的getarea)</p>
<p>子类和父类之间的二义性问题,想要解决只需要 在父类shape的getarea前加一个virtual就行了</p>
<p><img src="/2021/10/26/C++/image-20211230133910441.png" alt="image-20211230133910441"> </p>
</blockquote>
<p>包含多态 : 函数需要父类参数时传子类对象,会调用<strong>子类对应的方法</strong></p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>运行时多态的基础(编译时不知道要调用哪个方法,运行时传入对象,就调用对应对象的方法)</p>
<h4 id="继承情况下的名字查找"><a href="#继承情况下的名字查找" class="headerlink" title="//继承情况下的名字查找"></a>//继承情况下的名字查找</h4><p><img src="/2021/10/26/C++/image-20211230140004446.png" alt="image-20211230140004446"> </p>
<blockquote>
<p>声明类型是shape,实际类型(分配的空间)是Rectangle型的对象</p>
</blockquote>
<p>假设调用p-&gt;mem()</p>
<ol>
<li>确定p的静态类型(声明类型)</li>
<li>在声明类型中查找mem,找不到就在父类中一直查找,还找不到则编译器报错</li>
<li>找到了就进行类型检查,确认调用是否合法</li>
<li>合法的话,则<ul>
<li>mem是虚函数,且通过引用或指针调用,则编译器在运行时根据对象的动态类型确定到底运行虚函数的哪个版本</li>
<li>不是虚函数或者通过对象直接调用(非指针及引用),则编译器产生正常函数调用</li>
</ul>
</li>
</ol>
<p>父类和子类同名函数,父类不加virtual是同名隐藏,加了virtual是覆盖(override/overwrite</p>
<p>在想用父类指针删除子类对象时,析构函数也要搞成虚析构函数,直接删除无所谓</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><img src="/2021/10/26/C++/image-20211230143947362.png" alt="image-20211230143947362" style="zoom: 67%;"> 

<p>抽象类不能实例化</p>
<h3 id="重载多态-看运算符重载"><a href="#重载多态-看运算符重载" class="headerlink" title="重载多态,看运算符重载"></a>重载多态,看运算符重载</h3><p>overload</p>
<p>同一作用域,同名不同参</p>
<p>运算符只针对基本数据类型，若要使得<strong>对象</strong>也能进行类似的运算，则需要通过运算符重载来实现。 </p>
<p><img src="/2021/10/26/C++/image-20211225225525502.png" alt="image-20211225225525502"> </p>
<p><img src="/2021/10/26/C++/image-20211225225758491.png" alt="image-20211225225758491">  </p>
<h4 id="成员函数法"><a href="#成员函数法" class="headerlink" title="成员函数法"></a>成员函数法</h4><p>• 特点： </p>
<p>(1) 可以自由访问本类对象的（私有）数据成员； </p>
<p>(2) 运算符重载为成员函数时，<strong>形参个数可以少一个</strong>； </p>
<p>(3) 若是双目运算，则左操作数就是目的对象本身，可使用 this 指针来调用； </p>
<p>(4) 若是单目运算，则目的对象就是操作数，不需要其它形参（注：后置 ++ 和后置 ‐‐ 除外）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational()</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">        y = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    Rational(int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">        this-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    Rational operator+(const Rational &amp;p); //重载加运算符,双目运算,左操作数是本对象,形参是右操作数</span><br><span class="line">    // 形参建议用“常引用”，既可以实现与变量的运算，也可以实现与常量的运算。</span><br><span class="line">    /*常引用可以绑定到常对象，普通引用不能绑定到常对象;</span><br><span class="line">    常引用也可以绑定到普通对象</span><br><span class="line">    但无论常引用所绑定的是常对象还是普通对象，都不能通过常引用来修改其所绑定的对象的数据。*/</span><br><span class="line"></span><br><span class="line">    void Display() &#123; cout &lt;&lt; x &lt;&lt; &quot;/&quot; &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rational Rational::operator+(const Rational &amp;p) // 重载加法运算</span><br><span class="line">&#123;</span><br><span class="line">    int newx = x * p.y + y * p.x;</span><br><span class="line">    int newy = y * p.y;</span><br><span class="line">    return Rational(newx, newy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Rational a(4, 5), b(7, 3), c;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a=&quot;;</span><br><span class="line">    a.Display();</span><br><span class="line">    cout &lt;&lt; &quot;b=&quot;;</span><br><span class="line">    b.Display();</span><br><span class="line"></span><br><span class="line">    c = a + b; // 使用重载运算符完成有理数加法</span><br><span class="line">    cout &lt;&lt; &quot;a+b=&quot;;</span><br><span class="line">    c.Display();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/26/C++/image-20211225232352881.png" alt="image-20211225232352881"> </p>
<blockquote>
<p>用伪参数来区别</p>
<p><img src="/2021/10/26/C++/image-20211225232858686.png" alt="image-20211225232858686"> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Clock // 时钟类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Clock(int H = 0, int M = 0, int S = 0);</span><br><span class="line">    void ShowTime() const;</span><br><span class="line">    Clock operator++();    // 前置单目运算符重载</span><br><span class="line">    Clock operator++(int); // 后置单目运算符重载</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock(int H, int M, int S) // 构造函数</span><br><span class="line">&#123;</span><br><span class="line">    if (0 &lt;= H &amp;&amp; H &lt; 24 &amp;&amp; 0 &lt;= M &amp;&amp; M &lt; 60 &amp;&amp; 0 &lt;= S &amp;&amp; S &lt; 60)</span><br><span class="line">    &#123;</span><br><span class="line">        hour = H;</span><br><span class="line">        minute = M;</span><br><span class="line">        second = S;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Time error!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Clock::ShowTime() const // 显示时间</span><br><span class="line">&#123;</span><br><span class="line">    cout.fill(&#x27;0&#x27;);</span><br><span class="line">    cout &lt;&lt; setw(2) &lt;&lt; hour &lt;&lt; &quot;:&quot;</span><br><span class="line">         &lt;&lt; setw(2) &lt;&lt; minute &lt;&lt; &quot;:&quot;</span><br><span class="line">         &lt;&lt; setw(2) &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock Clock::operator++() // 前置单目运算符重载</span><br><span class="line">&#123;</span><br><span class="line">    second++;</span><br><span class="line">    if (second &gt;= 60)</span><br><span class="line">    &#123;</span><br><span class="line">        second -= 60;</span><br><span class="line">        minute++;</span><br><span class="line">        if (minute &gt;= 60)</span><br><span class="line">        &#123;</span><br><span class="line">            minute -= 60;</span><br><span class="line">            hour = (++hour) % 24;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock Clock::operator++(int) // 后置单目运算符重载</span><br><span class="line">&#123;                            // 注意形参表中的整型参数</span><br><span class="line">    Clock old = *this;</span><br><span class="line">    ++(*this); // 调用前置++</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Clock myClock(23, 59, 59);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;First time output:&quot;;</span><br><span class="line">    myClock.ShowTime();</span><br><span class="line">    cout &lt;&lt; &quot;Show myClock++ : &quot;; // 后置++, 先参与运算, 然后自身加 1</span><br><span class="line">    (myClock++).ShowTime();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Show ++myClock : &quot;;</span><br><span class="line">    (++myClock).ShowTime(); // 前置++, 先自身加 1, 然后参与运算</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运算符 []、=、‐&gt;、() 必须以成员函数方式重载。</p>
</blockquote>
<h4 id="非成员函数方式-不想看了-lt-lt-和-gt-gt-必须用这个-涉及输入输出流"><a href="#非成员函数方式-不想看了-lt-lt-和-gt-gt-必须用这个-涉及输入输出流" class="headerlink" title="//非成员函数方式,不想看了(&lt;&lt;和&gt;&gt;必须用这个,涉及输入输出流)"></a>//非成员函数方式,不想看了(&lt;&lt;和&gt;&gt;必须用这个,涉及输入输出流)</h4><h4 id="左值和"><a href="#左值和" class="headerlink" title="左值和[]"></a>左值和[]</h4><p><img src="/2021/10/26/C++/image-20211225233258665.png" alt="image-20211225233258665"> </p>
<p><img src="/2021/10/26/C++/image-20211225233403930.png" alt="image-20211225233403930"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational()</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">        y = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    Rational(int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">        this-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    void display() &#123; cout &lt;&lt; x &lt;&lt; &quot;/&quot; &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">    int &amp;operator[](int idx); //返回引用类型</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int &amp;Rational::operator[](int idx) // 重载 []，返回的是引用</span><br><span class="line">&#123;</span><br><span class="line">    if (idx == 0)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Rational a(4, 5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a=&quot;;</span><br><span class="line">    a.display();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a[0] = 3;</span><br><span class="line">    a[1] = 2; // 可以用 [] 进行赋值运算</span><br><span class="line">    cout &lt;&lt; &quot;a=&quot;;</span><br><span class="line">    a.display();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动类型转换-对象与基本数据类型-不想看"><a href="#自动类型转换-对象与基本数据类型-不想看" class="headerlink" title="自动类型转换(对象与基本数据类型),不想看"></a>自动类型转换(对象与基本数据类型),不想看</h4><h2 id="第九周I-O流"><a href="#第九周I-O流" class="headerlink" title="//第九周I/O流"></a>//第九周I/O流</h2><p>总览、普通流（cin，cout）、文件流（文件读写）、字符串流</p>
<h3 id="I-O流总览"><a href="#I-O流总览" class="headerlink" title="I/O流总览"></a>I/O流总览</h3><img src="/2021/10/26/C++/image-20211026140341738.png" alt="image-20211026140341738" style="zoom: 67%;"> 

<blockquote>
<p>不是类型安全</p>
<p>不能自定义</p>
</blockquote>
<img src="/2021/10/26/C++/image-20211026140948113.png" alt="image-20211026140948113" style="zoom:67%;"> 

<h3 id="一表一图-四头九类"><a href="#一表一图-四头九类" class="headerlink" title="一表一图,四头九类"></a>一表一图,四头九类</h3><p><img src="/2021/10/26/C++/image-20211026141031296.png" alt="image-20211026141031296"> </p>
<p><img src="/2021/10/26/C++/image-20211026141110864.png" alt="image-20211026141110864"> </p>
<p><img src="/2021/10/26/C++/image-20211026141222256.png" alt="image-20211026141222256"> </p>
<h3 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h3><p><img src="/2021/10/26/C++/image-20211026141609926.png" alt="image-20211026141609926"> </p>
<p><img src="/2021/10/26/C++/image-20211026141653360.png" alt="image-20211026141653360"> </p>
<blockquote>
<p>cerr和cout 的区别就是没有缓冲区,一旦有消息就直接传了</p>
<p>cout是先开一个缓冲区,用的时候再送出去</p>
<p>假如递归时栈空间溢出了,就没有位置给缓冲区了,用cout 的话不会报错</p>
<p>clog就是缓冲区满了就输出</p>
</blockquote>
<p>下面这一张不考,计算机了解</p>
<p><img src="/2021/10/26/C++/image-20211026141930910.png" alt="image-20211026141930910"> </p>
<blockquote>
<p>I/O很慢,一个H一个e,l,l,o …很慢</p>
<p>全缓冲,满了再送</p>
<p>行缓冲,收到了换行符再送</p>
<p>无缓冲,cerr</p>
<p>endl就相当于\n加上flush</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211026142727240.png" alt="image-20211026142727240"> </p>
<blockquote>
<p>iostream对运算符进行了重载</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211026143132511.png" alt="image-20211026143132511"> </p>
<blockquote>
<p>信号量传递,杀死进程</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211230163522913.png" alt="image-20211230163522913"> </p>
<p><img src="/2021/10/26/C++/image-20211230163555763.png" alt="image-20211230163555763"> </p>
<p><img src="/2021/10/26/C++/image-20211026143821550.png" alt="image-20211026143821550"> </p>
<p><img src="/2021/10/26/C++/image-20211026143654444.png" alt="image-20211026143654444"> </p>
<p><img src="/2021/10/26/C++/image-20211026144431086.png" alt="image-20211026144431086"> </p>
<p><img src="/2021/10/26/C++/image-20211026144433862.png" alt="image-20211026144433862"> </p>
<p><img src="/2021/10/26/C++/image-20211026144242305.png" alt="image-20211026144242305"> </p>
<blockquote>
<p>静态成员变量可以通过域作用限定符来使用</p>
</blockquote>
<p>解决输入输出也解决格式控制</p>
<p><img src="/2021/10/26/C++/image-20211026144459112.png" alt="image-20211026144459112"> </p>
<p><img src="/2021/10/26/C++/image-20211026144652423.png" alt="image-20211026144652423"> </p>
<blockquote>
<p>iosbase和ios都可以访问到静态变量</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211026144746378.png" alt="image-20211026144746378"> </p>
<p><img src="/2021/10/26/C++/image-20211026145320837.png" alt="image-20211026145320837"> </p>
<p><img src="/2021/10/26/C++/image-20211026145800654.png" alt="image-20211026145800654"> </p>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p><img src="/2021/10/26/C++/image-20211026151227636.png" alt="image-20211026151227636"> </p>
<p><img src="/2021/10/26/C++/image-20211026151708033.png" alt="image-20211026151708033"> </p>
<p><img src="/2021/10/26/C++/image-20211026152122833.png" alt="image-20211026152122833"></p>
<h3 id="文件流例子"><a href="#文件流例子" class="headerlink" title="文件流例子"></a>文件流例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ifstream ifstrm; //创建文件流对象,只读</span><br><span class="line">    ofstream ofstrm; //只写</span><br><span class="line">    fstream fstrm;   //读写</span><br><span class="line"></span><br><span class="line">    // 写文本文件</span><br><span class="line">    ofstrm.open(&quot;fout.txt&quot;); // 文本文件, 缺省模式为 in,将文件流对象 ofstrm 绑定到文件 four.txt</span><br><span class="line">    /*</span><br><span class="line">    (1) 将文件流对象关联到其它文件时，须先关闭已绑定的文件</span><br><span class="line">    (2) 文件流对象被释放时，close 会被自动调用</span><br><span class="line">    */</span><br><span class="line">    ofstrm &lt;&lt; &quot;This is a test for writing file&quot; &lt;&lt; endl;</span><br><span class="line">    ofstrm.close();</span><br><span class="line"></span><br><span class="line">    char str1[20], str2[20];</span><br><span class="line">    ifstrm.open(&quot;fout.txt&quot;); // 缺省模式：out, 文本文件</span><br><span class="line">    ifstrm &gt;&gt; str1;          // 缺省以空格为结束符</span><br><span class="line"></span><br><span class="line">    ifstrm.getline(str2, 13); // 获取接下来的 13 个字符</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ifstrm.close();</span><br><span class="line"></span><br><span class="line">    // 追加</span><br><span class="line">    fstrm.open(&quot;fout.txt&quot;, ios::out | ios::app);</span><br><span class="line">    fstrm &lt;&lt; &quot;This is appended text&quot; &lt;&lt; endl;</span><br><span class="line">    fstrm.close();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>希望一个函数或者类，其他场景都能用</p>
<p><img src="/2021/10/26/C++/image-20211230183553360.png" alt="image-20211230183553360"> </p>
<p><img src="/2021/10/26/C++/image-20211230183632098.png" alt="image-20211230183632098"> </p>
<blockquote>
<p>不可能对所有类型都写一遍</p>
</blockquote>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p><img src="/2021/10/26/C++/image-20211230183826501.png" alt="image-20211230183826501"> ‘</p>
<blockquote>
<p><img src="/2021/10/26/C++/image-20211230183918139.png" alt="image-20211230183918139"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T, class T1&gt;</span><br><span class="line">T min(T a[], T1 n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    T minv = a[0];</span><br><span class="line">    for (i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (minv &gt; a[i])</span><br><span class="line">            minv = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return minv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1, 3, 9, 2, 7, 6, 4, 5, 2&#125;;</span><br><span class="line">    double b[] = &#123;1.2, -3.4, 6.8, 9, 8&#125;;</span><br><span class="line">    cout &lt;&lt; &quot;a数组的最小值为:&quot; &lt;&lt; min(a, 9) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b数组的最小值为:&quot; &lt;&lt; min(b, 4) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211230184717939.png" alt="image-20211230184717939"> </p>
<blockquote>
<p>•函数模板只是说明，不能直接执行，<strong>需要实例化</strong>为模板函数后才能执行</p>
<p>•在说明了一个函数模板后，当编译系统发现有一个对应的函数调用时，将根据实参中的类型来确认是否匹配函数模板中对应的形参，然后生成一个重载函数。该重载函数的定义体与函数模板的函数定义体相同，它称之为<strong>模板函数</strong></p>
</blockquote>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p><img src="/2021/10/26/C++/image-20211230184905842.png" alt="image-20211230184905842"> </p>
<p><img src="/2021/10/26/C++/image-20211230185007695.png" alt="image-20211230185007695"> </p>
<blockquote>
<p>类模板的成员函数必须是函数模板</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211230185513079.png" alt="image-20211230185513079"> </p>
<p><img src="/2021/10/26/C++/image-20211230185525098.png" alt="image-20211230185525098"> </p>
<p>继承的时候要指明,不然无法分配空间</p>
<p>普通类继承模板类class son : public Base&lt;int&gt;{};</p>
<h2 id="STL标准模板库-模板应用"><a href="#STL标准模板库-模板应用" class="headerlink" title="STL标准模板库(模板应用)"></a>STL标准模板库(模板应用)</h2><p><strong>容器</strong>,STL里面叫做vector,向量类,FILO</p>
<p>list,双向进出</p>
<p><strong>迭代器</strong></p>
<p><strong>算法</strong>,find,sort,insert</p>
<img src="/2021/10/26/C++/image-20211230192139151.png" alt="image-20211230192139151" style="zoom:80%;"> 

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>希望遇到错误不中断,恢复运行</p>
<p>问题代码 传递 异常类对象 到处理机制</p>
<h3 id="异常处理实现"><a href="#异常处理实现" class="headerlink" title="异常处理实现"></a>异常处理实现</h3><p>异常检测和异常处理</p>
<p><img src="/2021/10/26/C++/image-20211230195110647.png" alt="image-20211230195110647"> </p>
<p><img src="/2021/10/26/C++/image-20211230201328284.png" alt="image-20211230201328284"> </p>
<p><img src="/2021/10/26/C++/image-20211230195336447.png" alt="image-20211230195336447"> </p>
<blockquote>
<p> 分配空间,可能空间不够,放进try里</p>
<p>throw丢出来的异常对象和catch要求的对象匹配的话就处理异常</p>
</blockquote>
<p><img src="/2021/10/26/C++/image-20211230195821764.png" alt="image-20211230195821764"> </p>
<blockquote>
<p>没有str类型的catch,丢出str时直接中断了</p>
<p>所以catch和throw一定要匹配,或者像下面这样</p>
<p><img src="/2021/10/26/C++/image-20211230200612479.png" alt="image-20211230200612479"> </p>
</blockquote>
<h2 id="UML-看一下"><a href="#UML-看一下" class="headerlink" title="UML(看一下)"></a>UML(看一下)</h2> <img src="/2021/10/26/C++/image-20211225201332485.png" alt="image-20211225201332485" style="zoom:67%;">

<p>UML图主要是用来显示系统中的<strong>类、接口以及它们之间的静态结构和关系的一种静态模型。</strong></p>
<p>泛化 : 就是继承,表示一般与特殊的关系,三角箭头实线子类指向父类</p>
<p>实现</p>
<p>关联 : 是一种拥有的关系，它使一个类知道另一个类的属性和方法</p>
<p>聚合 : 是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。是关联关系的一种，是强的关联关系,在语法上无法区分，必须考察具体的逻辑关系。</p>
<p>组合 : 是整体与部分的关系</p>
<p>依赖</p>
<p><img src="/2021/10/26/C++/image-20220310224439745.png" alt="image-20220310224439745"> <img src="/2021/10/26/C++/image-20220310224447170.png" alt="image-20220310224447170"> <img src="/2021/10/26/C++/image-20220310224542678.png" alt="image-20220310224542678">     <img src="/2021/10/26/C++/image-20220310224612369.png" alt="image-20220310224612369"> </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/25/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.25-IDA%E5%8A%A8%E8%B0%83/" rel="next" title="10.25-IDA动调">
                <i class="fa fa-chevron-left"></i> 10.25-IDA动调
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/26/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/10.26-Rex%E8%AE%BA%E6%96%87/" rel="prev" title="10.26-Rex论文">
                10.26-Rex论文 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">58</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%88%9D%E6%8E%A2"><span class="nav-number">1.</span> <span class="nav-text">C++初探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">*C++内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">简单的程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%88int-short-long-float%E2%80%A6%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本类型（int short long float…）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%88const-volatile-restrict%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">&#x2F;&#x2F;类型限定符（const volatile restrict）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%AB%E5%90%8D%EF%BC%88typedef-int-abcname%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">别名（typedef int abcname）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89"><span class="nav-number">1.3.4.</span> <span class="nav-text">&#x2F;&#x2F;枚举（enum）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9A-%C2%AD"><span class="nav-number">1.4.1.</span> <span class="nav-text">(1) 自动转换&#x2F;隐式转换： ­</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">(2)强制转换&#x2F;显式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="nav-number">1.4.3.</span> <span class="nav-text">转换规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.</span> <span class="nav-text">语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.5.1.</span> <span class="nav-text">&#x2F;&#x2F;逗号运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%AD%97%E8%8A%82%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88sizeof%EF%BC%89"><span class="nav-number">1.5.2.</span> <span class="nav-text">求字节数运算符（sizeof）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">&#x2F;&#x2F;数学函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88cin-cout%EF%BC%89"><span class="nav-number">1.5.4.</span> <span class="nav-text">输入输出（cin cout）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">&#x2F;&#x2F;时间函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">1.5.6.</span> <span class="nav-text">条件判断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-%E5%BC%95%E7%94%A8-%E5%86%85%E8%81%94-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8EC%E4%B8%8D%E5%90%8C"><span class="nav-number">2.</span> <span class="nav-text">函数(引用,内联,命名空间与C不同)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92-C%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F-%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.</span> <span class="nav-text">*参数传递(引用传递&#x2F;C的指针变量 对比)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">引用做参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.1.2.</span> <span class="nav-text">引用做返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-C%E9%87%8C%E6%B2%A1%E6%9C%89"><span class="nav-number">2.2.</span> <span class="nav-text">内联函数(C里没有)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8Cextern"><span class="nav-number">2.3.</span> <span class="nav-text">?头文件和extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-extern"><span class="nav-number">2.4.</span> <span class="nav-text">?全局变量和局部变量(extern)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.5.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%8C%BA%E5%88%86%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.</span> <span class="nav-text">*作用域解析运算符 :: (区分空间中的局部变量和全局变量)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-%E5%8C%BA%E5%88%86%E7%A9%BA%E9%97%B4"><span class="nav-number">2.7.</span> <span class="nav-text">*命名空间(区分空间)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F-%E9%9D%99%E6%80%81-amp-%E5%8A%A8%E6%80%81"><span class="nav-number">2.8.</span> <span class="nav-text">生存期 (静态&amp;动态)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">2.9.</span> <span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%B8%A6%E7%BC%BA%E7%9C%81%E5%80%BC"><span class="nav-number">2.10.</span> <span class="nav-text">&#x2F;&#x2F;形参带缺省值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%84%E7%90%86%E4%B8%8E%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.11.</span> <span class="nav-text">&#x2F;&#x2F;预编译处理与多文件结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">一维数组初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">二维数组初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">*数组做函数参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">4.</span> <span class="nav-text">指针与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-A%E4%B8%8EA-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">指针与二维数组(A与A[0] 的区别)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-new-delete"><span class="nav-number">4.2.</span> <span class="nav-text">&#x2F;&#x2F;动态数组(new&#x2F;delete)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">*面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">5.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-number">5.2.</span> <span class="nav-text">对象创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.3.</span> <span class="nav-text">构造函数(对象初始化)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%B0%86%E5%B7%B2%E7%BB%8F%E6%9C%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%A4%8D%E5%88%B6%E7%BB%99%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.3.1.</span> <span class="nav-text">&#x2F;&#x2F;复制构造函数(将已经有的对象值复制给其他对象)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%B4%9F%E8%B4%A3%E5%AF%B9%E8%B1%A1%E9%87%8A%E6%94%BE%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B8%85%E7%90%86%E5%B7%A5%E4%BD%9C"><span class="nav-number">5.4.</span> <span class="nav-text">析构函数(负责对象释放时的一些清理工作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11%E4%BD%9C%E4%B8%9A"><span class="nav-number">5.5.</span> <span class="nav-text">面向对象1作业</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6"><span class="nav-number">6.</span> <span class="nav-text">*面向对象进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%B1%BB-%E8%A6%81%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%B5%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.1.</span> <span class="nav-text">组合类(要有初始化列表,初始化内嵌对象)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">6.2.</span> <span class="nav-text">静态成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">静态成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%E4%BD%9C%E4%B8%9A"><span class="nav-number">6.4.</span> <span class="nav-text">面向对象2作业</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98"><span class="nav-number">7.</span> <span class="nav-text">*面向对象提高</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">7.1.</span> <span class="nav-text">const关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.2.</span> <span class="nav-text">const对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class%E5%92%8Cstruct%E5%8C%BA%E5%88%AB"><span class="nav-number">7.3.</span> <span class="nav-text">&#x2F;&#x2F;class和struct区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">7.4.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E7%B1%BB-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E2%80%A6%E8%AF%BE%E4%B8%8A%E6%B2%A1%E8%AE%B2"><span class="nav-number">7.5.</span> <span class="nav-text">向量类,字符串类…课上没讲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%94%A8cin-gt-gt-%E3%80%81cout-lt-lt"><span class="nav-number">7.5.2.</span> <span class="nav-text">输入输出用cin&gt;&gt;、cout&lt;&lt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">7.5.3.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">7.5.4.</span> <span class="nav-text">和数组字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.5.</span> <span class="nav-text">常用成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13%E4%BD%9C%E4%B8%9A"><span class="nav-number">7.6.</span> <span class="nav-text">面向对象3作业</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E5%91%A8%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F"><span class="nav-number">8.</span> <span class="nav-text">*第七周继承与派生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%B4%BE%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.1.</span> <span class="nav-text">派生类的构造函数(派生对象初始化)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%A0%87%E8%AF%86%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="nav-number">8.2.</span> <span class="nav-text">派生类成员的标识与访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99-%E5%AD%90%E7%B1%BBis-a-%E7%88%B6%E7%B1%BB"><span class="nav-number">8.4.</span> <span class="nav-text">类型兼容规则(子类is a 父类)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%88%B6%E7%B1%BB-%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="nav-number">8.5.</span> <span class="nav-text">虚父类(解决菱形继承二义性)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%9C%E4%B8%9A"><span class="nav-number">8.6.</span> <span class="nav-text">继承作业</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E5%91%A8%E5%A4%9A%E6%80%81"><span class="nav-number">9.</span> <span class="nav-text">*第八周多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-number">9.1.1.</span> <span class="nav-text">&#x2F;&#x2F;继承情况下的名字查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">9.2.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%A4%9A%E6%80%81-%E7%9C%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">9.3.</span> <span class="nav-text">重载多态,看运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B3%95"><span class="nav-number">9.3.1.</span> <span class="nav-text">成员函数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F-%E4%B8%8D%E6%83%B3%E7%9C%8B%E4%BA%86-lt-lt-%E5%92%8C-gt-gt-%E5%BF%85%E9%A1%BB%E7%94%A8%E8%BF%99%E4%B8%AA-%E6%B6%89%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">9.3.2.</span> <span class="nav-text">&#x2F;&#x2F;非成员函数方式,不想看了(&lt;&lt;和&gt;&gt;必须用这个,涉及输入输出流)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C"><span class="nav-number">9.3.3.</span> <span class="nav-text">左值和[]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8D%E6%83%B3%E7%9C%8B"><span class="nav-number">9.3.4.</span> <span class="nav-text">自动类型转换(对象与基本数据类型),不想看</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E5%91%A8I-O%E6%B5%81"><span class="nav-number">10.</span> <span class="nav-text">&#x2F;&#x2F;第九周I&#x2F;O流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%B5%81%E6%80%BB%E8%A7%88"><span class="nav-number">10.1.</span> <span class="nav-text">I&#x2F;O流总览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%A1%A8%E4%B8%80%E5%9B%BE-%E5%9B%9B%E5%A4%B4%E4%B9%9D%E7%B1%BB"><span class="nav-number">10.2.</span> <span class="nav-text">一表一图,四头九类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%B5%81"><span class="nav-number">10.3.</span> <span class="nav-text">普通流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">10.4.</span> <span class="nav-text">文件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E4%BE%8B%E5%AD%90"><span class="nav-number">10.5.</span> <span class="nav-text">文件流例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">11.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">11.1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">11.2.</span> <span class="nav-text">类模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-%E6%A8%A1%E6%9D%BF%E5%BA%94%E7%94%A8"><span class="nav-number">12.</span> <span class="nav-text">STL标准模板库(模板应用)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">13.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">13.1.</span> <span class="nav-text">异常处理实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UML-%E7%9C%8B%E4%B8%80%E4%B8%8B"><span class="nav-number">14.</span> <span class="nav-text">UML(看一下)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzlg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
