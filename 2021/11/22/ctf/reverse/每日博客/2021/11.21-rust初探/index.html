<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="re,game,rust," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="n1ctf的签到题叫babyrust，学一下">
<meta property="og:type" content="article">
<meta property="og:title" content="11.22-rust&#x2F;n1ctf复盘">
<meta property="og:url" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="hzlg&#39;s blog">
<meta property="og:description" content="n1ctf的签到题叫babyrust，学一下">
<meta property="og:locale">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211121222409943.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211121230225779.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122092614882.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122093655775.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122094702262.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122095735629.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122150839621.png">
<meta property="og:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211123100517468.png">
<meta property="article:published_time" content="2021-11-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-21T16:00:00.000Z">
<meta property="article:author" content="hzlg">
<meta property="article:tag" content="re">
<meta property="article:tag" content="game">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211121222409943.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hzlg.github.ioz/2021/11/22/ctf/reverse/每日博客/2021/11.21-rust初探/"/>





  <title>11.22-rust/n1ctf复盘 | hzlg's blog</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzlg's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记、日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzlg.github.ioz/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzlg's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">11.22-rust/n1ctf复盘</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-22T00:00:00+08:00">
                2021-11-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-22T00:00:00+08:00">
                2021-11-22
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>n1ctf的签到题叫babyrust，学一下</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://www.runoob.com/rust/rust-tutorial.html">菜鸟教程yyds,包含了下面的教程</a></p>
<h1 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="rust环境配置"><a href="#rust环境配置" class="headerlink" title="rust环境配置"></a><a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/tools/install">rust环境配置</a></h3><p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211121222409943.png" alt="image-20211121222409943"> </p>
<blockquote>
<p>去看菜鸟教程，教你选什么选项</p>
</blockquote>
<h3 id="hellorust"><a href="#hellorust" class="headerlink" title="hellorust"></a><a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/learn/get-started">hellorust</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello-rust</span><br><span class="line">cargo run</span><br><span class="line">#添加依赖</span><br><span class="line">#在 Cargo.toml 文件中添加:</span><br><span class="line">#[dependencies]</span><br><span class="line">#ferris-says = &quot;0.2&quot; </span><br></pre></td></tr></table></figure>

<h3 id="rust换源"><a href="#rust换源" class="headerlink" title="rust换源"></a><a target="_blank" rel="noopener" href="https://blog.bossma.cn/rust/rust-srolves-the-problem-of-slow-download/">rust换源</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p>#使用该依赖库</p>
<p>打开 <code>main.rs</code>,</p>
<p>添加:use ferris_says::say;(类似#include?)</p>
<p>小程序:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use ferris_says::say; // from the previous step</span><br><span class="line">use std::io::&#123;stdout, BufWriter&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let stdout = stdout();</span><br><span class="line">    let message = String::from(&quot;Hello fellow Rustaceans!&quot;);</span><br><span class="line">    let width = message.chars().count();</span><br><span class="line"></span><br><span class="line">    let mut writer = BufWriter::new(stdout.lock());</span><br><span class="line">    say(message.as_bytes(), width, &amp;mut writer).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211121230225779.png" alt="image-20211121230225779"> </p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="输出到命令行"><a href="#输出到命令行" class="headerlink" title="输出到命令行"></a>输出到命令行</h3><h4 id="不可变变量-直接let"><a href="#不可变变量-直接let" class="headerlink" title="不可变变量 :直接let"></a>不可变变量 :直接let</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 12; </span><br><span class="line"></span><br><span class="line">//在这句声明语句之后，以下三行代码都是被禁止的：</span><br><span class="line"></span><br><span class="line">// a = &quot;abc&quot;; 当声明 a 是 123 以后，a 就被确定为整型数字，不能把字符串类型的值赋给它。</span><br><span class="line"></span><br><span class="line">// a = 4.56;  自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换。</span><br><span class="line"></span><br><span class="line">// a = 456;   a 不是个可变变量,a是不可变变量</span><br></pre></td></tr></table></figure>

<h4 id="可变变量：mut"><a href="#可变变量：mut" class="headerlink" title="可变变量：mut"></a>可变变量：mut</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使变量变得&quot;可变&quot;（mutable）只需一个 mut 关键字。</span><br><span class="line"></span><br><span class="line">// let mut a = 123;</span><br><span class="line"></span><br><span class="line">// a = 456;</span><br></pre></td></tr></table></figure>

<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符{}"></a>占位符{}</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println!(&quot;a is &#123;&#125;&quot;, a); //&#123;&#125;作为占位符</span><br><span class="line"></span><br><span class="line">println!(&quot;a is &#123;0&#125;, a again is &#123;0&#125;&quot;, a); //将可变参数当作数组</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#123;&#125;&#125;&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="重新绑定"><a href="#重新绑定" class="headerlink" title="重新绑定"></a>重新绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 变量与常量的区别</span><br><span class="line"></span><br><span class="line">// 变量能够重新绑定:</span><br><span class="line"></span><br><span class="line">let a = 123;</span><br><span class="line"></span><br><span class="line">let a = 456;</span><br><span class="line"></span><br><span class="line">// 但是如果 a 是常量就不合法：</span><br><span class="line"></span><br><span class="line">// const a: i32 = 123;</span><br><span class="line"></span><br><span class="line">// let a = 456;</span><br><span class="line"></span><br><span class="line">// 重影和可变变量赋值不一样</span><br></pre></td></tr></table></figure>

<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//有些情况下声明类型更加方便：</span><br><span class="line"></span><br><span class="line">// let a: u64 = 123;</span><br><span class="line"></span><br><span class="line">// 这里声明了 a 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。</span><br></pre></td></tr></table></figure>

<h5 id="整型-i-u"><a href="#整型-i-u" class="headerlink" title="整型:i/u"></a>整型:i/u</h5><h5 id="浮点型-f32-f64"><a href="#浮点型-f32-f64" class="headerlink" title="浮点型: f32/f64"></a>浮点型: f32/f64</h5><h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><h5 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h5><h5 id="复合型"><a href="#复合型" class="headerlink" title="复合型:"></a>复合型:</h5><h6 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h6><p>可以包含不同类型的数据()</p>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>同类型数据[]</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算:"></a>运算:</h4><p>  // 不支持++和–</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</p>
<p>Rust不在乎您在何处定义函数，只需在某个地方定义它们即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    another_function(5, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn another_function(x: i32, y: i32) &#123;</span><br><span class="line">    println!(&quot;x 的值为 : &#123;&#125;&quot;, x);</span><br><span class="line">    println!(&quot;y 的值为 : &#123;&#125;&quot;, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line"></span><br><span class="line">    let y = &#123;</span><br><span class="line">        let x = 3;</span><br><span class="line">        x + 1                    //没有&#x27;;&#x27;号!!!,是表达式不是语句</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;x 的值为 : &#123;&#125;&quot;, x);</span><br><span class="line">    println!(&quot;y 的值为 : &#123;&#125;&quot;, y);</span><br><span class="line">&#125;</span><br><span class="line">// x = 5,y = 4</span><br></pre></td></tr></table></figure>

<p>这段程序中包含了一个表达式块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x = 3;</span><br><span class="line">    x + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而且在块中可以使用函数语句，最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做<strong>函数体表达式</strong>。</p>
<p>注意：<strong>x + 1</strong> 之后没有分号，否则它将变成一条语句！</p>
<p>这种表达式块是一个合法的函数体。而且在 Rust 中，函数定义可以嵌套：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  fn five() -&gt; i32 &#123;</span><br><span class="line">    5</span><br><span class="line">  &#125;</span><br><span class="line">  println!(&quot;five() 的值为: &#123;&#125;&quot;, five());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回值-gt-指定"><a href="#返回值-gt-指定" class="headerlink" title="返回值: -&gt;指定"></a>返回值: -&gt;指定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn add(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>函数体表达式并不能等同于函数体，它不能使用 <strong>return</strong> <strong>关键字。</strong></p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = 12;</span><br><span class="line">    let b;</span><br><span class="line">    if a &gt; 0 &#123;</span><br><span class="line">        b = 1;</span><br><span class="line">    &#125;  </span><br><span class="line">    else if a &lt; 0 &#123;</span><br><span class="line">        b = -1;</span><br><span class="line">    &#125;  </span><br><span class="line">    else &#123;</span><br><span class="line">        b = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;b is &#123;&#125;&quot;, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut number = 1;</span><br><span class="line">    while number != 4 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, number);</span><br><span class="line">        number += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;EXIT&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line">    for i in a.iter() &#123;                   //a.iter() 代表 a 的迭代器（iterator）</span><br><span class="line">        println!(&quot;值为 : &#123;&#125;&quot;, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let a = [10, 20, 30, 40, 50];</span><br><span class="line">    for i in 0..5 &#123;</span><br><span class="line">        println!(&quot;a[&#123;&#125;] = &#123;&#125;&quot;, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = [&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;];</span><br><span class="line">    let mut i = 0;</span><br><span class="line">    let location = loop &#123;</span><br><span class="line">        let ch = s[i];</span><br><span class="line">        if ch == &#x27;O&#x27; &#123;</span><br><span class="line">            break i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += 1;</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot; \&#x27;O\&#x27; 的索引为 &#123;&#125;&quot;, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内存管理规则-所有权"><a href="#内存管理规则-所有权" class="headerlink" title="内存管理规则(所有权)"></a>内存管理规则(所有权)</h3><h4 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h4><p>所有权有以下三条规则：</p>
<ul>
<li>Rust 中的每个值都有一个变量，称为其所有者。</li>
<li>一次只能有一个所有者。</li>
<li>当所有者不在程序运行范围时，该值将被删除。</li>
</ul>
<h4 id="内存和分配"><a href="#内存和分配" class="headerlink" title="内存和分配"></a>内存和分配</h4><p>如果我们定义了一个变量并给它赋予一个值，这个变量的值存在于内存中。这种情况很普遍。但如果我们需要储存的<strong>数据长度不确定</strong>（比如用户输入的一串字符串），我们就无法在定义时明确数据长度，也就无法在编译阶段令程序分配固定长度的内存空间供数据储存使用。（有人说分配尽可能大的空间可以解决问题，但这个方法很不文明）。这就需要提供一种在<strong>程序运行时程序自己申请使用内存的机制——堆</strong>。本章所讲的所有**”内存资源”都指的是堆所占用的内存空间**。</p>
<p>有分配就有释放，程序不能一直占用某个内存资源。因此决定资源是否浪费的关键因素就是资源有没有<strong>及时的释放</strong>。</p>
<p>Rust 在变量范围结束的时候，Rust 编译器<strong>自动添加了调用释放资源函数的步骤</strong>。</p>
<h3 id="变量与数据交互的方式-移动-克隆"><a href="#变量与数据交互的方式-移动-克隆" class="headerlink" title="变量与数据交互的方式(移动/克隆)"></a>变量与数据交互的方式(移动/克隆)</h3><p>变量与数据交互方式主要有移动（Move）和克隆（Clone）两种：</p>
<h4 id="移动-栈复制-堆失效"><a href="#移动-栈复制-堆失效" class="headerlink" title="移动(栈复制/堆失效)"></a>移动(栈复制/堆失效)</h4><p>多个变量可以在 Rust 中以不同的方式与相同的数据交互：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">let y = x;</span><br></pre></td></tr></table></figure>

<p>这个程序将值 5 绑定到变量 x，然后将 x 的值复制并赋值给变量 y。现在<strong>栈</strong>中将有两个值 5。此情况中的数据是”基本数据”类型的数据，不需要存储到堆中，仅在<strong>栈中的数据的”移动”方式是直接复制</strong>，这不会花费更长的时间或更多的存储空间。”基本数据”类型有这些：</p>
<ul>
<li>所有整数类型，例如 i32 、 u32 、 i64 等。</li>
<li>布尔类型 bool，值为 true 或 false 。</li>
<li>所有浮点类型，f32 和 f64。</li>
<li>字符类型 char。</li>
<li>仅包含以上类型数据的元组（Tuples）。</li>
</ul>
<p>但如果发生交互的数据在堆中就是另外一种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1;</span><br></pre></td></tr></table></figure>

<p>第一步产生一个 String 对象，值为 “hello”。其中 “hello” 可以认为是类似于长度不确定的数据，需要在<strong>堆中存储</strong>。</p>
<p>两个 String 对象在栈中，每个 String 对象都<strong>有一个指针指向堆中</strong>的 “hello” 字符串。</p>
<p>在给 s2 赋值时，<strong>只有栈中的数据被复制了</strong>，堆中的字符串依然还是原来的字符串。</p>
<p>前面我们说过，当变量超出范围时，Rust 自动调用释放资源函数并清理该变量的堆内存。但是 s1 和 s2 都被释放的话堆区中的 “hello” 被释放两次，这是不被系统允许的。</p>
<p>为了确保安全，在给 s2 赋值时 s1 已经无效了。没错，在把 s1 的值赋给 s2 以后 s1 将不可以再被使用。下面这段程序是错的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1; </span><br><span class="line">println!(&quot;&#123;&#125;, world!&quot;, s1); // 错误！s1 已经失效</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122092614882.png" alt="image-20211122092614882"> </p>
<h4 id="克隆-堆复制"><a href="#克隆-堆复制" class="headerlink" title="克隆(堆复制)"></a>克隆(堆复制)</h4><p>Rust会尽可能地降低程序的运行成本，所以默认情况下，长度较大的数据存放在堆中，且采用移动的方式进行数据交互。但如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆。</p>
<p>fn main() {<br>  let s1 = String::from(“hello”);<br>  let s2 = s1.clone();<br>  println!(“s1 = {}, s2 = {}”, s1, s2);<br>}</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = hello, s2 = hello</span><br></pre></td></tr></table></figure>

<p>这里是真的将堆中的 “hello” 复制了一份，所以 s1 和 s2 都分别绑定了一个值，释放的时候也会被当作两个资源。</p>
<p>当然，克隆仅在需要复制的情况下使用，毕竟复制数据会花费更多的时间。</p>
<h4 id="函数参数的所有权机制-传参等于移动"><a href="#函数参数的所有权机制-传参等于移动" class="headerlink" title="函数参数的所有权机制(传参等于移动)"></a>函数参数的所有权机制(传参等于移动)</h4><p>对于变量来说这是最复杂的情况了。</p>
<p>如果将一个变量当作函数的参数传给其他函数，怎样安全的处理所有权呢？</p>
<p>下面这段程序描述了这种情况下所有权机制的运行原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line">    // s 被声明有效</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);</span><br><span class="line">    // s 的值被当作参数传入函数</span><br><span class="line">    // 所以可以当作 s 已经被移动，从这里开始已经 无效 </span><br><span class="line"></span><br><span class="line">    let x = 5;</span><br><span class="line">    // x 被声明有效</span><br><span class="line"></span><br><span class="line">    makes_copy(x);</span><br><span class="line">    // x 的值被当作参数传入函数</span><br><span class="line">    // 但 x 是基本类型，依然 有效</span><br><span class="line">    // 在这里依然可以使用 x 却不能使用 s</span><br><span class="line"></span><br><span class="line">&#125; // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn takes_ownership(some_string: String) &#123;</span><br><span class="line">    // 一个 String 参数 some_string 传入，有效</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_string);</span><br><span class="line">&#125; // 函数结束, 参数 some_string 在这里释放</span><br><span class="line"></span><br><span class="line">fn makes_copy(some_integer: i32) &#123;</span><br><span class="line">    // 一个 i32 参数 some_integer 传入，有效</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_integer);</span><br><span class="line">&#125; // 函数结束, 参数 some_integer 是基本类型, 无需释放</span><br></pre></td></tr></table></figure>

<p>如果将变量当作参数传入函数，那么它和移动的效果是一样的。</p>
<p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122093655775.png" alt="image-20211122093655775"> </p>
<h4 id="函数返回值的所有权机制-返回等于移动"><a href="#函数返回值的所有权机制-返回等于移动" class="headerlink" title="函数返回值的所有权机制(返回等于移动)"></a>函数返回值的所有权机制(返回等于移动)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = gives_ownership();</span><br><span class="line">    // gives_ownership 移动它的返回值到 s1</span><br><span class="line"></span><br><span class="line">    let s2 = String::from(&quot;hello&quot;);</span><br><span class="line">    // s2 被声明有效</span><br><span class="line"></span><br><span class="line">    let s3 = takes_and_gives_back(s2);</span><br><span class="line">    // s2 被当作参数移动, s3 获得返回值所有权</span><br><span class="line">&#125; // s3 无效被释放, s2 被移动, s1 无效被释放.</span><br><span class="line"></span><br><span class="line">fn gives_ownership() -&gt; String &#123;</span><br><span class="line">    let some_string = String::from(&quot;hello&quot;);</span><br><span class="line">    // some_string 被声明有效</span><br><span class="line"></span><br><span class="line">    return some_string;</span><br><span class="line">    // some_string 被当作返回值移动出函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn takes_and_gives_back(a_string: String) -&gt; String &#123; </span><br><span class="line">    // a_string 被声明有效</span><br><span class="line"></span><br><span class="line">    a_string  // a_string 被当作返回值移出函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。</p>
<h4 id="引用与租借"><a href="#引用与租借" class="headerlink" title="引用与租借"></a>引用与租借</h4><p>引用（Reference）是 C++ 开发者较为熟悉的概念。</p>
<p>如果你熟悉指针的概念，你可以把它看作一种指针。</p>
<p>实质上”引用”是变量的间接访问方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">    let s2 = &amp;s1;</span><br><span class="line">    println!(&quot;s1 is &#123;&#125;, s2 is &#123;&#125;&quot;, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 is hello, s2 is hello</span><br></pre></td></tr></table></figure>

<p><strong>&amp;</strong> 运算符可以取变量的”引用”。</p>
<p>当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值：</p>
<p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122094702262.png" alt="image-20211122094702262"> </p>
<p>函数参数传递的道理一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The length of &#x27;hello&#x27; is 5.</span><br></pre></td></tr></table></figure>

<p>引用不会获得值的所有权。</p>
<p>引用只能<strong>租借</strong>（Borrow）值的所有权。</p>
<p>即获得使用权</p>
<p>引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;run&quot;);</span><br><span class="line">    let s2 = &amp;s1;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">    s2.push_str(&quot;oob&quot;); // 错误，禁止修改租借的值</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要修改需要引用可变变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s1 = String::from(&quot;run&quot;);</span><br><span class="line">    // s1 是可变的</span><br><span class="line"></span><br><span class="line">    let s2 = &amp;mut s1;</span><br><span class="line">    // s2 是可变的引用</span><br><span class="line"></span><br><span class="line">    s2.push_str(&quot;oob&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变引用与不可变引用相比除了权限不同以外，可变引用不允许<strong>多重引用</strong>，但不可变引用可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 = &amp;mut s;</span><br><span class="line">let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">////////////////////////////错误↑</span><br><span class="line">////////////////////////////正确↓</span><br><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 = &amp;s;</span><br><span class="line">let r2 = &amp;s;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br></pre></td></tr></table></figure>



<p>Rust 对可变引用的这种设计主要出于对并发状态下发生<strong>数据访问碰撞</strong>的考虑，在编译阶段就避免了这种事情的发生。</p>
<p>由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。</p>
<h4 id="垂悬引用（Dangling-References）"><a href="#垂悬引用（Dangling-References）" class="headerlink" title="垂悬引用（Dangling References）"></a>垂悬引用（Dangling References）</h4><p>这是一个换了个名字的概念，如果放在有指针概念的编程语言里它就指的是那种<strong>没有实际指向一个真正能访问的数据的指针</strong>（注意，不一定是空指针，还有可能是已经释放的资源）。它们就像失去悬挂物体的绳子，所以叫”垂悬引用”。</p>
<p>“垂悬引用”在 Rust 语言里不允许出现，如果有，编译器会发现它。</p>
<p>下面是一个垂悬的典型案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  let s = String::from(&quot;hello&quot;);</span><br><span class="line">  &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，伴随着 dangle 函数的结束，其局部变量的值本身没有被当作返回值，被释放了。但它的引用却被返回，这个引用所指向的值已经不能确定的存在，故不允许其出现。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><p>最简单、最常用的数据切片类型是字符串切片（String Slice）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let s = String::from(&quot;broadcast&quot;);</span><br><span class="line"></span><br><span class="line">  let part1 = &amp;s[0..5];</span><br><span class="line">  let part2 = &amp;s[5..9];</span><br><span class="line"></span><br><span class="line">  println!(&quot;&#123;&#125;=&#123;&#125;+&#123;&#125;&quot;, s, part1, part2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcast=broad+cast</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122095735629.png" alt="image-20211122095735629"> </p>
<p>使用 <strong>..</strong> 表示范围的语法在循环章节中出现过。<strong>x..y</strong> 表示 <strong>[x, y)</strong> 的数学含义。**..** 两边可以没有运算数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let a = [10, 20, 30, 40, 50];</span><br><span class="line">    for i in 0..5 &#123;</span><br><span class="line">        println!(&quot;a[&#123;&#125;] = &#123;&#125;&quot;, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ..y 等价于 0..y</span><br><span class="line">// x.. 等价于位置 x 到数据结束</span><br><span class="line">// .. 等价于位置 0 到结束</span><br></pre></td></tr></table></figure>

<p><strong>字符串被切片引用 且切片被使用时 禁止更改其值：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let mut s = String::from(&quot;runoob&quot;);</span><br><span class="line">  let slice = &amp;s[0..3];</span><br><span class="line">  s.push_str(&quot;yes!&quot;); // 这两句留一句</span><br><span class="line">  println!(&quot;slice = &#123;&#125;&quot;, slice); // 这两句留一句</span><br><span class="line">  println!(&quot;s = &#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211122150839621.png" alt="image-20211122150839621"> </p>
<h4 id="str和String"><a href="#str和String" class="headerlink" title="str和String"></a>str和String</h4><p>实际上，到目前为止你一定疑惑为什么每一次使用字符串都要这样写<strong>String::from(“runoob”)</strong> ，直接写 <strong>“runoob”</strong> 不行吗？</p>
<p>事已至此我们必须分辨这两者概念的区别了。在 Rust 中有两种常用的字符串类型：str 和 String。str 是 Rust 核心语言类型，就是本章一直在讲的字符串切片（String Slice），常常以引用的形式出现（&amp;str）。</p>
<p>凡是用双引号包括的字符串常量整体的类型性质都是 <strong>&amp;str</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>

<p>这里的 s 就是一个 &amp;str 类型的变量。</p>
<p>String 类型是 Rust 标准公共库提供的一种数据类型，它的功能更完善——它<strong>支持字符串的追加、清空</strong>等实用的操作。String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个<strong>容量</strong>（capacity）属性。</p>
<p>String 和 str 都支持切片，切片的结果是 &amp;str 类型的数据。</p>
<p>注意：<strong>切片结果必须是引用类型</strong>，但开发者必须自己明示这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let slice = &amp;s[0..3];</span><br></pre></td></tr></table></figure>

<p>有一个快速的办法可以将 String 转换成 &amp;str：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = &amp;s1[..]; </span><br></pre></td></tr></table></figure>

<h4 id="非字符串切片"><a href="#非字符串切片" class="headerlink" title="非字符串切片"></a>非字符串切片</h4><p>除了字符串以外，其他一些线性数据结构也支持切片操作，例如数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let arr = [1, 3, 5, 7, 9];</span><br><span class="line">  let part = &amp;arr[0..3];</span><br><span class="line">  for i in part.iter() &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a><a target="_blank" rel="noopener" href="http://llever.com/rust-by-example-cn/macros/designators.html">宏</a></h1><p>Rust 对宏（macro）有着非常好的支持。宏能够使得你能够通过写代码的方式来生成代码，这通常被称为元编程（metaprogramming）。</p>
<p>Rust 宏非常不同于 C 里面的宏。Rust 宏会被应用于<strong>词法树（token tree）</strong>，而 C 语言里的宏则是文本替换。</p>
<p>正如你已经看过了前面章节，宏看起来和函数很像，除了名称末尾连着一个感叹号 <code>!</code> ，但宏并不产生一个函数调用，而是展开成源码并结合程序的其余代码一起进行编译。(宏提供了类似函数的功能，但是没有运行时开销。但是，因为宏会在编译期进行展开（expand），所以它会有一些编译期的开销。)</p>
<p>Rust 有两种类型的宏：</p>
<ul>
<li>声明式宏（Declarative macros）使得你能够写出类似 match 表达式的东西，来操作你所提供的 Rust 代码。它使用你提供的代码来生成用于替换宏调用的代码。</li>
<li>过程宏（Procedural macros）允许你操作给定 Rust 代码的抽象语法树（abstract syntax tree, AST）。过程宏是从一个（或者两个）<code>TokenStream</code>到另一个<code>TokenStream</code>的函数，用输出的结果来替换宏调用。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/praying/p/14457360.html">https://www.cnblogs.com/praying/p/14457360.html</a></p>
<p>宏是通过 <code>macro_rules!</code> 宏来创建的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个简单简单的宏，名为 `say_hello`。</span><br><span class="line">macro_rules! say_hello &#123;</span><br><span class="line">    // `()` 表示此宏不接受任何参数。</span><br><span class="line">    () =&gt; (</span><br><span class="line">        // 此宏将会展开成这个代码块里面的内容。</span><br><span class="line">        println!(&quot;Hello!&quot;);</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 这个调用将会展开成 `println(&quot;Hello&quot;);`!</span><br><span class="line">    say_hello!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指示符"><a href="#指示符" class="headerlink" title="指示符"></a>指示符</h2><p>宏里面的参数使用一个美元符号 <code>$</code> 作为前缀，并使用一个<strong>指示符</strong>（<em>designator</em>）来注明类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> create_function &#123;</span><br><span class="line">    <span class="comment">// 此宏接受一个 `ident` 指示符参数，并创建一个名为 `$func_name`</span></span><br><span class="line">    <span class="comment">// 的函数。</span></span><br><span class="line">    <span class="comment">// `ident` 指示符用于变量名或函数名</span></span><br><span class="line">    ($func_name:ident) =&gt; (</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> $<span class="title">func_name</span></span>() &#123;</span><br><span class="line">            <span class="comment">// `stringify!` 宏把 `ident` 转换成字符串。</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;You called &#123;:?&#125;()&quot;</span>,<span class="built_in">stringify!</span>($func_name))<span class="comment">// &#123;&#125;里的:?使得输出的字符串套上引号</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助上述宏来创建名为 `foo` 和 `bar` 的函数。</span></span><br><span class="line">create_function!(foo);</span><br><span class="line">create_function!(bar);</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> print_result &#123;</span><br><span class="line">    <span class="comment">// 此宏接受一个 `expr` 类型的表达式，将它转换成一个字符串，</span></span><br><span class="line">    <span class="comment">// 并伴随着表达式的结果。</span></span><br><span class="line">    <span class="comment">// `expr` 指示符用于表达式。</span></span><br><span class="line">    ($expression:expr) =&gt; (</span><br><span class="line">        <span class="comment">// `stringify!` 把表达式转换成一个字符串，正如 stringify</span></span><br><span class="line">        <span class="comment">// （意思为“字符串化”） 所表达的意思那样。</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; = &#123;:?&#125;&quot;</span>,<span class="built_in">stringify!</span>($expression),$expression)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo();</span><br><span class="line">    bar();</span><br><span class="line"></span><br><span class="line">    print_result!(<span class="number">1u32</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回想一下，代码块也是表达式！</span></span><br><span class="line">    print_result!(&#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">1u32</span>;</span><br><span class="line"></span><br><span class="line">        x * x + <span class="number">2</span> * x - <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">You called &quot;foo&quot;()</span><br><span class="line">You called &quot;bar&quot;()</span><br><span class="line">&quot;1u32 + 1&quot; = 2</span><br><span class="line">&quot;&#123; let x = 1u32; x * x + 2 * x - 1 &#125;&quot; = 2</span><br></pre></td></tr></table></figure>

<p>这里列出全部指示符：</p>
<ul>
<li><code>block</code> <strong>块</strong>（block）（即一个语句块或一个表达式，由花括号所包围）</li>
<li><code>expr</code> 表达式</li>
<li><code>ident</code> <strong>标识符</strong>（indentfier）,用于变量名或函数名</li>
<li><code>item</code> <strong>项</strong>（item），像一个函数，结构体，模块等</li>
<li><code>pat</code> (<strong>模式</strong> <em>pattern</em>)</li>
<li><code>path</code> <strong>路径</strong>（path）（例如，<code>foo</code>，<code>::std::mem::replace</code>，<code>transmute::&lt;_, int&gt;</code>，…）</li>
<li><code>stmt</code> (<strong>语句</strong> <em>statement</em>)</li>
<li><code>tt</code> (<strong>令牌树</strong> <em>token tree</em>)/词法树</li>
<li><code>ty</code> (<strong>类型</strong> <em>type</em>)</li>
<li><code>meta</code>  一个元数据项；位于<code>#[...]</code>和<code>#![...]</code>属性</li>
<li><code>vis</code>一个可能为空的<code>Visibility</code>限定词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">macro_rules! add_as&#123;</span><br><span class="line">// using a ty token type for macthing datatypes passed to maccro</span><br><span class="line">    ($a:expr,$b:expr,$typ:ty)=&gt;&#123;</span><br><span class="line">        $a as $typ + $b as $typ</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,add_as!(0,2,u8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// `test!` 将以不同的方式来比较 `$left` 和 `$right`，</span><br><span class="line">// 根据所调用的情况确定。</span><br><span class="line">macro_rules! test &#123;</span><br><span class="line">    // 参数不需要使用逗号隔开。</span><br><span class="line">    // 可以使用任意模板（原文：Any template can be used!）！</span><br><span class="line">    ($left:expr; and $right:expr) =&gt; (</span><br><span class="line">        println!(&quot;&#123;:?&#125; and &#123;:?&#125; is &#123;:?&#125;&quot;,stringify!($left),stringify!($right),$left &amp;&amp; $right)</span><br><span class="line">    );</span><br><span class="line">    // ^ 每个分支都必须以分号结束。</span><br><span class="line">    ($left:expr; or $right:expr) =&gt; (</span><br><span class="line">        println!(&quot;&#123;:?&#125; or &#123;:?&#125; is &#123;:?&#125;&quot;,stringify!($left),stringify!($right),$left || $right)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);</span><br><span class="line">    test!(true; or false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;1i32 + 1 == 2i32&quot; and &quot;2i32 * 2 == 4i32&quot; is true</span><br><span class="line">&quot;true&quot; or &quot;false&quot; is true</span><br></pre></td></tr></table></figure>

<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>宏在参数列表中可以使用 <code>+</code> 来表示一个参数可能出现一次或多次，使用 <code>*</code> 来表示该参数可能出现零次或多次。</p>
<p>在下面例子中，使用 <code>$(...),+</code> 包含的内容将匹配一个或多个表达式，使用逗号隔开。还注意到分号对于最后一种情形是可选的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// `min!` 将求出任意数量的参数的最小值。</span><br><span class="line">macro_rules! find_min &#123;</span><br><span class="line">    // 基本情形：</span><br><span class="line">    ($x:expr) =&gt; ($x);</span><br><span class="line">    // `$x` 后面跟着至少一个 `$y,`</span><br><span class="line">    ($x:expr, $($y:expr),+) =&gt; (</span><br><span class="line">        // 对尾部的 `$y` 调用 `find_min!` </span><br><span class="line">        std::cmp::min($x, find_min!($($y),+))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, find_min!(1u32));</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, find_min!(1u32 + 2 , 2u32));</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, find_min!(5u32, 2u32 * 3, 4u32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h1 id="学到了这"><a href="#学到了这" class="headerlink" title="学到了这"></a>学到了这</h1><p><img src="/2021/11/22/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-rust%E5%88%9D%E6%8E%A2/image-20211123100517468.png" alt="image-20211123100517468"> </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://llever.com/rust-by-example-cn/macros/repeat.html">http://llever.com/rust-by-example-cn/macros/repeat.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/praying/p/14457360.html">https://www.cnblogs.com/praying/p/14457360.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/rust/rust-struct.html">https://www.runoob.com/rust/rust-struct.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.bossma.cn/rust/rust-example-guessing-game/">https://blog.bossma.cn/rust/rust-example-guessing-game/</a></p>
</blockquote>
<h2 id="令牌树"><a href="#令牌树" class="headerlink" title="令牌树"></a>令牌树</h2><p>引入此概念是为了确保宏调用中的内容正确匹配()，[]和{}对. tt将匹配任何单个标记<strong>或</strong>括号/括号/大括号<em>及其内容</em>.</p>
<p>例如，对于以下程序:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令牌树将是:</p>
<ul>
<li>fn</li>
<li>main</li>
<li>()<ul>
<li>∅</li>
</ul>
</li>
<li>{ println!(“Hello world!”); }<ul>
<li>println</li>
<li>!</li>
<li>(“Hello world!”)<ul>
<li>“Hello world!”</li>
</ul>
</li>
<li>;</li>
</ul>
</li>
</ul>
<p>每一个都形成一棵树，简单的标记(fn，main等)是叶子，而被()，[]或{}包围的任何事物都有一个子树.请注意，(不会单独出现在令牌树中:如果不匹配相应的)，则不可能匹配(.</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">macro_rules! &#123;</span><br><span class="line">    (fn $name:ident $params:tt $body:tt) =&gt; &#123; /* … */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将与<code>$name → main</code>，<code>$params →()</code>，<code>$body → &#123; println!(&quot;Hello world!&quot;); &#125;</code>匹配上述功能。</p>
<p>令牌树是要求最低的元变量类型：它匹配任何东西。它经常被用在具有“不真正关心”部分的宏中，特别是在具有“头部”和“尾部”部分的宏中。例如，<code>println!</code>宏具有匹配<code>($fmt:expr, $($arg:tt)*)</code>的分支，其中<code>$fmt</code>是格式字符串，而<code>$($arg:tt)*</code>表示“所有其余”，并且仅转发到<code>format_args!</code>。这意味着<code>println!</code>不需要知道实际的格式并与其进行复杂的匹配。</p>
<h1 id="n1"><a href="#n1" class="headerlink" title="n1"></a>n1</h1><h2 id="数据类型转换https-www-cnblogs-com-liuhe688-p-13416091-html"><a href="#数据类型转换https-www-cnblogs-com-liuhe688-p-13416091-html" class="headerlink" title="数据类型转换https://www.cnblogs.com/liuhe688/p/13416091.html"></a>数据类型转换<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuhe688/p/13416091.html">https://www.cnblogs.com/liuhe688/p/13416091.html</a></h2><p>run是gonna++</p>
<p>up是give++</p>
<p>bye是gonna = flag{give}</p>
<p>lie 是flag{give} = gonna </p>
<p>lie up bye就是</p>
<p>flag{give} = gonna </p>
<p>give++</p>
<p>gonna = flag{give}</p>
<blockquote>
<p>give = 0 , gonna = 0</p>
<p>bye : //gonna是flag第0位</p>
<p>give = 0  ,gonna = flag{0}</p>
<p>give = 0  ,gonna = flag{0}+83</p>
<p>flag{0} = flag{0}+83 , give = 1 , gonna = flag{1}</p>
<p>flag{1} = flag{1} + 5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bye</span><br><span class="line">// run run lie up bye</span><br><span class="line">// run run run run lie up bye</span><br><span class="line">// run lie up</span><br><span class="line">// value</span><br></pre></td></tr></table></figure>



<p>lie // flag的第83位是gonna</p>
<p>up //give = 1</p>
<p>bye //gonna是flag的第一位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">macro_rules! check &#123;</span><br><span class="line">    (@s n1ctf&#123;$Never:tt&#125;) =&gt; &#123;</span><br><span class="line">        check!(stringify!($Never))</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (up $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Give += true as usize;</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna let you down $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Give -= true as usize;</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (run $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Gonna += true as u8;</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna make you cry $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Gonna -= true as u8;</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (bye $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Gonna = $Never[$Give];</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (lie $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Never[$Give] = $Gonna;</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    ($Never:expr) =&gt; &#123;&#123;</span><br><span class="line">        fn check() -&gt; bool &#123;</span><br><span class="line">            let mut never = $Never.as_bytes().to_vec();</span><br><span class="line">            let mut gonna = false as u8;</span><br><span class="line">            let mut give:usize = false as usize;</span><br><span class="line">            check!(@e (never,gonna,give); (</span><br><span class="line">            bye </span><br><span class="line">            run_83   lie up bye </span><br><span class="line">            run_5    lie up bye </span><br><span class="line">            run_76   lie up bye </span><br><span class="line">            run_61   lie up bye </span><br><span class="line">            run_70   lie up bye </span><br><span class="line">            run_117  lie up bye </span><br><span class="line">            run_41   lie up bye </span><br><span class="line">            run_83   lie up bye </span><br><span class="line">            run_2    lie up bye </span><br><span class="line">            run_35   lie up bye </span><br><span class="line">            run_115  lie up bye </span><br><span class="line">            run_101  lie up bye </span><br><span class="line">            run_117  lie up bye </span><br><span class="line">            run_56   lie up bye </span><br><span class="line">            run_105  lie up bye</span><br><span class="line">            run_97   lie up bye </span><br><span class="line">            run_94   lie up bye </span><br><span class="line">            run_101  lie up bye </span><br><span class="line">            run_29   lie up bye </span><br><span class="line">            run_21   lie up bye </span><br><span class="line">            run_12   lie up bye </span><br><span class="line">            run_106  lie up bye </span><br><span class="line">            run_85   lie up bye </span><br><span class="line">            run_80   lie up bye </span><br><span class="line">            run_67   lie up bye</span><br><span class="line">            run_6    lie up bye</span><br><span class="line">            run_21   lie up bye </span><br><span class="line">            run_120  lie up bye </span><br><span class="line">            run_85   lie up bye </span><br><span class="line">            run_57   lie up bye</span><br><span class="line">            run_98   lie up bye </span><br><span class="line">            run_11   lie up </span><br><span class="line">            Never gonna give never gonna give</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        check()</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna give never gonna give)) =&gt; &#123;</span><br><span class="line">        let you = [148u8, 59, 143, 112, 121, 186, 106, 133, 55, 90, 164, 166, 167, 121, 174, 147, 148, 167, 99, 86, 81, 161, 151, 149, 132, 56, 88, 188, 141, 127, 151, 63];</span><br><span class="line">        return $Never == you;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let result = check!(@s answer);</span><br><span class="line">    if result &#123;</span><br><span class="line">        println!(&quot;Yes&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的无脑笨比脚本:把run有多少个用vscode辅助数了出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [83, 5, 76, 61, 70, 117, 41, 83, 2, 35, 115, 101, 117, 56, 105, 97,</span><br><span class="line">   94, 101, 29, 21, 12, 106, 85, 80, 67, 6, 21, 120, 85, 57, 98, 11]</span><br><span class="line"></span><br><span class="line">b = [148, 59, 143, 112, 121, 186, 106, 133, 55, 90, 164, 166, 167, 121, 174,</span><br><span class="line">   147, 148, 167, 99, 86, 81, 161, 151, 149, 132, 56, 88, 188, 141, 127, 151, 63]</span><br><span class="line"></span><br><span class="line">for i in range(32):</span><br><span class="line">  b[i] = b[i]-a[i]</span><br><span class="line">  print(chr(b[i]), end=&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>r3kapig:</p>
<p>将代码改成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna say goodbye $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Gonna = $Never[$Give];</span><br><span class="line">        println!(&quot;Gonna = Never[Give: &#123;&#125;]: &#123;&#125;&quot;, $Give, $Never[$Give]);</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna tell a lie and hurt you $($code:tt)*)) =&gt; &#123;</span><br><span class="line">        $Never[$Give] = $Gonna;</span><br><span class="line">        println!(&quot;Never[Give: &#123;&#125;] = Gonna: &#123;&#125;&quot;, $Give, $Gonna);</span><br><span class="line">        check!(@e ($Never,$Gonna,$Give); ($($code)*));</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    let result = check!(@s n1ctf&#123;00000000000000000000000000000000&#125;);</span><br></pre></td></tr></table></figure>

<p>我的疑问:我出现了<code>error: recursion limit reached while expanding &#39;check!&#39;</code>这个报错,怎么解除递归限制?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cipher = [148, 59, 143, 112, 121, 186, 106, 133, 55, 90, 164, 166, 167, 121, 174, 147, 148,</span><br><span class="line">          167, 99, 86, 81, 161, 151, 149, 132, 56, 88, 188, 141, 127, 151, 63]</span><br><span class="line">fake_cipher = [131, 53, 124, 109, 118, 165, 89, 131, 50, 83, 163, 149, 165, 104,</span><br><span class="line">               153, 145, 142, 149, 77, 69, 60, 154, 133, 128, 115, 54, 69, 168, 133, 105, 146, 59]</span><br><span class="line">for c, f in zip(cipher, fake_cipher):</span><br><span class="line">    print(chr(c - f + 48), end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>n1ctf{A6C33EA2571A2AE26BFAE7BEA2CD8F54}</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/re/" rel="tag"># re</a>
          
            <a href="/tags/game/" rel="tag"># game</a>
          
            <a href="/tags/rust/" rel="tag"># rust</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/21/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.21-excel%E9%80%86%E5%90%91/" rel="next" title="11.21-excel型逆向(z3)">
                <i class="fa fa-chevron-left"></i> 11.21-excel型逆向(z3)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/24/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/2021/11.24-%E9%BB%91%E7%9B%92%E5%8A%A8%E8%B0%83/" rel="prev" title="11.24-黑盒动调(修改内存)">
                11.24-黑盒动调(修改内存) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">103</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%AE%E9%80%9A"><span class="nav-number">1.</span> <span class="nav-text">普通</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B"><span class="nav-number">1.1.</span> <span class="nav-text">开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rust%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text">rust环境配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hellorust"><span class="nav-number">1.1.2.</span> <span class="nav-text">hellorust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rust%E6%8D%A2%E6%BA%90"><span class="nav-number">1.1.3.</span> <span class="nav-text">rust换源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%88%B0%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">1.2.1.</span> <span class="nav-text">输出到命令行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F-%E7%9B%B4%E6%8E%A5let"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">不可变变量 :直接let</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%EF%BC%9Amut"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">可变变量：mut</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">占位符{}</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">重新绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B-i-u"><span class="nav-number">1.2.1.5.1.</span> <span class="nav-text">整型:i&#x2F;u</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B-f32-f64"><span class="nav-number">1.2.1.5.2.</span> <span class="nav-text">浮点型: f32&#x2F;f64</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="nav-number">1.2.1.5.3.</span> <span class="nav-text">布尔型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-number">1.2.1.5.4.</span> <span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E5%9E%8B"><span class="nav-number">1.2.1.5.5.</span> <span class="nav-text">复合型:</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%83%E7%BB%84"><span class="nav-number">1.2.1.5.5.1.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.5.5.2.</span> <span class="nav-text">数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">运算:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-gt-%E6%8C%87%E5%AE%9A"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">返回值: -&gt;指定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">1.2.3.</span> <span class="nav-text">条件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#while"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loop"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">loop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%A7%84%E5%88%99-%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">1.2.5.</span> <span class="nav-text">内存管理规则(所有权)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">所有权规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E5%88%86%E9%85%8D"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">内存和分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F-%E7%A7%BB%E5%8A%A8-%E5%85%8B%E9%9A%86"><span class="nav-number">1.2.6.</span> <span class="nav-text">变量与数据交互的方式(移动&#x2F;克隆)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8-%E6%A0%88%E5%A4%8D%E5%88%B6-%E5%A0%86%E5%A4%B1%E6%95%88"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">移动(栈复制&#x2F;堆失效)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%8B%E9%9A%86-%E5%A0%86%E5%A4%8D%E5%88%B6"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">克隆(堆复制)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6-%E4%BC%A0%E5%8F%82%E7%AD%89%E4%BA%8E%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">函数参数的所有权机制(传参等于移动)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6-%E8%BF%94%E5%9B%9E%E7%AD%89%E4%BA%8E%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">函数返回值的所有权机制(返回等于移动)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%9F%E5%80%9F"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">引用与租借</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%82%E6%82%AC%E5%BC%95%E7%94%A8%EF%BC%88Dangling-References%EF%BC%89"><span class="nav-number">1.2.6.6.</span> <span class="nav-text">垂悬引用（Dangling References）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">1.2.7.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">字符串切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#str%E5%92%8CString"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">str和String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">非字符串切片</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">2.</span> <span class="nav-text">宏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">2.1.</span> <span class="nav-text">指示符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">2.2.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D"><span class="nav-number">2.3.</span> <span class="nav-text">重复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E5%88%B0%E4%BA%86%E8%BF%99"><span class="nav-number">3.</span> <span class="nav-text">学到了这</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">令牌树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#n1"><span class="nav-number">4.</span> <span class="nav-text">n1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2https-www-cnblogs-com-liuhe688-p-13416091-html"><span class="nav-number">4.1.</span> <span class="nav-text">数据类型转换https:&#x2F;&#x2F;www.cnblogs.com&#x2F;liuhe688&#x2F;p&#x2F;13416091.html</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzlg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
