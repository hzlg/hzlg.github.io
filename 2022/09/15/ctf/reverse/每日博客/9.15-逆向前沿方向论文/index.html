<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="re,论文," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="逆向课需要阅读论文并写阅读报告">
<meta property="og:type" content="article">
<meta property="og:title" content="9.15-New Frontiers of Reverse Engineering">
<meta property="og:url" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/index.html">
<meta property="og:site_name" content="hzlg&#39;s blog">
<meta property="og:description" content="逆向课需要阅读论文并写阅读报告">
<meta property="og:locale">
<meta property="og:image" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20221026093122476.png">
<meta property="og:image" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220915140153319.png">
<meta property="og:image" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220915144358799.png">
<meta property="og:image" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220916233159994.png">
<meta property="og:image" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220917230830545.png">
<meta property="article:published_time" content="2022-09-14T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-25T16:00:00.000Z">
<meta property="article:author" content="hzlg">
<meta property="article:tag" content="re">
<meta property="article:tag" content="论文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20221026093122476.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hzlg.github.ioz/2022/09/15/ctf/reverse/每日博客/9.15-逆向前沿方向论文/"/>





  <title>9.15-New Frontiers of Reverse Engineering | hzlg's blog</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzlg's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记、日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzlg.github.ioz/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzlg's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">9.15-New Frontiers of Reverse Engineering</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-15T00:00:00+08:00">
                2022-09-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2022-10-26T00:00:00+08:00">
                2022-10-26
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>逆向课需要阅读论文并写阅读报告</p>
<blockquote>
<p><img src="/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20221026093122476.png" alt="image-20221026093122476"> </p>
</blockquote>
<span id="more"></span>

<h1 id="逆向工程的新前沿"><a href="#逆向工程的新前沿" class="headerlink" title="逆向工程的新前沿"></a>逆向工程的新前沿</h1><p>逆向工程的新前沿(New Frontiers of Reverse Engineering)阅读报告</p>
<p>一、摘要</p>
<p>本文简要介绍了逆向工程领域的概况，回顾了逆向工程的主要成果和应用领域，并强调了未来的关键开放研究问题。</p>
<p>二、研究对象与部分案例</p>
<p>逆向工程的核心在于从软件工件中获取信息，如在早期研究架构恢复问题时应用聚类技术可将组件识别问题视为优化问题，以及将获得的信息转换为更易于人类理解的抽象表示，如在早期研究程序分析问题时创建了能够提取并存储中间表示的工具</p>
<p>三、历史研究成果</p>
<p>本文介绍了近十年来逆向工程的主要成就，包括三个方面：程序分析，架构和设计恢复，可视化。</p>
<p>程序设计方面，近年来开发出了基于规则转换的语法分析器，能够从源代码中提取信息的事实提取器，支持集成逆向工程工具的开发环境。而OOP编程与AOP编程的兴起使得确定方法引用的技术，切面挖掘技术等被人们研究。</p>
<p>架构和设计恢复方面，静态恢复类图，动态恢复对象图，恢复UML图，恢复分布式系统的序列图现在都可以实现。WEB技术兴起后也开发了工具来对网站进行静态流分析，恢复UML文档，恢复架构，动态分析等。</p>
<p>可视化方面，提取已经被广泛使用的UML图、状态机、cfg很容易实现，可用于可视化架构/软件实体及其关系/软件度量/类/执行轨迹的工具也层出不穷。</p>
<p>四、未来研究趋势</p>
<p>未来程序分析将会面临：</p>
<p>①高动态性软件的挑战，如在运行时加载的情况下只能进行动态分析。</p>
<p>②跨语言程序的分析挑战，如web应用中涉及多种语言与技术。</p>
<p>③新形式的程序的分析挑战，如终端用户编程中的工件分析问题。</p>
<p>④在版本控制系统的帮助下如何理解软件工件在更新中是否变化，如何变化，变化是否影响软件其他特征的问题，挖掘软件存储库成为程序分析的新方法，工件更新的差异，更改的耦合关系等构成了程序分析新的的信息源。</p>
<p>未来架构和设计恢复将会面临：</p>
<p>①设计恢复未来需要处理设计范式，且要为具有高动态性、异构性和分布性的新兴软件体系结构开发设计恢复方法和工具。</p>
<p>②要支持支持 WAs 向 Web2.0应用程序迁移。</p>
<p>③全自动化设计恢复方法要么是不完整的，要么是不精确的，而半自动的设计恢复需要使用来自开发人员的信息对其进行补充，逆向工程应该能够从专家反馈中学习，自动产生结果改进工件呈现方式，帮助理解程序。</p>
<p>未来可视化将会面临：</p>
<p>①需要提供更多细节的工件视图或粗粒度视图。</p>
<p>②需要以3D或动画等简单易理解的形式呈现信息。</p>
<p>③可视化技术成果较难验证，需要进行大量实验。</p>
<p>④为新兴的软件系统类型提供可视化动态服务组合、服务绑定和重新配置的支持。</p>
<p>五、新兴计算场景的挑战</p>
<p>在正向开发过程中可以连续地利用逆向工程提取的信息，如提取高级视图以帮助系统创建，对工件进行一致性检查以减少错误，进行克隆检测以重构工件或去除代码异味，恢复丢失的可追溯性链接，跟踪代码度量以提高软件质量。</p>
<p>为了在高压市场中保持竞争力，专注于高度动态、跨组织系统的开发的面向服务架构和促进了软件系统自适应和自进化机制的自主计算正在不断发展，逆向工程需要开发出自动发现服务，系统自修复，重新配置等功能。</p>
<p>六、研究推动方法</p>
<p>逆向工程教育需要被推动，逆向工程的实证成熟度需要提高，逆向工程的工具成熟度和互操作性需要提高</p>
<p>七、总结</p>
<p>逆向工程技术将依赖于三个维度的信息：静态分析、动态分析和工件演化历史分析来分析具有高动态性、异构性和分布性的软件，且逆向工程将会成为被集成进开发过程中，成为开发过程中的一部分，在其中不断重复，进行一致性检查，提供能帮助开发人员的视图，根据专家的输入反馈自动产生结果改进工件。</p>
<p>为了推动逆向工程的采用需要三个因素支持：逆向工程教育，进一步的实证研究，成熟的可交互工具。</p>
<p>对于目前正在开发新的软件系统类型：面向服务架构和自主计算，需要启用自动发现和重新配置等机制来支持系统的开发。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>理解和修改软件是软件工程任务的核心，这解释了软件逆向工程在过去20年中获得的日益增长的兴趣。从广义上讲，<code>逆向工程是分析主题系统以在更高抽象级别创建系统表示的过程</code>。 本文简要介绍了逆向工程领域的概况，回顾了主要成就和应用领域，并强调了未来的关键开放研究问题。</p>
<blockquote>
<p><strong>逆向工程</strong>是分析主题系统以在更高抽象级别创建系统表示的过程(1)</p>
</blockquote>
<h1 id="1介绍"><a href="#1介绍" class="headerlink" title="1介绍"></a>1介绍</h1><p>许多软件工程活动需要处理现有系统。 <strong>软件维护、测试、质量保证、重用和集成</strong>是涉及现有系统的几个例子。这些过程的关键是<code>识别系统的组件和组件间关系的识别</code>。 逆向工程一词涵盖了与理解和修改软件系统相关的各种方法和工具。</p>
<blockquote>
<p><strong>软件工程</strong>的关键是识别系统的组件和组件间关系的识别(2),<strong>逆向工程</strong>包括了软件工程活动所需要的方法和工具</p>
</blockquote>
<p>软件工程这个词在1990年被Chikofsky和Cross在他们的开创性论文中提出,逆向工程的核心在于<code>从可用的软件工件中获取信息，并将其转换为更易于人类理解的抽象表示</code>。在<strong>工具</strong>的支持下，逆向工程的好处会最大化。</p>
<blockquote>
<p>分析主题系统的过程包括 识别组件(2) 和 创建系统表示(1)</p>
<p>逆向工程的核心在于从可用的软件工件中获取信息(2)，并将其转换为更易于人类理解的抽象表示(1)</p>
</blockquote>
<p>IEEE-1219标准推荐逆向工程作为关键支持技术来处理以源代码作为唯一可靠表示的系统。</p>
<p>逆向工程有几个任务:<strong>应对复杂性、生成替代视图、修复丢失的信息、检测副作用、综合更高的抽象,促进重用</strong>。</p>
<p>逆向工程已成功应用的问题领域的示例包括<strong>重新记录程序和关系数据库，识别可重用资产，恢复架构，恢复设计模式，在代码和文档之间建立可追溯性，识别克隆，代码异味(代码中需要重构的模式，可能是重复/复杂/依赖其他代码,重构:不改变代码外部行为但改善其内部结构的方式更改软件系统的过程)，计算变更影响，逆向工程二进制代码，更新用户界面/接口，将程序从一种语言翻译成另一种语言，代码迁移或包装遗留代码</strong>。</p>
<p>尽管软件逆向工程起源于软件维护，但它的定义足够广泛，以至于适用于许多问题领域，例如<strong>创建测试所需的表示，或审计安全性和漏洞</strong>。</p>
<p>本文提供了逆向工程现有工作的调查,讨论成功的案例和主要的成就,为未来可能的发展提供路线图</p>
<p>第二节介绍了逆向工程术语以及成功案例</p>
<p>第三节介绍了近十年来逆向工程的主要成就,包括三个方面:程序分析,设计恢复,可视化</p>
<p>第四节在上述3个领域中确定并讨论了接下来几年逆向工程可能会遇到的挑战</p>
<p>第五节确认了来自新兴计算范例的挑战,如面向服务的计算和自动化计算</p>
<p>第六节 The issue of easing the adoption of reverse engineering</p>
<p>第七节 总结全文</p>
<h1 id="2逆向工程术语以及成功案例"><a href="#2逆向工程术语以及成功案例" class="headerlink" title="2逆向工程术语以及成功案例"></a>2逆向工程术语以及成功案例</h1><blockquote>
<p>我的总结:</p>
<p>逆向工程的核心在于从软件<code>工件中获取信息</code>(文档重构:产生/修改工件在同一抽象层级的视图)</p>
<p>如在早期研究架构恢复问题时应用<code>聚类技术</code>可将组件识别问题视为优化问题</p>
<p>使用<code>软件反射模型</code>能够捕捉<code>源代码与工件之间的差异</code></p>
<p>使用<code>模糊集的联合</code>能将逆向工程的结果与专家/开发人员的反馈结合起来</p>
<p>在数据集(<code>控制流和数据流信息</code>)上使用cliché匹配能被用于半自动架构恢复</p>
<p>以及将获得的信息转换为更易于人类理解的<code>抽象表示</code>(设计恢复:重新创建设计抽象)</p>
<p>如在早期研究程序分析问题时创建了能够提取并存储<code>中间表示</code>的工具</p>
<p>理解/重组数据结构和数据库,识别维护源代码,保存遗留系统</p>
<p>程序切片技术</p>
</blockquote>
<p>第二节介绍了逆向工程术语以及成功案例</p>
<p>逆向工程被分为两步:<code>信息提取</code>和<code>信息抽象</code>，信息提取阶段分析系统工件来收集原始数据,信息抽象阶段创建面向用户的文档和视图</p>
<p>信息提取包括提取<code>从源代码中控制流图(cfg),源代码度量，源代码事实</code></p>
<p>信息抽象可以<code>设计工件，可追溯性链接，业务对象</code></p>
<blockquote>
<p>逆向两个步骤:信息提取(3)和信息抽象(4)</p>
</blockquote>
<p>Chikofsky和Cross概述了逆向工程工具的基本结构：</p>
<blockquote>
<img src="/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220915140153319.png" alt="image-20220915140153319" style="zoom: 50%;"> 
</blockquote>
<p>软件被语法分析器,语义分析器分析后的结果存储到了信息库中</p>
<p>视图合成器会将结果转换为软件的其他视图,如代码度量、图形、报告等</p>
<blockquote>
<p>分析(3)+产生其他视图(4)</p>
</blockquote>
<p>逆向工程工具旨在从软件运行中获取抽象,或不同的形式的表示</p>
<p>逆向可以在任何软件<code>工件</code>上执行:需求、设计、代码、测试用例、手册页，等等。</p>
<p>逆向工程有两大目标:<code>文档重构</code>和<code>设计恢复</code></p>
<p>文档重构旨在产生/修改给定工件在同一层次抽象的备选视图,如还原源代码或产生可视化cfg。</p>
<p>设计恢复旨在从 源代码/现有文档/专家建议 重新创建设计抽象</p>
<blockquote>
<p>逆向目标：文档重构（产生/修改工件在同一抽象层级的视图）(5)，设计恢复（重新创建抽象）(6)</p>
</blockquote>
<p>严格来说逆向工程不包括重组，即从一种表示形式到另一种表示形式的转换(如源代码间的转换),也不包括再造，再造的目的是改变系统且以新的形式重构系统(如代码移植)</p>
<p>代码再造包括了获取软件抽象的逆向工程,重构系统的正向工程,是一个马蹄形的架构</p>
<blockquote>
<img src="/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220915144358799.png" alt="image-20220915144358799" style="zoom:67%;"> 
</blockquote>
<p>第一步:从源代码中提取架构</p>
<p>第二部:向目标架构转换</p>
<p>第三步:实例化新架构</p>
<p>观察这个马蹄模型可以明白代码再造如何在不同的抽象层次进行：代码表征,函数表征,架构表征</p>
<blockquote>
<p>代码再造严格来说不是逆向的而一部分,而是包括逆向,可以观察马蹄模型看到逆向工程和正向工程在代码表征,函数表征,架构表征三个层次如何进行</p>
</blockquote>
<p>在过去的20年里，逆向工程领域已经做了很多工作。</p>
<p>主要成果已在逆向工程工作会议(WCRE)、软件维护国际会议(ICSM)、程序理解国际会议(ICPC，前称IWPC)、源代码分析和操作国际研讨会(SCAM)、ICSM和ICSE研讨会以及其他主要软件工程会议和期刊上发表。</p>
<blockquote>
<p>主要成果刊登在会议里</p>
</blockquote>
<p>在90年代早期,逆向工程的研究集中在<code>与程序性软件分析相关的问题上</code>,分析程序来理解它并应对可能出现的问题(如Y2K问题),创建了很多 fact extractors(从源代码提取中间表示并将其存储到数据库中的工具),比如中情局使用一个叫做Refine的面向对象数据库来以AST抽象语法树的形式存储细粒度的程序模型</p>
<blockquote>
<p>早期研究<code>程序性软件分析</code>,创建提取中间表示的工具</p>
</blockquote>
<p>面向对象语言的推广带来了将现有的过程性软件以面向对象的形式重新设计的建议,开发了将对象识别为遗留代码的方法,尽管这些方法很有前途,也有语言转换技术的辅佐,但人们怀疑目标程序的的可理解性和可维护性,因为目标程序通常只有目标语言的语法,没有遵守其设计哲学</p>
<blockquote>
<p>新语言的出现,是被遗留代码</p>
</blockquote>
<p>在九十年代和新千年初期，架构恢复也一直是主流研究。 架构旨在识别构成软件系统架构的组件，以及它们之间的关系（连接器）。 正如 Koschke 的博士论文 [67] 中所指出的，架构恢复对于提高可理解性、促进重用以及支持和管理软件演化非常重要。 过去使用基于度量的(metrics-based)或<a target="_blank" rel="noopener" href="https://www.baike.com/wiki/%E5%BD%A2%E5%BC%8F%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90?view_id=2isbr1aii9c000">形式概念分析(Formal Concept Analysis，FCA)</a>等方法执行组件恢复。</p>
<blockquote>
<p>早期还研究<code>架构恢复</code>,识别组件,辨别关系(2)</p>
</blockquote>
<p>进一步的工作集中在提出用于组件恢复的聚类度量和基于启发式的技术。 过去，Tzerpos 和 Holt已经发表了对应用于软件系统的组件识别的<code>聚类技术</code>的调查。 Mitchell 和 Mancoridis提出了一种依赖模块间和模块内<code>依赖图</code>来重构软件系统的方法。 一般来说，当使用基于度量的方法时，组件识别可以被视为一个优化问题。</p>
<blockquote>
<p>组件识别能视为优化问题</p>
</blockquote>
<p>架构恢复是一种半自动方法，因此可能需要手动干预，如 Rigi。 恢复架构时要解决的主要问题之一是捕获源代码组织和高级工件背后的思维模型之间的差异。</p>
<p>Murphy等人提出了一种名为<code>软件反射模型</code>的方法来捕捉和利用这些差异。</p>
<p>在他的论文中，Koschke提出了一种方法，通过使用<code>模糊集的联合</code>来组合不同的技术，从每一种技术中获益，并将这些结果与从系统专家/开发人员获得的信息结合起来。</p>
<p>正如Linda Wills的博士论文和随后的许多论文所讨论的那样，cliché匹配是体系结构恢复的一种有效策略。Fiutem等人提出了一种方法，通过在<code>控制流和数据流信息</code>上使用cliché匹配来检测体系结构连接器——如管道、共享内存、远程过程调用、套接字等。Cliché匹配最近被Sartipi用于半自动架构恢复，他开发了一种名为Alborz的架构恢复工具和一种名为架构查询语言(architecture query language, AQL)的查询语言。</p>
<blockquote>
<p>用软件反射模型来捕捉源代码和工件之间的差异</p>
<p>用模糊集联合来组合不同的技术</p>
<p>用cliché匹配在CFG上来检测架构连接器</p>
</blockquote>
<p>在数据逆向工程领域做了大量的工作，目的是理解和/或重组现有的数据结构或数据库，最重要的是，应对千年虫问题。多亏了逆向工程技术的使用，维护人员能够识别和维护不符合千年变化的源代码部分。这帮助节省了数十亿美元，并防止了该故障可能造成的重大损失。多亏了逆向工程和再工程技术，遗留系统在新技术(如Web)的引入中幸存下来，这一点，以及这一事实，都是工业如何从逆向工程中极大受益的重要例子。</p>
<blockquote>
<p>理解/重组数据结构和数据库,识别维护源代码,保存遗留系统</p>
</blockquote>
<p>在程序切片、切丁和切切方面进行了相关工作。</p>
<p>在Weiser的开创性论文发表25年后，许多不同种类的切片技术已经被开发出来，并开展了比较不同切片方法的研究。</p>
<p>现在已经有了健壮有效的切片工具，如CodeSurfer或Indus。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/379422670">程序切片</a></p>
</blockquote>
<p>最后，这些早期的逆向工程已经见证了二进制逆向工程方法的发展，即，当源代码不可用时，从二进制中提取源代码或高级表示</p>
<blockquote>
<p>二进制逆向,低层次到源代码</p>
</blockquote>
<h1 id="3逆向工程十年成就"><a href="#3逆向工程十年成就" class="headerlink" title="3逆向工程十年成就"></a>3逆向工程十年成就</h1><p>第三节介绍了近十年来逆向工程的主要成就,包括三个方面:程序分析,设计恢复,可视化</p>
<p>本节讨论了逆向工程在过去10年的主要成就。其中许多是在M¨uller等FoSE 2000论文之后出现的，实际上解决了他们论文中列出的问题和挑战。</p>
<p>讨论围绕三个主线展开:程序分析及其应用、设计恢复和软件可视化，旨在作为起草未来研究路线图的基线。</p>
<blockquote>
<p>成就:程序分析及其应用、设计恢复和软件可视化</p>
</blockquote>
<h2 id="程序分析及其应用"><a href="#程序分析及其应用" class="headerlink" title="程序分析及其应用:"></a>程序分析及其应用:</h2><p>过去几年见证了一些程序分析技术和工具的发展。其中一些依赖于<code>静态分析</code>技术，而近年来已经看到越来越多的使用<code>动态分析</code>作为静态分析的有效补充方法:尽管动态分析可能是昂贵的和不完整的，它是必要的，以处理许多仅静态分析是不够的逆向工程问题。</p>
<blockquote>
<p>静态分析+动态分析</p>
</blockquote>
<p>目前，有几个分析和转换工具包可以帮助逆向工程师完成他们的任务。例如，Semantic Designs开发的设计维护系统(DMS)[9]、TXL[33]或Stratego工具包[15]。这些工具包提供了解析源代码和执行基于规则的转换的工具。</p>
<blockquote>
<p>源代码分析工具1:语法分析,基于规则的转换</p>
</blockquote>
<p>尽管在源代码分析工具的开发上付出了努力，尽管解析技术已经成熟，但大量编程语言方言的扩散——这一现象被称为“500种语言问题”[70]——或诸如处理宏和预处理器指令等问题，突出了对替代源代码分析方法的需要。Moonen[88]通过岛解析和湖解析发展了源代码分析的思想，即只分析与特定目的相关的代码片段。</p>
<blockquote>
<p>源代码分析方法:岛解析和湖解析,只分析特定代码段(岛上的,不分析水中的)</p>
</blockquote>
<p>近年来开发的一些最常用的源代码分析工具是事实提取器，它能够从源代码中提取相关信息，甚至不需要彻底的源代码解析。著名的例子有MOOSE[39]、SrcML[31]、Columbus[45]或Bauhaus[67]。不同事实提取器的扩散概述了需要使用公共模式来表示它们[46]，例如GXL[115]或MOOSE使用的FAMIX元模型。</p>
<blockquote>
<p>源代码分析工具2:事实提取器</p>
</blockquote>
<p>在他们的FOSE 2000论文中，M¨uller等人[91]强调了将逆向工程技术合并到开发环境或Emacs等可扩展编辑器中的必要性，以便于维护者采用它们。今天的开发环境，如Eclipse或NetBeans，强烈支持这样的集成思想。事实上，它们允许工具的开发——包括逆向工程工具——作为集成到开发环境中的插件，能够与其他工具交互，例如源代码编辑器，并能够动态访问程序员当前正在编写的源代码文件的AST。</p>
<blockquote>
<p>逆向工程工具可以集成到开发环境中</p>
</blockquote>
<p>为了处理面向对象语言引入的特性，例如多态，在程序分析方面已经做了大量的工作。</p>
<p>例如使用指向分析points-to-analysis来确定方法调用引用的可能方法集，或者使用指向和数据流分析来分析异常处理。</p>
<blockquote>
<p>面向对象特性:使用指向分析来确定<code>方法的引用</code>,使用指向和数据流分析来分析<code>异常处理</code></p>
</blockquote>
<p>一个激发了许多成功研究的有趣现象是软件系统中<code>克隆</code>的存在(图3显示了一个从Linux内核克隆的例子)。</p>
<blockquote>
<p><img src="/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220916233159994.png" alt="image-20220916233159994"> </p>
</blockquote>
<p>结果是产生了不同的技术，即基于记号的，基于ast的，基于度量的，每一种技术都确保了不同的优势，如高精度(基于ast)或高召回率(基于记号)，语言独立性，或检测剽窃的能力(基于度量)。已有实证研究对大型软件系统中克隆的存在和演化进行了分析:克隆百分比趋向于保持稳定:当新的克隆出现时，旧的克隆会被重构。最后，与常识相反的是，克隆的存在并不一定是一种不好的代码异味和有害的现象:只要维护者意识到它们的存在，克隆构成了一种广泛采用的机制，以促进软件开发(例如，为一段类似的代码创建<code>模板</code>)和重用。另一方面，克隆移除可能是有风险和不受欢迎的。</p>
<blockquote>
<p>软件系统中克隆技术,产生了基于token的,基于ast的,基于度量的技术</p>
<p>克隆不一定完全是冗余的,有害的,创建代码模板等技术就运用到了克隆技术</p>
</blockquote>
<p>面向切面的编程代表了软件开发的新前沿之一。它解决了横切关注点的问题，也就是说，通过一个新的模块化单元，即封装它们的切面，特性分布在许多模块中。为了支持横切关注点的维护，以及将它们重构为切面，需要将它们标识到源代码中。考虑到这一点，开发了几种切面挖掘方法。它们基于方法扇入分析[79]，或执行轨迹的动态分析[106]。</p>
<blockquote>
<p>面向切面的编程AOP是软件开发的新前沿之一,开发了几种切面挖掘方法</p>
</blockquote>
<p>软件系统中包含的文本(以<code>注释或标识符</code>的形式)在逆向工程中发挥了核心作用。</p>
<p>特别是，它已被用于恢复不同软件工件之间的可追溯链接，使用向量空间模型和概率排序，或潜在语义索引(LSI)。</p>
<p>此外，使用信息检索技术的文本分析已被用于基于标识符和注释之间的相似性进行软件质量评估，用于度量类的概念内聚性，或用于执行语义聚类。</p>
<blockquote>
<p>注释或标识符等文本能恢复工件之间的可追溯链接,<code>文本分析</code>可以用来进行质量评估</p>
</blockquote>
<h2 id="架构和设计恢复"><a href="#架构和设计恢复" class="headerlink" title="架构和设计恢复"></a>架构和设计恢复</h2><p>九十年代早期的研究集中在从<code>过程代码</code>中恢复<code>高级架构或图表</code></p>
<p>一方面，面向对象语言的普及，另一方面，统一建模语言(UML)的普及，引入了从源代码逆向工程UML模型的需要。</p>
<blockquote>
<p>早期的设计恢复：恢复架构/图表,UML模型</p>
</blockquote>
<p>该领域的相关工作由 Tonella 和 Potrich进行。 首先，他们提出了一种恢复类图的静态方法。 对于对象图，需要结合静态和动态信息。 </p>
<p>Tonella 和 Potrich 表明，缺少一些流传播信息的 静态视图需要使用（可能不完整）包含 类字段到对象的绑定 的动态信息进行传播。 </p>
<p>Tonella 和 Potrich 通过对数据流的保守静态分析提取序列图，而 Systä 结合静态和动态分析来恢复 UML 图 [104]。 布里安德等人还使用动态分析来恢复分布式系统的序列图，并且通过转换，他们能够恢复详细信息，例如条件、交换的消息和数据流。</p>
<blockquote>
<p>静态恢复类图,动态恢复对象图</p>
<p>恢复UML图</p>
<p>恢复分布式系统的序列图</p>
</blockquote>
<p>面向对象的开发伴随着设计模式的扩散。</p>
<p>从逆向工程的角度来看，在源代码中标识设计模式的目的是促进重用和评估代码质量。</p>
<p>在这种情况下，静态技术和动态技术都被使用了。</p>
<p>所有的技术都是基于cliché对部分类图的匹配(静态方法)或对执行跟踪的匹配(动态方法)。</p>
<blockquote>
<p>cliché匹配静态类图与动态执行跟踪来标识设计模式</p>
</blockquote>
<p>特征识别和定位是逆向工程中广泛存在的研究问题。</p>
<p>特性定位是一种技术，旨在识别在执行一项功能时激活的程序源代码的子集。</p>
<p>考虑到这一点，提出了使用静态分析、动态分析和它们的组合的技术。</p>
<p>例如，王尔德和Scully提出了动态分析技术。</p>
<p>Chen和Rajlich提出了一种基于抽象系统依赖图(ASDG)的静态技术。</p>
<p>Eisenbarth等人结合使用静态和动态数据来识别特征。</p>
<p>在完成静态分析之后，他们使用FCA(形式概念分析)来关联特征。</p>
<p>Antoniol和Gu ‘ eh ‘ eneuc也结合了静态和动态分析。</p>
<p>在他们的方法中，跟踪分析之后是基于知识的过滤和旨在识别与特定特征相关的事件的概率排序。</p>
<p>Marcus和Poshyvanyk[78]使用了一种完全不同的技术，基于在源代码上应用LSI。</p>
<p>然后将他们的技术与Antoniol和Guéhéneuc提出的技术相结合，产生了比两种单独技术更好的结果[93]。</p>
<blockquote>
<p>动态分析技术，基于ASDG的技术，使用静态与动态数据来静态识别特征然后使用FCA来关联特征</p>
<p>xxx，在源代码上应用LSI</p>
</blockquote>
<p>最后，过去十年中Web的大规模普及引发了对与Web应用程序(WAs)相关的反向工程技术的需求。</p>
<p>除了逆向工程相关的会议外，这一领域的研究也在网站进化国际研讨会(WSE)中得到传播。</p>
<p>WAs目前的特性要求开发新的逆向工程技术，或调整现有的技术。</p>
<p>与WAs的交互通过浏览器中的可视化页面进行，并通过将数据从浏览器发送到Web服务器进行。</p>
<p>作为一个额外的复杂性级别，这些页面—包括要由浏览器执行的脚本代码—是动态生成的。</p>
<p>Tilley和Huang比较了商业WA开发工具的逆向工程能力。</p>
<p>显然，这些功能还不足以满足逆向工程的需求，必须做更多的工作。</p>
<p>Ricca和Tonella对WAs逆向工程做出了重大贡献，他们开发了ReWeb工具来对网站进行分析[95]，并扩展到WAs传统的静态流分析。</p>
<p>Di Lucca等人提出了一种方法和工具(W ARE)从W As[37]中恢复Conallens UML文档。</p>
<p>Hassan和Holt[56]讨论了W As的架构恢复问题。</p>
<p>Antoniol等人处理了WAs的动力学问题，提出了WANDA作为WAs的动力学分析工具。</p>
<blockquote>
<p>WEB技术的兴起要求开发新的逆向技术，因为浏览器的可视化页面和要执行的脚本都是动态生成的</p>
<p>开发了ReWeb工具来对网站进行分析，恢复UML文档，架构恢复，动态分析工具</p>
</blockquote>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>向开发人员或维护人员提供信息的方式对程序分析或设计恢复技术的有用性有很大影响。</p>
<p>在某些情况下，选择合适的可视化是很简单的，例如，当逆向工程技术旨在从源代码中提取定义良好的、广泛采用的图时，例如UML图、状态机、cfg等。</p>
<p>在其他情况下，可视化构成了逆向工程技术的本质，因为它能够在正确的细节级别突出显示相关信息。</p>
<blockquote>
<p>提取已经被广泛使用的UML图、状态机、cfg是很简单的,而对于其他的情况,可视化很重要,因为可视化能突出相关信息</p>
</blockquote>
<p>能够可视化静态提取信息的工具包括Rigi工具[116]、CodeCrawler[72]、Seesoft[40]、SHriMP[102]和sv3D[75]。</p>
<p>其中一些工具——如Rigi或shrim——旨在显示架构视图。</p>
<p>其他工具，如sv3D，提供了软件工件度量的3D可视化。</p>
<p>CodeCrawler结合了显示软件实体及其关系的功能，以及使用多度量视图可视化软件度量的功能，多度量视图使用方框的宽度、长度和颜色显示不同的度量(参见图4)，以及类似的方法类蓝图[38]来可视化关于类的信息。</p>
<p>其他可视化工具，如Program Explorer[71]，旨在可视化动态信息，例如，从执行轨迹中提取的信息。</p>
<blockquote>
<p>静态提取信息:显示架构/3D可视化/显示软件实体及其关系/可视化软件度量/可视化类/可视化执行轨迹</p>
</blockquote>
<h1 id="4逆向工程的未来趋势"><a href="#4逆向工程的未来趋势" class="headerlink" title="4逆向工程的未来趋势"></a>4逆向工程的未来趋势</h1><p>第四节在上述3个领域中确定并讨论了接下来几年逆向工程可能会遇到的挑战</p>
<h2 id="程序分析的未来趋势"><a href="#程序分析的未来趋势" class="headerlink" title="程序分析的未来趋势"></a>程序分析的未来趋势</h2><p>当今和未来程序分析的主要挑战之一是<code>处理高动态</code>。</p>
<p>今天广泛使用的许多编程语言都允许高动态性，这构成了强大的开发机制，但增加了分析的难度。</p>
<p>例如，像Java这样的语言引入了<code>反射</code>的概念和在<code>运行时加载类</code>的能力。</p>
<p>这影响了许多分析技术，比如静态指向分析:在运行时类加载的情况下，不可能确定引用指向的对象集。</p>
<p>因此需要动态分析作为静态分析的必要补充。</p>
<p>另一方面，像反射这样的机制可以简化一些分析任务，例如提供对给定类的字段和方法的访问。</p>
<p>Java虚拟机(JVMT M) 1.5还通过JVM工具接口(JVMTI)提供了分析功能:可以通过从它获取信息来执行动态分析，而不是通过检测源代码。</p>
<p>这避免了对源代码解析/仪器的需要，最重要的是，避免了对源代码本身的需要。</p>
<blockquote>
<p>语言允许高动态性,越来越复杂</p>
<p>反射可以简化分析任务,运行时加载只能动态分析,可以在没有源代码的条件下从JVM获取动态分析需要的信息</p>
</blockquote>
<p>另一个重要的程序分析挑战是跨语言应用程序。</p>
<p>新的程序分析工具必须能够处理用于开发单一软件系统的语言和技术的多样性。</p>
<p>例如，如果我们考虑Was，它们通常由HTML片段、服务器端脚本和客户端脚本、用SQL编写的数据库查询组成。</p>
<p>Moise等人[87]和Strein等人[103]提出的工作代表了朝着这个方向的步骤。</p>
<blockquote>
<p>跨语言程序的分析,web应用里有HTML片段,服务器端脚本和客户端脚本、用SQL编写的数据库查询</p>
</blockquote>
<p>新形式的程序将代表逆向工程未来应用的来源。</p>
<p>一个例子是分析由Burnett等人定义为终端用户编程[18]所产生的工件的需求，例如，通过使用生产力工具来开发软件。</p>
<p>文字处理器和电子表格等资产必须与源代码同等重要:公式或宏中的错误将导致数百万美元的损失。</p>
<blockquote>
<p>新形式的程序如 终端用户编程 中的工件 需要被分析</p>
<p>文字处理器和电子表格和源代码一样重要,不能出错</p>
</blockquote>
<p>逆向工程研究强调了静态分析和动态分析之间的二元论，需要补充这两种技术，试图利用两者的优点和限制它们的缺点。</p>
<p>然而，静态和动态分析技术都可以用来分析软件系统配置快照，而忽略了软件在此期间是如何发展的。</p>
<p>尽管如此，理解软件工件在一个给定的版本中是如何变化的，一些工件是否一起变化，这些变化是否与其他软件特征相关(例如，缺陷)，等等是很有用的。</p>
<p>由于版本控制系统(如并发版本系统(CVS)或Subversion (SVN))和问题报告系统(如Bugzilla)的广泛使用，这种分析现在是可行的。</p>
<blockquote>
<p>静态分析和动态分析要扬长补短</p>
<p>软件是不断发展的,在版本控制系统的帮助下 理解软件工件在更新中是否变化,如何变化,变化是否影响软件其他特征是很重要的</p>
</blockquote>
<p>在过去几年中，对这些数据源的分析进行了深入研究，并且出现了一个新的重要研究领域：<code>挖掘软件存储库</code>。</p>
<p>相关工作已在软件维护相关会议、Mining Software Repositories (MSR) 研讨会和主要期刊上进行了报道。 </p>
<p>虽然这种研究被认为是研究软件进化、分析开发人员行为或关联不同软件特征的有效方法——例如，度量概要的缺陷[54]——但最近软件存储库信息已被用作分析的替代或补充方法。 例如，盖格等人。 [49] 与软件存储库共同更改的相关克隆，以及 Canfora 等人。 具有横切关注点[21]。</p>
<blockquote>
<p>挖掘软件存储库获得软件存储库信息被用作程序分析的替代或补充方法</p>
</blockquote>
<p>在过去的10年里，软件分析从单一维度(静态分析)发展到二维(静态和动态分析)，最后，今天的机会是增加<code>第三个维度</code>，包括从<code>软件存储库</code>[24]中提取的数据的历史分析。</p>
<p>文件修订之间的<code>更改差异</code>、在同一时间窗口内共同更改的文件之间的<code>更改耦合关系</code>、错误报告和代码存储库之间的关系，以及在问题修复报告和CVS消息中记录的更改原理，构成了对静态和动态分析的有价值的信息源。</p>
<blockquote>
<p>在过去的10年里，软件分析从单一维度(静态分析)发展到二维(静态和动态分析)，最后，今天的机会是增加<code>第三个维度</code>，包括从<code>软件存储库</code>中提取的数据的历史分析。</p>
<p>更改差异,更改耦合关系等构成了程序分析的信息源</p>
</blockquote>
<h2 id="设计恢复的未来趋势"><a href="#设计恢复的未来趋势" class="headerlink" title="设计恢复的未来趋势"></a>设计恢复的未来趋势</h2><p>即将进行的与设计恢复相关的研究需要能够处理分析师和软件架构师目前正在使用的设计范式。</p>
<p>虽然已经做了大量的工作来从源代码中提取UML文档，但是仍然需要做大量的工作，特别是关于动态图的提取以及对象约束语言(OCL)的前置和后置条件。</p>
<p>另一方面，需要为新的软件体系结构开发设计恢复方法和工具，这些体系结构具有高动态、高度分布式、自配置和异构的特征。</p>
<p>我们将在5.2节中讨论这些问题，以分析面向服务的体系结构(SOA)。</p>
<blockquote>
<p>设计恢复未来要能处理设计范式</p>
<p>且要为具有<code>高动态性</code>、<code>异构性</code>和<code>分布性</code>的新兴软件体系结构开发设计恢复方法和工具</p>
</blockquote>
<p>在第三节中，我们强调了WA逆向工程在过去十年中所扮演的重要角色。</p>
<p>Web应用程序现在正在向Web 2.0发展，这将对逆向工程产生不可忽视的影响。</p>
<p>例如，将需要能够支持现有WAs(由通过HTML表单与用户交互的多个页面组成)向用户与单个页面交互的Web 2.0应用程序迁移的技术。</p>
<p>进一步的挑战将与逆向工程处理用于新的WAs的新技术数量的能力有关。</p>
<blockquote>
<p>支持 WAs 向 Web2.0应用程序迁移</p>
</blockquote>
<p>逆向工程文献报告了几种声称可以从<code>源代码中恢复设计或任何更高级别工件</code>的方法。</p>
<p>基于第3节中所讨论的内容，设计恢复的目标不仅是<code>提取源代码中可用的信息，以生成更高级别的工件</code>，还包括<code>使用来自开发人员基本原理的信息对其进行补充</code>。</p>
<blockquote>
<p>设计恢复的目标不仅是<code>提取源代码中可用的信息，以生成更高级别的工件</code>，还包括<code>使用来自开发人员基本原理的信息对其进行补充</code>。</p>
</blockquote>
<p>考虑到这一点，目前提出的设计恢复方法有两个局限性:。</p>
<ol>
<li>它们要么是<code>不完整的</code>，要么是<code>不精确的</code>，即可以牺牲<code>召回率</code>以保证良好的<code>精确度</code>，反之亦然;</li>
<li>它们是<code>半自动</code>的，也就是说，它们的应用需要<code>人类专家的输入</code>，以<code>补充或纠正自动提取的信息</code>。</li>
</ol>
<p>当一种方法是完全自动化的，这就降低了它的精度或召回率，或者获得的设计只能被维护者部分使用。</p>
<p>当维护者向逆向工程系统提供反馈时，交互式地改进工件呈现方式的可能性将使程序理解任务受益匪浅。</p>
<blockquote>
<p>全自动化设计恢复方法要么是不完整的，要么是不精确的,而半自动的设计恢复需要使用来自开发人员的信息对其进行补充</p>
<p>改进工件呈现方式可以帮助理解程序</p>
</blockquote>
<p>逆向工程的未来活动应该推动人类反馈与自动逆向工程技术的紧密结合。</p>
<p>换句话说，逆向工程机械应该能够从专家反馈中学习，自动产生结果。</p>
<p>机器学习、元启发式和人工智能提供了大量机制，能够利用计算过程中提供的反馈。</p>
<p>举几个例子，Rocchio反馈机制可以用来交互改进向量空间模型的结果。</p>
<p>例如，Huffman Hayes等人使用相关性反馈来提高可追溯性恢复[59]。</p>
<p>此外，像遗传算法(GAs)这样的启发式方法提供了一种从用户反馈构建适应度函数的方法。</p>
<p>这种机制被称为交互式GAs (IGAs)(例如，参见Llora等人[74]的工作)，可以潜在地应用于改进基于启发式的逆向工程方法，如聚类、设计模式恢复和重构识别。</p>
<p>关于在软件工程中使用交互适应度函数的更多细节，可以在Harman的FoSE论文[55]中找到。</p>
<blockquote>
<p>自动和反馈的结合</p>
</blockquote>
<p>最后，逆向工程可以进一步恢复设计工件:需求也是逆向工程可以产生的一个重要输出[117]。</p>
<blockquote>
</blockquote>
<h2 id="软件可视化的未来趋势"><a href="#软件可视化的未来趋势" class="headerlink" title="软件可视化的未来趋势"></a>软件可视化的未来趋势</h2><p>尽管在软件可视化方面做了大量的工作，但在逆向工程社区中，关于可视化的有用性一直存在着长期而重复的讨论。有效的可视化应该能够:</p>
<ol>
<li>显示特定用户需要的正确细节级别，并让用户选择查看更深入层级的工件,或有一个粗粒的，大范围的视图;</li>
<li>以用户能够理解的形式显示信息。简单的可视化应该比更复杂的可视化更受欢迎，如3D或动画，当这并不一定带来无法用更简单的方式可视化的额外信息时。</li>
</ol>
<blockquote>
<p>提供更多细节的工件视图或粗粒度视图</p>
<p>以3D或动画等简单易理解的形式呈现信息</p>
</blockquote>
<p>虽然其他的逆向工程技术可以以一种相对容易的方式进行验证——例如，分析开放源码系统，随着时间的推移，它成为了一些技术比较的基准——但这对于可视化来说就比较困难了。为了研究可视化的有用性、有效性和可扩展性，越来越需要实验。</p>
<p>还需要注意的是，评估可视化技术需要研究程序员在理解软件时建立的思维模型[101]。最后，评估软件可视化的实验现在可以利用先进的监控系统，例如眼球跟踪工具，来监控一个受试者在实验任务中是否以及如何使用特定的可视化。 </p>
<blockquote>
<p>可视化技术成果较难验证,需要进行大量实验</p>
</blockquote>
<p>SOA或自治系统背后的机制是相当复杂的，并且，正如将在第5.2节中更好地解释的那样，它们的理解对于在出现故障时调试这些系统或执行维护是必要的。可视化研究应该在这个领域做更多的工作，例如，提供可视化动态服务组合、服务绑定和重新配置的支持。</p>
<blockquote>
<p>可视化要支持新兴的软件开发场景</p>
</blockquote>
<h1 id="5新兴软件开发场景中的逆向工程"><a href="#5新兴软件开发场景中的逆向工程" class="headerlink" title="5新兴软件开发场景中的逆向工程"></a>5新兴软件开发场景中的逆向工程</h1><p>第五节确认了来自新兴计算范例的挑战,如面向服务的计算和自动化计算</p>
<p>逆向工程的不同领域需要处理新的开发范式和技术。下面的小节重点介绍了逆向工程师面临的一系列问题和挑战。我们认为，未来几年的逆向工程必须能够应对:</p>
<ol>
<li>一方面，对具有高动态、分布和异构性的系统进行分析，另一方面，通过提供技术来帮助开发人员启用诸如自动发现和重新配置等机制，从而支持系统的开发;</li>
<li>需要将逆向工程与开发过程完全集成，这将在开发人员编写代码、处理设计模型等时从逆向工程技术的动态应用中受益。</li>
</ol>
<blockquote>
<p>对具有高动态、分布和异构性的系统进行分析,启用自动发现和重新配置等机制来支持系统的开发</p>
<p>将逆向工程与开发过程完全集成</p>
</blockquote>
<h2 id="连续逆向工程-在正向开发中使用逆向"><a href="#连续逆向工程-在正向开发中使用逆向" class="headerlink" title="连续逆向工程:在正向开发中使用逆向"></a>连续逆向工程:在正向开发中使用逆向</h2><p>M¨uller等人[91]强调了在<code>正向开发过程中利用逆向工程提取的信息</code>的思想，即通过使用逆向工程技术使一些信息或工件(例如，体系结构视图、设计图、可追溯链接)对开发人员可用。如今，一些反向工程技术的成熟，以及可扩展开发环境的可用性，使得在开发软件系统时能够持续执行反向工程。这个想法已经被应用到软件工程的其他领域:例如Saff和Ernst[96]提出了持续测试的想法，即在开发或维护开发人员已经指定的单元测试用例的功能块的同时重复执行单元测试用例。</p>
<blockquote>
<p>逆向融进正向,使正向能利用逆向信息</p>
</blockquote>
<p>在逆向工程的背景下，这将带来不同的好处。首先，通过从开发中的源代码中提取并不断更新高级视图(例如，体系结构视图，或者设计图，例如类图、序列图、状态图)，可以为开发人员提供正在创建的系统的更清晰的图像。第二，当具有不同抽象级别的工件可用时，在它们之间进行持续的一致性检查可以帮助减少开发错误，例如检查代码是否与设计一致，或者是否符合前后条件。</p>
<p>第三，对正在开发的代码和其他工件的持续分析可以为开发人员提供有用的见解，例如，建议使用特定组件或改进源代码质量，例如通过改进注释级别，通过增加其内聚性等。</p>
<blockquote>
<p>高级视图帮助开发人员</p>
<p>一致性检查减少错误</p>
</blockquote>
<p>在这种情况下可以使用的逆向工程技术之一是克隆检测。开发人员可以在通过版本控制系统提交文件时，甚至在编写/维护源代码时，持续监视克隆的存在。例如，当开发人员维护一个克隆的软件片段时，开发环境可能会警告她/他存在可能需要一致更改的类似工件。另外，正在开发的单个代码段与其他克隆代码段之间的差异可能突出可能的编程错误。在同样的方向上，也可以持续监控不良气味的存在[111]，并建议重构机会，同时考虑到开发环境为自动重构提供支持。 </p>
<blockquote>
<p>进行克隆检测</p>
</blockquote>
<p>在开发和维护过程中，可追溯性链接往往会丢失，如第3节所述。</p>
<p>可追溯性链接可以使用假设跨不同软件工件(从需求到源代码)的标识符/术语的一致性的技术进行恢复。</p>
<p>同样的思想可以用于指导开发人员正确地命名标识符和注释源代码。</p>
<p>例如，De Lucia等人[36]开发了一个插件，能够指示高级工件和正在开发的代码之间的可追溯级别。</p>
<p>命名糟糕的标识符不仅使追溯恢复变得困难，而且还使代码难以理解。</p>
<p>在同样的方向上，有可能自动为开发人员提供对名称标识符的洞察，从现有代码中学习命名约定，并从需求和设计中提取领域术语。</p>
<p>此外，跟踪一些度量，如Chidamber和Kemerer度量[27]或概念内聚[77]将提高正在开发的软件的质量，也可能减少故障[54]的存在。</p>
<blockquote>
<p>恢复可追溯性链接</p>
<p>跟踪代码度量以提高软件质量</p>
</blockquote>
<p>连续逆向工程可用于支持代码文档，并在开发过程中保持文档的一致性。</p>
<p>对源代码、设计图、测试用例的维护/开发操作可以触发对其他工件的分析，并突出一致性对齐或修复的需求(例如，测试用例可能需要修复，因为应用程序正在被维护[83])。</p>
<blockquote>
<p>文档一致性</p>
</blockquote>
<p>以类似的方式，在敏捷开发或将流程[20]重新设计为连续的动态反馈的过程中，有集成许多反向工程方法的空间。这是因为(i)在敏捷过程中，文档很少或根本不存在;(二)质量保证仅限于某些单元和验收测试;并且(iii)最重要的是，软件产品是通过小的分析到代码迭代逐步创建的，这使得反向工程工件的持续更新非常可取。</p>
<blockquote>
<p>集成</p>
</blockquote>
<h2 id="面向服务架构和自主计算的逆向工程"><a href="#面向服务架构和自主计算的逆向工程" class="headerlink" title="面向服务架构和自主计算的逆向工程"></a>面向服务架构和自主计算的逆向工程</h2><p>世界各地的现代组织都力求敏捷，以在高压市场中保持竞争力。SOA和自主计算是对这一需求的一种新兴答案:</p>
<p>第一种<code>专注于高度动态、跨组织系统的开发</code>，将软件的占有和所有权(<code>软件作为产品</code>)与软件作为服务的使用(<code>软件作为服务</code>)明确分离[109];</p>
<p>第二个[65]促进了软件系统中的<code>自适应和自进化</code>机制。</p>
<blockquote>
<p>面向服务架构和自主计算 </p>
</blockquote>
<p>正如Gold等人[51]所强调的，虽然SOA代表了软件开发的下一个(今天我们可以说是新的)革命，但它们提出了相关的软件理解问题。一个面向服务的系统是由dis组成的</p>
<p>感谢不同组织提供的服务。每个服务<code>通过其接口提供了其可用功能的有限视图</code>:提供者“出售”服务的使用，但希望保护其背后的技术和实现细节。此外，当某些文档/规范可用时，不能确保属于不同组织或不同领域的不同服务提供者使用相同的术语、相同的形式主义，甚至提供相同数量的信息。所有这些因素都会影响服务的可理解性，而且由于逆向工程无法实现，因此需要使用像Korel[66]过去使用的<code>黑箱理解技术</code>。</p>
<p>在处理服务时，特别是在将一组服务编排为业务流程的阶段，一个重要的问题是理解服务如何相互关联，以及它们发布的操作之间的差异和共性是什么。</p>
<p>面向服务的系统，以及更普遍的，具有自主能力的系统，包括自主执行一些操作的能力，如:</p>
<ol>
<li><code>自动发现</code>:当一个服务，甚至整个服务组合不可用或不能提供所要求的功能级别时，自动发现[92]新的服务，绑定它们，甚至修改它们的组合方式，并继续执行;</li>
<li><code>自修复</code>[8]:持续监视系统执行，直到某些事件触发恢复操作，如更改组合、重新配置/修复系统、中断执行等。</li>
</ol>
<blockquote>
<p>SOA需要自动发现服务与系统自修复等功能</p>
</blockquote>
<p>这些特性对系统的可理解性和作为副作用的可维护性有重要影响，特别是在自修复或自动发现和组合机制不能正常工作的情况下。在这种情况下，服务有限的可观察性并不是对可分析性的唯一挑战:它必须应对极高的动态，以及组成系统的各个部分可能只在执行时才知道的事实。换句话说，动态发现和绑定将代表一个类似于点到分析的问题，但会有更多的困难，因为在这种情况下，甚至不可能预先确定可能的终点集。</p>
<blockquote>
</blockquote>
<p>正如 Mü uller [90] 所指出的，不断发展的系统可以从逆向工程和再工程技术中受益，这些技术可以用来检测具有自主元素的不断发展的软件密集型系统。另一方面，逆向工程可能为实现自主系统和 SOA 提供重要贡献，提供<code>动态发现和绑定</code>等特性。事实上，这种系统的实现在今天是有限的，因为为了正常工作，服务/组件必须公开信息，例如它们的语义、预期的服务质量 (QoS) 水平、它们的状态机或甚至是他们内部状态的一部分。在许多情况下，这根本不会发生：发布服务的任何人都只是公开其操作的签名（在 Web 服务的情况下，根据 Web 服务描述语言 (WSDL) 接口）通常是从源代码自动生成的。有限的工作量、较短的上市时间、有限的能力——以及缺乏定义明确和标准的描述语言——是减缓 SOA 传播的主要因素。</p>
<blockquote>
</blockquote>
<p>逆向工程即将开展的工作可以支持服务提供者(半)自动生成支持自动发现和重新配置机制的服务/组件注释。当然，这种自动提取的信息可能与今天已经开发的自动发现和合成机制所假设的有所不同，这需要后退一步并重新思考其中的一些机制。</p>
<p>除了使用语义注释进行发现、组合和重新配置之外，还有一种可行的替代方法，可以是某些形式的执行跟踪、从源代码中提取的指纹、组件的部分内部状态或监视数据。逆向工程无疑是使这些信息可用的一个很好的支持。</p>
<blockquote>
</blockquote>
<p>最后，但并非最不重要的是，SOA为反向工程研究人员提供了一个机会，在构建新工具和创建新研究部分时将他们的努力集中在一起。源代码分析和逆向工程工具可以作为服务发布，这样每当需要实现一个新工具时，只需使用一些服务就可以构建它的一部分。逆向工程工具可以通过组合一个解析服务、一个用于标识克隆的服务、一个用于检测源代码的服务、一个用于提取UML文档的服务等等来实现。目前限制这种互操作性的最大挑战是需要通用模式/本体来表示工具的输入/输出。</p>
<blockquote>
</blockquote>
<h1 id="6赞成采用逆向工程及其工具"><a href="#6赞成采用逆向工程及其工具" class="headerlink" title="6赞成采用逆向工程及其工具"></a>6赞成采用逆向工程及其工具</h1><p>第六节 The issue of easing the adoption of reverse engineering</p>
<p>尽管逆向工程的研究已经相当成熟，而且许多逆向工程工作似乎都能及时解决关键问题，并能满足相关的行业需求，但在工业上的应用仍然有限。我们认为，有几个方向是必须推动的:</p>
<ol>
<li><code>逆向工程教育</code>:大多数软件工程和计算机科学课程包括若干设计过程和设计方法课程。这些课程利用可重复设计技术和过程教授工程设计基础知识。然而，很少有课程使用逆向工程作为教授设计软件系统的手段，因为它在现实世界中大多数时候都是通过基于新的和正在出现的需求和需求来发展现有的系统。教授逆向工程作为软件设计过程的一个组成部分——而不仅仅是作为处理变化的技术——将增加对逆向工程作用的意识，从而帮助减少障碍，公司必须投资逆向工程或采用逆向工程实践;</li>
<li>获得更好的经验证据:特别是近年来，大多数逆向工程研究已经通过旨在测量技术性能或将其与现有技术进行比较的研究进行了经验验证。然而，这一研究领域的实证成熟度仍有待提高。在2006年WCRE大会上，Briand[16]提出了评价逆向工程研究的三个维度:输入、分析过程和输出。需要根据执行一项具体任务的正确性、完整性和实用性来评价产出。分析过程需要根据性能和可伸缩性进行评估。评估逆向工程研究的一个具有挑战性的问题是需要基准[42]，这是比较类似研究方法所必需的。基准测试的例子已经成功地应用于特征定位(例如XFig)或评估c++提取器[43]。最后，人为因素在逆向工程工具的使用中扮演了一个相关的角色，尤其是在软件理解任务中，提高了运行受控实验的需要;</li>
<li><code>提高工具的成熟度和互操作性</code>:有人可能会说，这可能是也可能不是研究人员的作用，但成熟的反向工程工具的可用性及其互操作性，通过共享数据格式和公共事实模式[39,115]或通过组合为服务的能力(如5.2节所述)，将有利于它们的使用，从而促进它们的采用。最后，上面讨论的关于逆向工程技术的经验评估需要考虑到，在许多情况下，结果强烈依赖于工具的成熟度、鲁棒性和可用性。</li>
</ol>
<blockquote>
<p>逆向工程教育,提高工具成熟度和互操作性</p>
</blockquote>
<h1 id="7总结"><a href="#7总结" class="headerlink" title="7总结"></a>7总结</h1><p>第七节 总结全文</p>
<p>在我们看来，图5总结了逆向工程在未来可能扮演的角色。</p>
<p>即将到来的逆向工程技术将依赖于跨三个不同且互补的维度的信息:<code>静态分析</code>、<code>动态分析</code>，以及作为一个新维度的<code>工件演化历史分析</code>。</p>
<p>现在和未来的软件将以<code>高动态性</code>、<code>异构性</code>和<code>分布性</code>为特征。</p>
<p>这对逆向工程来说是一个巨大的挑战，如果不对三维信息进行恰当的组合，就不可能对如此复杂的软件进行逆向工程。</p>
<blockquote>
<p><img src="/2022/09/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/9.15-%E9%80%86%E5%90%91%E5%89%8D%E6%B2%BF%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87/image-20220917230830545.png" alt="image-20220917230830545">  </p>
</blockquote>
<p>未来的逆向工程将<code>成为开发过程的一部分</code>:它将随着时间的推移在一个相同的系统上重复，当它被开发/发展为各种目的时，从一致性检查到设计合理化。</p>
<p><code>人类的反馈</code>将完全融入到逆向工程过程中，这意味着传统的自动和半自动逆向工程的二分法将被克服。</p>
<p>传统上，<code>自动</code>逆向工程被迫在<code>精度和召回率</code>之间权衡</p>
<p>而<code>半自动</code>逆向工程则使用<code>人工反馈</code>来改进特定的工件和视图，而不是生产过程本身。</p>
<p>我们设想具有自我管理功能的新一代逆向工程技术和工具。</p>
<p>其基本思想是利用逆向工程反馈来改进逆向工程过程，而不仅仅是一个特定的观点;当一个系统在其生命周期中不断地进行逆向工程时，工程师的反馈可以用来捕获和存储关于系统和工程师的背景知识和隐性知识。</p>
<p>因此，系统逆向工程的结果可以随着时间的推移而改善，不仅在精确度和召回率方面，而且在工程师的工作风格和手头任务的充分性方面。</p>
<p>在未来的逆向工程方法和工具中构建这些特性给研究带来了许多挑战:</p>
<p>如何从与逆向工程的<code>交互中获取背景知识和隐性知识</code>?</p>
<p>如何<code>利用工程师的反馈来学习更好的逆向工程方法</code>?</p>
<p>在与工程师的交互中，<code>需要捕获哪些信息</code>来建立一个有用的概要来指导未来的逆向工程?</p>
<p>如何<code>将任务的知识提供给逆向工程工具</code>，从而使输出面向手头的特定任务?。</p>
<blockquote>
<p>半自动+反馈提出的问题</p>
</blockquote>
<p>另一个重要方面与逆向工程在开发过程中所扮演的角色有关。</p>
<p>轻量级过程的<code>扩散</code>，其中<code>需求到代码的循环</code>代表了当今软件开发实践的一个现实。</p>
<p>然而，这些过程需要(i)在不同级别上对软件工件进行持续的<code>一致性检查和对齐</code>，以及(ii)<code>持续的重构</code>。</p>
<p>将逆向工程工具<code>集成</code>到开发环境中将使这成为可能，从而实现一种紧密的连续逆向工程形式，在正向阶段，工件将被持续地分析，如果有必要，还将被转换。</p>
<p>逆向工程将不断地向开发人员提供更新的信息，每次都随着开发人员修改代码而变化，同时也会对之前的反馈做出反应。</p>
<p>就其本身而言，逆向工程机器通过利用开发人员的反馈来提高所生产工件的质量。</p>
<blockquote>
<p>集成:对工件一致性检查+重构</p>
</blockquote>
<p>逆向工程的采用仍然是有限的，需要通过三个关键的促成因素来支持。</p>
<p>首先，可以预见在不同的学术水平上对这一学科进行更好的<code>教育</code>。</p>
<p>其次，虽然逆向工程研究相当可靠，发表的研究论文也包含可靠的验证，但需要进一步的实证研究来比较技术，评估它们的有用性和工具的可用性，并了解在什么情况下可以应用特定的技术。</p>
<p>实证研究的最终作用一方面是评估现有的逆向工程理论，另一方面是开发新的理论，如程序理解[100]可以用于使数据和结论有意义。</p>
<blockquote>
<p>教育+实证研究</p>
</blockquote>
<p>最后，虽然业界应该负责开发可靠的逆向工程工具，利用已经开展的研究，生产可用的原型，首先，通过共同交换软件工程的未来和通过像<code>SOA这样的新兴架构</code>，支持不同工具的<code>集成和互操作性</code>，这将是促进逆向工程技术扩散的关键因素。</p>
<blockquote>
<p>开发可靠工具</p>
</blockquote>
<p>逆向工程将有三个主要目标。</p>
<p>两个将是通常的，即帮助软件<code>理解</code>和为<code>维护和再工程</code>提供支持。</p>
<p>此外，目前正在开发新的软件系统类型:<code>自治系统，或SOA</code>，允许自动服务发现和重新配置等功能。</p>
<p>在这种情况下，逆向工程的作用将是<code>提取所需的信息</code>，以实现<code>自动发现和组合</code>等功能，并支持必要的<code>软件转换</code>，以使<code>现有系统自修复</code>和<code>自动重新配置</code>。</p>
<blockquote>
</blockquote>
<h1 id="词"><a href="#词" class="headerlink" title="词:"></a>词:</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/455298119">artifact 一词在计算机编程里面表示什么意思？ - 知乎 (zhihu.com)</a></p>
<p>需求、设计、代码、测试用例、手册页等</p>
<p>任务产出/阶段性成果/java项目/数据模型/图表/启动脚本/</p>
<p>一个 Artifact 指的是一种软件开发的副产品。它指的是任何创建出来用以开发一套软件的一类东西，这其中也许包含了数据模型，图表，启动脚本等等。</p>
<p>在软件工程中，Artifact 这个词汇是很宽泛的。大部分的软件都有大量的 Artifacts 来支撑他们的运行。有一些 Artifacts 是用来解释软件是如何运行的，另一些则真正支撑着软件的运行。</p>
<p>ci 里面指的是一次任务的产出（文件）。这个产出可能是最终产物，也可能是接下来任务的输入数据。 另外这里的任务一般指可以被重复执行的一系列命令，比如编译，文件转换等，他们的产出就是 artifact</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/component/6406571">component（组件）_百度百科 (baidu.com)</a></p>
<p>组件就是对象,组件是对数据和方法的简单封装,组件可以有自己的属性和方法。</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-metrics-values?view=vs-2022">计算代码度量 - Visual Studio (Windows) | Microsoft Docs</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/AOP/1332219">AOP（面向切面编程）_百度百科 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/6016335?fromModule=lemma_inlink">面向切面编程</a>，通过<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%A2%84%E7%BC%96%E8%AF%91/3191547?fromModule=lemma_inlink">预编译</a>方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/OOP?fromModule=lemma_inlink">OOP</a>的延续，是软件开发中的一个热点，也是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Spring?fromModule=lemma_inlink">Spring</a>框架中的一个重要内容，是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/4035031?fromModule=lemma_inlink">函数式编程</a>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938?fromModule=lemma_inlink">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/re/" rel="tag"># re</a>
          
            <a href="/tags/%E8%AE%BA%E6%96%87/" rel="tag"># 论文</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/08/30/%E7%8E%AF%E5%A2%83%20%E5%B7%A5%E5%85%B7/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="next" title="环境配置指南">
                <i class="fa fa-chevron-left"></i> 环境配置指南
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/" rel="prev" title="机器学习名词辨析">
                机器学习名词辨析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">96</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B0%E5%89%8D%E6%B2%BF"><span class="nav-number">1.</span> <span class="nav-text">逆向工程的新前沿</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">1介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD%E4%BB%A5%E5%8F%8A%E6%88%90%E5%8A%9F%E6%A1%88%E4%BE%8B"><span class="nav-number">4.</span> <span class="nav-text">2逆向工程术语以及成功案例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8D%81%E5%B9%B4%E6%88%90%E5%B0%B1"><span class="nav-number">5.</span> <span class="nav-text">3逆向工程十年成就</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">5.1.</span> <span class="nav-text">程序分析及其应用:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%81%A2%E5%A4%8D"><span class="nav-number">5.2.</span> <span class="nav-text">架构和设计恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">5.3.</span> <span class="nav-text">可视化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF"><span class="nav-number">6.</span> <span class="nav-text">4逆向工程的未来趋势</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF"><span class="nav-number">6.1.</span> <span class="nav-text">程序分析的未来趋势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF"><span class="nav-number">6.2.</span> <span class="nav-text">设计恢复的未来趋势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%B6%8B%E5%8A%BF"><span class="nav-number">6.3.</span> <span class="nav-text">软件可视化的未来趋势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5%E6%96%B0%E5%85%B4%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">5新兴软件开发场景中的逆向工程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E5%9C%A8%E6%AD%A3%E5%90%91%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%86%E5%90%91"><span class="nav-number">7.1.</span> <span class="nav-text">连续逆向工程:在正向开发中使用逆向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%92%8C%E8%87%AA%E4%B8%BB%E8%AE%A1%E7%AE%97%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">面向服务架构和自主计算的逆向工程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E8%B5%9E%E6%88%90%E9%87%87%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8F%8A%E5%85%B6%E5%B7%A5%E5%85%B7"><span class="nav-number">8.</span> <span class="nav-text">6赞成采用逆向工程及其工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">7总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%8D"><span class="nav-number">10.</span> <span class="nav-text">词:</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzlg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
