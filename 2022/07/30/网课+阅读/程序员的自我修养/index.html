<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,re," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="经典">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养">
<meta property="og:url" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/index.html">
<meta property="og:site_name" content="hzlg&#39;s blog">
<meta property="og:description" content="经典">
<meta property="og:locale">
<meta property="og:image" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/20160514162627644.jpeg">
<meta property="og:image" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20221019140249106.png">
<meta property="og:image" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/v2-412db966686bfba76fda6016ec9a1cf7_720w.webp">
<meta property="og:image" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/v2-6714abbe81e747dc695a592842aa483d_720w.webp">
<meta property="og:image" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/v2-130f6f1cb4073a52c9aeca4c4e7edc0c_720w.webp">
<meta property="article:published_time" content="2022-07-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-25T00:55:26.833Z">
<meta property="article:author" content="hzlg">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="re">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/20160514162627644.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hzlg.github.ioz/2022/07/30/网课+阅读/程序员的自我修养/"/>





  <title>程序员的自我修养 | hzlg's blog</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzlg's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记、日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzlg.github.ioz/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzlg's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员的自我修养</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-30T00:00:00+08:00">
                2022-07-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-02-25T08:55:26+08:00">
                2025-02-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>经典</p>
<span id="more"></span>

<p>可执行文件，目标文件格式：分段</p>
<p>普通C，C++代码如何被编译成目标文件以及程序在目标文件中如何存储：预处理，词法，语法，语义，中间代码生成，目标代码生成，目标代码优化</p>
<p>目标文件如何与链接器链接在一起，并且形成可执行文件：空间与地址分配，符号解析与重定位</p>
<p>目标文件在链接时符号处理，重定位和地址分配如何进行：全局符号表，重定位表，指令修正</p>
<p>可执行文件如何被装载并且执行</p>
<p>可执行文件与进程的虚拟空间之间如何映射</p>
<p>什么是动态链接，为什么要进行动态链接</p>
<p>Windows和Linux如何进行动态链接，以及动态链接时的相关问题</p>
<p>什么是堆，栈</p>
<p>函数调用惯例</p>
<p>运行库，Glibc和MSVC CRT的实现分析</p>
<p>系统调用与API</p>
<p>实现一个Mini CRT</p>
<h1 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h1><p><code>硬件</code>:CPU,内存,IO,总线</p>
<p>多层次结构,通信协议,接口</p>
<p><code>操作系统</code>:向上提供接口,向下管理硬件资源</p>
<p>管理<code>CPU</code>发展:多道程序,分时-&gt;多任务</p>
<p>设备<code>驱动</code>:操作系统内核和驱动一起运行在特权级</p>
<p>管理<code>内存</code>发展:</p>
<ul>
<li><strong>地址空间需要隔离</strong>防止恶意程序跨程序改写</li>
<li>程序<strong>不要全部装入内存</strong>,否则在交换内存的时候有大量数据交换,效率低</li>
<li>程序装入时的物理内存位置不确定,访问数据或指令跳转的目标地址需要<strong>重定位</strong></li>
</ul>
<p>分页:虚拟地址按页分割,把常用的数据和代码装载到内存中,你常用的保存在硬盘中</p>
<p><code>线程</code>:线程ID,当前指令PC,寄存器集合,堆栈</p>
<p><code>进程</code>:线程,代码段,数据段,堆,进程级资源(打开的文件)</p>
<p>线程能访问进程内存里的所有数据,线程的私有空间有:寄存器,<strong>线程局部存储(TLS)</strong>,栈</p>
<p>线程私有:局部变量,函数参数,TLS数据  线程间共享:全局变量,堆上的数据,静态变量,程序代码,打开的文件</p>
<p>线程调度:…</p>
<p>Linux下的多线程:Linux只有任务的概念,可共享内存的多个任务视作进程,fork产生新任务,共享一块写时复制的内存空间,fork产生任务镜像后exec用新的可执行镜像来替换当前镜像</p>
<p>线程安全:<code>原子操作</code>,<code>同步与锁</code></p>
<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p>gcc hello.c包括四个步骤：<strong>预处理,编译,汇编,链接</strong></p>
<ul>
<li><strong>预编译</strong>:删除源代码.c中的无用物(展开宏定义,删除注释…P39)生成.i文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i (-E表示只进行预编译)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>编译</strong>:对.i文件进行<code>词法分析</code>,<code>语法分析</code>,<code>语义分析</code>,<code>源代码优化</code>,<code>代码生成</code>,<code>目标代码优化</code>,最后生成汇编文件.s</li>
</ul>
<blockquote>
<p>编译器<code>前端</code>:</p>
<p><strong>词法分析</strong>:源代码被输入到扫描器<code>Scanner</code>,<code>Scanner</code>运用<code>有限状态机</code>算法将源代码的<code>字符序列</code>转换成一系列的记号<code>Token</code>,如关键字,标识符(变量名),括号,运算符,数字等   程序<code>lex</code>可以实现词法分析,按照用户描述的<code>词法规则</code>将输入的<code>字符串</code>分割成<code>记号</code></p>
<p><strong>语法分析</strong>:语法分析器<code>Parser</code>采用<code>上下文无关语法</code>分析手段对<code>Token</code>进行语法分析,生成<code>ast语法树</code>,若出现表达式不合法,如<strong>括号不匹配</strong>,<strong>缺少操作符</strong>,就会报语法分析阶段的错误</p>
<p><strong>语义分析</strong>:语义分析器Semantic Analyzer进行静态语义分析,给<code>ast语法树</code>里的表达式标识类型,静态语义包括<strong>声明和类型的匹配</strong>,<strong>类型的转换</strong>,动态语义是运行时的错误,如除零异常</p>
<p><strong>源代码优化(中间代码生成)</strong>:(2+6)表达式在编译期间值就可以确认是8，会被优化成8，在<code>ast语法树</code>上优化比较困难,<strong>会将语法树生成<code>中间代码</code></strong>(和目标机器,运行时环境无关,不包含数据尺寸,变量地址,寄存器名字等)</p>
<hr>
<p><code>中间代码</code>使得编译器可以被分为<code>前端</code>和<code>后端</code>,<code>前端</code>负责产生机器无关的<code>中间代码</code>,<code>后端</code>将<code>中间代码</code>转换成<code>目标机器代码</code></p>
<hr>
<p>编译器<code>后端</code>:</p>
<p><strong>目标机器代码生成(汇编生成)</strong>:代码生成器<code>Code Generator</code>将<code>中间代码</code>转换成目标机器代码(根据各个机器不同的字长,寄存器,数据类型等)</p>
<p><strong>目标代码优化</strong>:目标代码优化器<code>Target Code Optimizer</code>对目标代码进行优化(选择合适的寻址方式,使用位移代替乘法等)(还有满足CPU流水线特性,支持多种硬件平台等)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line"></span><br><span class="line">gcc将预编译和编译合并了,用程序cc1来完成 </span><br><span class="line"></span><br><span class="line">gcc -S hello.c -o hello.s   或   /usr/lib/gcc/i486-linux-gnu/4.1/cc1 hello.c</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>汇编</strong>:把汇编代码.s翻译成可执行目标文件.o (可执行文件是机器指令吗?不是,除了编译后的<code>机器指令代码,数据</code>还有链接时需要的信息等等)</li>
</ul>
<blockquote>
<p>汇编语言使用符号来简化机器语言,比如jmp</p>
<p>也使用符号来进行重定位,比如 jmp foo而不是jmp 绝对地址,汇编器在汇编程序的时候会重新计算符号foo的地址</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br><span class="line"></span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>链接</strong>:把目标文件.o和库进行链接得到可执行文件</li>
</ul>
<blockquote>
<p>链接问题就是模块间的通信问题,或者符号的引用问题,函数访问需要知道目标函数的地址,变量访问需要知道目标变量的地址</p>
<p>链接过程包括了地址和<code>空间分配</code>,<code>符号决议</code>(寻找符号定义),<code>重定位</code></p>
<p>静态链接:编译main.c的不知道外部的foo()在哪,先不管,链接的时候链接器在fun.c模块寻找foo()然后修正main.c中引用foo()的指令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ld -static ...</span><br><span class="line"></span><br><span class="line">gcc hello.c -o a.out</span><br></pre></td></tr></table></figure>

<h2 id="ELF目标文件"><a href="#ELF目标文件" class="headerlink" title="ELF目标文件"></a>ELF目标文件</h2><p>目标文件是编译后还未链接的中间文件(.o文件),结构和可执行文件类似,只有部分符号和地址没有被调整</p>
<p>现在流行可执行文件格式是COFF格式(Windows下的PE,Linux下的ELF),COFF的主要贡献是在目标文件里面引入了段的机制</p>
<p>目标文件中至少有编译后的<code>机器指令代码</code>,<code>数据</code>,还包含<strong>链接</strong>时需要的信息,如<code>符号表,调试信息,字符串</code>等,这些信息被按照不同的属性存储在各个<strong>段</strong>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h SimpleSection.o 可以查看目标文件内部简单结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size SimpleSection.o 可以查看各个段的大小</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objdump -s 可以将所有段的内容以十六进制打印出来</span><br><span class="line">-d 可以将所有包含指令的段反汇编</span><br><span class="line">objdump  -s -d SimpleSection.o 看.text段的内容</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump  -x -s -d SimpleSection.o 看所有段详细的内容,如.data段/.bss段等 -x比-h更多消息,更复杂</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h SimpleSection.o 能看文件头</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S SimpleSection.o 可以查看真正的ELF段表结构,objdump把符号表,字符串表,重定位表等省略了</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nm SimpleSection.o 能看符号表</span><br><span class="line">readelf -S SimpleSection.o 能看具体符号格式</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>可执行文件/目标文件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ELF header</strong> 描述文件信息,类型,平台,入口地址,段表位置等</td>
</tr>
<tr>
<td><strong>.text</strong> 机器指令</td>
</tr>
<tr>
<td><strong>.data</strong> 已初始化的全局变量,局部静态变量</td>
</tr>
<tr>
<td><strong>.bss</strong> 未被初始化的全局变量(编译后根据语言/编译器存放,不存放在bbs的是common符号,弱符号,最终占的空间大小未定,无法分配空间,链接后才在bbs分配空间),局部静态变量(只是预留位置，没有内容，不占实际空间)</td>
</tr>
<tr>
<td>.rodata 字符串常量(如“%d/n”)、const常量</td>
</tr>
<tr>
<td>.comment 存放编译器版本信息，如字符串”GCC:(GNU)4.2.0”</td>
</tr>
<tr>
<td>.shstrtab 段表<strong>字符串表</strong></td>
</tr>
<tr>
<td>Section table <strong>段表</strong> 包括段名,段虚拟地址，段偏移,段权限等</td>
</tr>
<tr>
<td>.symtab <strong>符号表</strong> 记录目标文件用到的所有符号,有全局符号,局部符号,外部符号。                                                     段名等等为了防止符号冲突,C编译后会加’_‘(如’_foo’),C++引入命名空间                                                          符号修饰机制:C++重载,引入函数签名,包含了函数信息,如函数名,参数类型,所在的类,命名空间…                                        C++为了和C兼容,有一个用来声明或定义C的符号的关键字<code>extern &quot;C&quot;</code>,加了<code>extern &quot;C&quot;</code>就不会有函数签名(GCC编译器除外)在C和C++共同的头文件中使用了C++宏<code>__cplusplus</code>,C++编译器在编译C++的时候会定义这个宏,加入<code>extern &quot;C&quot;</code>                                           弱符号和强符号,定义时函数和初始化的全局变量是强符号,不能多次定义,弱引用和强引用,符号决议没找到报错就是强引用,没定义但是有默认值不报错就是弱引用</td>
</tr>
<tr>
<td>.rel.text 对text段的重定位表(因为text段对printf函数的调用是绝对地址的引用)</td>
</tr>
<tr>
<td>.debug 调试信息 目标代码中的地址对应源代码中的哪一行、函数和变量的类型，结构体的定义。。。 strip 能去掉ELF文件的调试信息</td>
</tr>
<tr>
<td>Other data .dynamic/.plt .got/.init等等</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o可以将图片作为目标文件的一个段</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__(section(&quot;FOO&quot;))) int global = 42; 可以将变量放到以&quot;FOO&quot;为段名的段中</span><br></pre></td></tr></table></figure>

<h2 id="静态链接-1"><a href="#静态链接-1" class="headerlink" title="静态链接"></a>静态链接</h2><p>链接要解决的问题有<strong>空间和地址分配</strong>,<strong>符号解析与重定位</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld a.o b.o -e main -o ab</span><br><span class="line">-e main 表示将main函数作为程序入口,ld链接器默认的程序入口是_start</span><br></pre></td></tr></table></figure>

<p><strong>空间分配</strong>: 空间可以分为<code>可执行文件中的空间</code>,装载后的虚拟地址中的<code>虚拟地址空间</code></p>
<p>此处关注<code>虚拟地址空间</code>,因为关系到链接器的地址计算,所以bss段也需要分配空间</p>
<p>VMA(Virtual Memory Address):虚拟地址, 链接之前VMA均为0,因为没有分配虚拟地址,Linux下链接后默认从地址0x080480000开始分配</p>
<ul>
<li>直接叠加,段的数量很多,页对齐后会浪费很多空间</li>
<li>段合并,链接器获得段的长度,属性等等,将<strong>段合并</strong>,计算出输出文件中各个段合并后的长度和位置</li>
</ul>
<p><strong>符号地址确定</strong>:段空间分配完后,段的虚拟地址就已经确定了,根据符号在段中的偏移,就能确定符号的虚拟地址</p>
<ul>
<li>将输入目标文件中的符号表中所有符号定义和符号引用收集起来,放到全局符号表中并<strong>确定符号虚拟地址</strong>,建立映射关系</li>
</ul>
<hr>
<p><strong>符号解析与重定位</strong>:读取输入文件中的数据和重定位信息,进行<strong>符号解析与重定位</strong>,<strong>调整代码中的地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d a.o 能看反汇编的内容</span><br></pre></td></tr></table></figure>

<p>在a.c中引用了两个外部符号,变量’shared’和函数’swap’,a.o中这两个符号有关的指令是<code>movl $0x0, 0x4(esp)</code>(暂时将地址0当做未知的’shared’的地址,移到esp+4处),<code>call 27 &lt;main+0x27&gt;</code>(暂时将地址0x27当做未知的’swap’地址,调用)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -r a.o 能看重定位表--引用了外部符号的地方的地址(重定位入口)以及符号类型和下标</span><br><span class="line">objdump -s a.o 能符号表</span><br></pre></td></tr></table></figure>

<p><strong>重定位表</strong>(<code>哪些</code>符号<code>需要在哪</code>被调整):重定位表包括offset(重定位入口相对于段起始的偏移)和info(符号类型,符号在符号表中的下标)</p>
<p><strong>符号解析</strong>(找<code>在哪定义</code>了符号,确定符号的目标地址)：在a.o符号表(还不是全局符号表)中“GLOBAL”类型的且未定义的变量需要在链接后的全局符号表中能被找到,否则报符号未定义错误</p>
<p><strong>指令修正</strong>(如何<code>修正</code>符号地址): 指令寻址 在intel有近址寻址,远址寻址,绝对寻址… 32位x86平台下的ELF文件只有<code>绝对近址32位寻址</code>和<code>相对近址32位寻址 </code></p>
<p>绝对寻址修正(如 mov)：重定位入口P=0x1000+0x1C，隐式加数A=0，未重定位时访问到的就是0x1000+0x1C，重定位后<strong>地址</strong>改成S+A(符号实际位置0x3000+编译器给符号暂时的值隐式加数0x0),修正完绝对寻址的地址刚好是S的值</p>
<p>相对寻址修正(如 call)：重定位入口P=0x1000+0x27，下一条指令：0x1000+0x2b，隐式加数A=0xfcffffff（-4的补码），未重定位时跳转到的就是0x1000+0x2b-4=0x1000+0x27，重定位后<strong>偏移</strong>改成S+A-P(符号实际位置0x2000 + 编译器给符号暂时的值隐式加数-4 - 重定位入口0x1000+0x27)=0xfd5，修正完相对寻址的地址刚好是下一条指令地址0x102b+偏移0xfd5=0x2000,即S的值</p>
<hr>
<p><strong>C++相关问题</strong>:</p>
<p>C++一些特性需要编译器和链接器共同支持,重要的有<code>重复代码消除</code>,<code>全局构造与析构</code>,C++虚函数,重载,继承等,数据结构复杂,数据结构往往在不同的编译器和链接器无法通用,讨论<code>二进制兼容性问题</code></p>
<p><code>重复代码消除</code>:C++模板本质很像宏,在一个编译单元被实例化后不知道别的编译单元是否也被实例化了,多次实例化且都保留的话就会空间浪费,且指向同一函数的指针可能不相等,指令执行效率也会降低(cache命中率降低),可以<strong>将每个模板的实例代码都单独的放在一个段里</strong>，别的编译单元实例化该模板后也会生成一样名字的段，链接器就会将段合并</p>
<p>不过由于不同的编译单元可能用不同的编译版本或不同的编译优化选项,导致同名的段内容不一样,链接器会随机选择并警告</p>
<blockquote>
<p>函数级别链接:VISUAL C++编译器提供了函数级别链接的编译选项,即像模板函数一样，把所有函数都保存到单独的段里,链接器要用到函数时就把段合并到输出文件中,避免了没用的变量和函数也被链接。不过这个优化选项会减慢编译和链接过程,因为要计算函数依赖关系,且段数庞大,重定位也更复杂</p>
</blockquote>
<p><code>全局构造与析构</code>:全局对象的构造函数在main函数前被执行,全局对象的析构函数在main函数后被执行</p>
<p>Linux系统下程序的入口一般是Glibc下的_start,ELF里还有两个段:<strong>.init</strong>和**.fini**,第十一章运行库再细讲</p>
<p><code>C++与ABI</code>二进制兼容:不同编译器编译出的目标文件能够相互链接?</p>
<p>MSVC编译出的是PE/COFF格式,gcc编译出的是ELF格式,链接器需要支持这两种格式才行</p>
<p>除了<strong>目标文件格式</strong>,ABI-Application Binary Interface(<strong>符号修饰标准,变量的内存分布方式,函数调用方式</strong>)也要相同</p>
<blockquote>
<p>API保证<strong>函数定义相同</strong>(printf在POSIX标准下的系统内都是一样的),ABI保证<strong>函数使用相同</strong>(printf调用时参数压栈方向相同)</p>
</blockquote>
<p>硬件,编程语言,编译器,链接器,操作系统都会影响ABI</p>
<hr>
<p><strong>静态库链接</strong>:</p>
<p>程序输入输出需要使用操作系统提供的API(Application Programming Interface应用程序编程接口)</p>
<p>语言的开发环境会附带语言库,语言库很多是对API的包装(printf函数在Linux下是write系统调用,在Winodws下是WriteConsle系统API),也有不涉及API的,如strlen()函数</p>
<p>静态库可以看作是一组目标文件的集合,用Linux下的ar工具压缩并加上编号和索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ar -t libc.a 能看文件包含了哪些目标文件</span><br><span class="line">objdump -t libc.a 加上 grep 能看符号在哪个目标文件里,能看到printf在printf.o里</span><br><span class="line">gcc -c -fno-buildin hello.c 编译得到hello.o,默认情况下gcc会把printf替换成puts,-fno-buildin关闭函数优化</span><br><span class="line">ar -x libc.a 将所有目标文件解压到当前目录,就能找到printf.o</span><br><span class="line">ld hello.o printf.o 却失败了,因为printf缺少stdout和vfprintf的定义,依赖于其他目标文件...很复杂</span><br><span class="line">gcc -static --verbose -fno-buildin hello.c --verbose能把链接中间过程打印出来:cc1编译,as汇编,collect2(ls)链接了libc.a,crtn.o,crt1.o等等</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>链接过程控制</strong>:</p>
<ul>
<li>链接控制脚本:</li>
</ul>
<p>可以使用命令行指定参数,-d,-o等; 将链接指令存放在目标文件中,编译器会用这种方法向链接器传递指令,如VISUAL C++把链接参数放在PE里的.drectve段中; 还可以使用<code>链接控制脚本</code>,最为灵活,最为强大。</p>
<p>ld有默认链接脚本在/usr/lib/ldscripts/下,ld -verbose能看,ld会根据参数对应的链接脚本文件来控制链接过程,链接IA32下的可执行ELF文件时使用elf_i386.x作为链接控制脚本,生成共享目标文件的时候就会使用elf_i386.xs.</p>
<p>我们也可以自己写脚本,然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -T link.script</span><br></pre></td></tr></table></figure>

<ul>
<li>最小的程序: <code>不使用库函数</code>, <code>不使用main函数作为入口</code>, <code>不分段,段全部合并起来</code>,直接内嵌汇编调用write系统调用和exit系统调用,不过直接链接的话会有4个段</li>
<li>ld链接脚本的使用:ld的链接脚本语言指定要<code>合并</code>的段,要<code>丢弃</code>的段,指定输出<code>段名</code>,<code>装载地址</code>,<code>属性</code>…</li>
</ul>
<p>Tiny.lds:设置虚拟地址,合并,丢弃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(nomain)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0x8048000 + SIZEOF_HEADERS;</span><br><span class="line">	tinytext : &#123;*(.text) *(.data) *(.rodata)&#125;</span><br><span class="line">	/DISCARD/ : &#123;*(.comment)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接后还有4个段, .shstrtab,.symtab,.strtab ,字符串表和符号表,ld可以参数-s禁止产生符号表,或者用strip去除</p>
<hr>
<p><strong>BFD库</strong>:Binary File Descriptor library</p>
<p>软硬件平台很多,每个平台目标文件格式不同,编译器和链接器很难处理,需要一个统一的接口来处理差异</p>
<p>BFD库是binutils的子项目,把目标文件抽象成一个统一的模型,模型中有文件头,段,符号表,重定位表等概念</p>
<p>BFD库的程序只需要操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式</p>
<p>GCC,ld,GDB等都通过BFD库来处理目标文件,而不是直接操作目标文件,有新的目标文件格式时只需要在BFD库中添加格式就行,不需要变动编译器和链接器</p>
<h2 id="WindowsPE-COFF"><a href="#WindowsPE-COFF" class="headerlink" title="WindowsPE/COFF"></a>WindowsPE/COFF</h2><p>PE（protable executable），windows下的可执行文件格式，与ELF文件同根同源，都是COFF格式发展来的</p>
<p>VISUAL C++编译出的目标文件是COFF格式</p>
<p>cd到visual stdio目录下，命令行使用cl编译器，link链接器，dumpbin可执行文件查看器</p>
<p>COFF也是文件头加若干段加符号表，调试信息</p>
<p>文件头包括描述文件总体结构和属性的映像头（Image Header），和描述文件中包含的段属性的段表（Section Table）</p>
<blockquote>
<p>映像Image:因为PE文件在装载时被直接映射到进程的虚拟空间中运行,它是进程的虚拟空间的映像。所以PE可执行文件很多时候被叫做映像文件</p>
</blockquote>
<p>COFF具体结构在P137，和ELF也差不多</p>
<p>COFF文件的段表，一些重要的：加载至物理内存后的大小<code>VituralSize</code>(bss段为bss大小),加载至内存后的虚拟地址<code>VituralAddress</code>,该段在executable文件中的大小<code>SizeofRawData</code>(bss为0)</p>
<p>两个ELF中不存在的段：<code>.drectve</code>(链接指示信息)和<code>.debug$S</code>(符号相关的调试信息段)</p>
<p>PE相比COFF多了几个结构,开头不再是文件头,而是DOS MZ可执行文件格式的文件头和桩代码,且文件头中的IMAGE_FILE_HEADER部分扩展为了<code>IMAGE_NT_HEADERS</code>,都是为了兼容DOS系统,在DOS系统运行的时候会向终端输出This Program cannot be run in DOS</p>
<p>在Windows装载PE的时候,需要很快地找到一些装载所需要的数据结构,比如导入表,导出表,资源,重定位表等等,这些常用数据的位置和长度都被保存在了<code>数据目录</code>中,而数据目录就在<code>IMAGE_NT_HEADERS</code>中</p>
<h1 id="装载与动态链接"><a href="#装载与动态链接" class="headerlink" title="装载与动态链接"></a>装载与动态链接</h1><h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p>早期的装载就是把程序从外部存储器中读取到内存中的某个位置,随着硬件MMU诞生,多进程,多用户,虚拟存储的操作系统出现,装载过程变复杂</p>
<p><strong>进程虚拟地址空间:</strong></p>
<p>32位的硬件平台决定了进程虚拟地址空间地址从0到2^32-1(0x0~0xffffffff),4GB,高1GB操作系统,低3GB用户空间</p>
<p>3GB的空间有些小,对于数据密集型的程序比如数据库来说不够,最好的方式是变64位,还可以<code>PAE</code>(Physical Address Extension)地址扩展,若空间指虚拟地址空间,则不能超过3GB,因为指针只有32位,若空间指计算机物理内存空间,则可以超过。</p>
<p>硬件层面从32位的地址线扩展到了<code>36位地址线</code></p>
<p>Intel<code>修改了页映射方式</code>，使得新的映射方式可以访问到更多的物理内存，这个地址扩展方式就叫<code>PAE</code>,开启PAE之后，页表和页目录中的表项都从32位扩为64位,而页表和页目录的总大小不变(4KB)，所以页表和页目录都变成了<strong>512</strong>个表项。</p>
<p>应用程序感受不到扩展的地址空间,操作系统提供<code>窗口映射</code>的方法,应用程序想要使用额外的物理空间就可以申请一个窗口并把窗口映射到物理内存中,窗口可以映射到多块物理地址(非重叠),要用到另一块物理地址时就映射过去</p>
<p>Windows下叫<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/memory/address-windowing-extensions">AWE</a>(Address Windowing Extensions)地址窗口扩展,Linux下是mmap()系统调用来实现</p>
<p>**装载的方式:**覆盖装载,<code>页映射</code></p>
<p>程序装载到内存最简单的就是全装，但是内存不够，就想着根据局部性原理<strong>把最常用的装入内存，不常用的放硬盘</strong></p>
<p>覆盖装入（Overlay）：已经被淘汰了，程序员手动将程序分割成若干块，将模块按照调用依赖关系组织成树状结构，写一个覆盖管理器，根据模块间的依赖关系让模块间相互覆盖</p>
<p><code>页映射（Paging）磁盘中可执行文件和物理内存映射</code>：将<strong>内存和硬盘中</strong>的数据都分页，装载和操作的单位都是页，装载时只将一部分装入内存,在页错误的时候可以FIFO，LUR（最少使用）等算法交换页</p>
<blockquote>
<img src="/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/20160514162627644.jpeg" alt="这里写图片描述" style="zoom:67%;"> 
</blockquote>
<p>程序使用物理地址操作的话,每次装载都需要重定位,所以程序用虚拟地址操作,由MMU提供地址转换功能</p>
<p><strong>装载的过程:</strong></p>
<p>进程建立:创建虚拟空间,虚拟空间与可执行文件映射,加载</p>
<ul>
<li><p><code>创建独立的虚拟地址空间</code>(创建映射函数所需要的数据结构,如页目录)</p>
</li>
<li><p>读取可执行<strong>文件头</strong>并建立<strong>虚拟空间与可执行文件的映射关系</strong>(创建可执行文件中的段与虚拟空间中的段VMA对应的数据结构)</p>
<p>虚拟空间与可执行文件的映射:可执行文件中有0xe1大小的text段,操作系统如Linux将进程虚拟空间中的一个段叫VMA(虚拟内存区域),text段的VMA就是图中的0x08048000~0x08049000(对齐粒度0x1000)</p>
<p>程序执行到虚拟地址0x08048000的时候,发现页面0x08048000~0x08049000是个空页面,MMU无法将虚拟地址转换到物理内存中(页映射),产生页错误page fault,CPU交还控制权给操作系统,查询空页面所在的VMA,找到相应的页面在可执行文件中的偏移,在物理内存中分配一个物理页,将缺页从硬盘读到内存,建立<strong>虚拟页和物理页的映射关系</strong>(注意区分),交还控制权</p>
<blockquote>
<p><img src="/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/image-20221019140249106.png" alt="image-20221019140249106">    </p>
</blockquote>
</li>
<li><p>将CS:IP设置到入口地址并<code>开始执行</code>(操作系统把寄存器等的控制权交给进程)</p>
</li>
</ul>
<p><strong>进程虚拟地址空间分布:</strong></p>
<p>每个段都产生一个VMA,占据整数个页的话,会有很多空隙,浪费内存空间</p>
<p>可以将section段分为三种,可读可执行,可读可写,只读</p>
<p>ELF文件引入<code>Segment</code>概念,相似类型的段可以看作一个整体一起映射,如.text段和.init段,映射后只有一个VMA而不是两个</p>
<p><strong>Segment实际上从装载的角度重新划分了ELF的各个段,系统是按Segment而不是Section来映射可执行文件的</strong></p>
<p><code>代码VMA+数据VMA</code></p>
<p>视图View:Section和Segment从不同角度划分ELF文件,从Section来看就是链接视图,从Segment来看就是执行视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf -S SectionMapping.elf 看段表中的段</span><br><span class="line">readelf -l SectionMapping.elf 看Program Header 中的Segment</span><br></pre></td></tr></table></figure>

<p>ELF可执行文件需要装载,有一个Program Header Table结构来保存Segment,是ELF目标文件中没有的</p>
<p>VMA除了被用来映射Segment外,还可以对进程的地址空间进行管理,堆和栈在进程虚拟空间中也是以VMA的形式存在的</p>
<p><code>堆VMA+栈VMA</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./SectionMapping.elf &amp;  输出进程号</span><br><span class="line">cat /proc/21963/maps    proc查看进程的虚拟空间分布</span><br></pre></td></tr></table></figure>

<p><strong>段地址对齐</strong>:</p>
<p>分出来segment后,因为segment可能不足一个页的大小，若将每个segment分开一一映射(一个虚拟页映射到一个物理页),还是会有内存碎片</p>
<p>Unix系统让各个段接壤部分共享一个物理页面,然后将该物理页面分别映射两次(将可执行文件分为若干个块，块里有两个SEG也是一个物理页，不过还是有两个虚拟页，这两个虚拟页都能页映射到同一个物理页上）</p>
<blockquote>
<p><img src="/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/v2-412db966686bfba76fda6016ec9a1cf7_720w.webp" alt="img" style="zoom:67%;"> <img src="/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/v2-6714abbe81e747dc695a592842aa483d_720w.webp" alt="img" style="zoom:67%;"></p>
</blockquote>
<p>之前将section合并为Segment是在<strong>虚拟地址空间</strong>和<strong>物理空间</strong>两个地方都进行合并</p>
<p>而将Segment合并<strong>仅仅是在物理空间合并</strong>，在<strong>虚拟地址空间中的操作是将两个Segment交接处所在的页映射两次</strong>。</p>
<p>不同Segment在虚拟地址空间中不能在一个页中有交集，否则虚拟地址空间中的同一个页的权限会有冲突。</p>
<p>可以看作将整个ELF文件分为若干个4096字节的块,作为物理页,映射一次或两次</p>
<p><strong>ELF的装载</strong></p>
<p>在bash下输入一个命令执行ELF程序是,在用户层面bash进程会调用 fork()系统调用 创建一个新的进程,新的进程调用 execve()系统调用 Linux内核装载ELF文件,原先的bash进程返回等待新进程结束</p>
<p>装载细节: 1.sys_execve()读取文件前128个字节以判断文件格式 2.search_binary_handle()搜索并调用可执行文件对应的装载处理过程,如load_elf_binary() 3.检查文件有效性,寻找动态链接段并设置<code>动态链接</code>器路径,ELF文件<code>映射</code>到虚拟空间,初始化ELF进程<code>环境</code>,将系统调用的返回地址设为ELF文件的<code>入口点</code>（虚拟地址） 4.返回用户态,跳转到ELF入口点,开始执行</p>
<p><strong>PE的装载</strong></p>
<p>PE没有很多section,不需要合并成segment,段地址对齐…</p>
<p>PE里有几个概念:</p>
<p><code>RVA</code>(Relative Vitural Address)相对虚拟地址,就是<code>在文件中的偏移量</code>(RVA不变)</p>
<p><code>ImageBase</code>是PE文件的优先装载地址,<code>ImageBase</code>为0x400000时,装载器会先尝试将PE装载到虚拟空间的0x400000处,若已被占用就换个地方(ImageBase会变)</p>
<p>虚拟地址<code>VA</code>=<code>ImageBase</code>+<code>RVA</code></p>
<p>装载细节: 1.读取第一个页的DOS头,文件头,段表信息等 2.检查地址空间中目标地址是否可用(主要是DLL要检查) 3.根据段表信息将PE文件中所有段映射到虚拟地址空间 4.装载地址不是目标地址就进行Rebasing 5.装载DLL 6.对导入符号进行解析 7.根据PE头信息初始化栈和堆 8.建立主线程并启动进程</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>引入动态的原因/动态特点介绍</strong>:</p>
<p>静态链接特点:</p>
<ul>
<li>生成可执行文件时链接器把用得上的用不上的.o文件<strong>全部合并,符号决议,重定位</strong></li>
<li>执行时把可执行文件<strong>一整个装载</strong>(映射并加载放进内存)。</li>
<li>缺点是空间浪费,而且更新难</li>
</ul>
<p>ELF文件里的<code>.dynamic</code> 包含了可执行程序所需的动态链接库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd filename  能递归的查依赖</span><br></pre></td></tr></table></figure>

<p>动态链接特点:</p>
<ul>
<li>生成可执行文件时<code>链接器</code>进行<code>链接1</code>:<strong>不合并,根据.so文件信息进行符号标记,不重定位</strong></li>
<li>执行时<strong>不重复地递归装载</strong>模块副本(可执行文件/共享库等),<code>动态链接器</code>再进行<code>链接2</code>:<strong>符号绑定,重定位</strong></li>
</ul>
<p>动态链接提高了程序的可扩展性:公司开发完产品后给出接口,开发者就能根据接口自己写第三方模块,使得程序能使用插件进行扩展</p>
<p>动态链接提高了程序的兼容性:操作系统给出动态链接库,程序在不同os下就能用不同的库,消除了平台依赖性,根据接口自己写第三方模块,使得程序能使用插件进行扩展</p>
<p>不过动态链接性能会下降,把链接(重定位)从装载前变到了装载后,每次装载都要重新链接(重定位),但是可以延迟绑定,减小损失</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so Lib.c  将Lib.c编译成共享对象文件,-shared生成共享库,-fPIC生成位置无关代码（PIC）</span><br></pre></td></tr></table></figure>



<p>在装载的时候,静态链接只有可执行文件(.o文件合并.a文件)需要被映射,而动态链接需要将可执行文件(.o文件里有被标记为动态链接的未决议符号)，<code>共享目标文件和动态链接器都映射</code>,运行可执行文件之前将控制权交给动态链接器再交给可执行文件</p>
<hr>
<p><strong>地址无关代码</strong>:</p>
<p>链接时重定位:在编译时未决议的符号(.a文件中定义)虚拟地址未确定,要在静态链接时符号决议找到虚拟地址之后把指令修正</p>
<p>装载时重定位:在动态链接时未决议的符号(.so文件中定义)虚拟地址未确定,要在装载时符号绑定找到虚拟地址后把指令修正</p>
<p>装载时重定位要修正可执行文件中的指令,<strong>也要修正共享对象中的指令</strong>(在静态链接时指令都被合并到一个段里修正),修正共享对象的指令部分后内存中这一份共享对象就进程相关了,在多进程共享内存中共享对象的指令部分时还是要有多个副本，所以不适合多进程共享。</p>
<p>地址无关代码(PIC):将指令中要修改的部分(地址相关部分)和可修改数据放在一起,这些部分可以有多个副本,其他东西在内存中留一个副本就行</p>
<p>地址引用能分为模块内外的函数调用或数据访问四种</p>
<ul>
<li>模块内部调用/跳转:caller和callee的相对位置不变,PC+xxx=newPC,<code>直接call xxx改PC</code>就行,已经是地址无关代码,不需要重定位</li>
<li>模块内部数据访问:代码和数据的相对位置不变,PC+xxx=&amp;var,<code>获得PC后偏移得到数据地址</code>,再对数据进行访问/修改就行,不需要重定位</li>
<li>模块外部数据访问:引入<strong>GOT表</strong>(Global Offset Table),放在数据段中,可以有多个副本,内容是变量的指针,链接器在装载时会填充GOT表(还可能会延迟绑定,加入PLT表)(不同的进程虚拟空间内.so的位置不同,每个进程GOT表填充的东西不一样,不过可执行文件内代码和GOT的相对位置不变),要访问外部数据就先<code>获得PC后偏移找到GOT表中的数据地址</code>,再对数据进行访问/修改就行</li>
<li>模块外部调用/跳转:GOT表中存目标函数的地址,<code>获得PC后偏移找到GOT表中的函数地址</code></li>
</ul>
<blockquote>
<img src="/2022/07/30/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/v2-130f6f1cb4073a52c9aeca4c4e7edc0c_720w.webp" alt="img" style="zoom: 50%;"> 
</blockquote>
<p>还有一个问题：模块内的全局变量</p>
<p>若是模块内的普通变量或静态变量，访问模块内数据段中的那一个副本即可</p>
<p>若是模块外的全局变量，需要GOT表，访问模块外的那一个副本即可。</p>
<p>而模块内的全局变量,需要GOT表,当做模块外的全局变量,访问模块外可执行文件的那一个副本，虽然全局变量在本模块内，但自己没有副本。</p>
<p>ELF 共享库在编译时，默认把所有全局变量都当作是定义在其他模块中，通过 GOT 表实现外部访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，动态链接器就把 GOT 表中的相应地址指向该副本。如果该变量在可执行文件中没有副本，那么 GOT 表中的相应地址就指向模块内部的该变量副本。</p>
<p>共享模块内有全局变量，当做模块外的</p>
<ul>
<li>可执行文件有副本，共享模块的GOT表指向可执行文件副本(链接器在创建可执行文件时于bss段创建的副本,若变量在共享模块中被初始化,就复制到可执行文件副本中)</li>
<li>可执行文件没有副本，共享模块的GOT表指向模块内副本</li>
</ul>
<hr>
<p><strong>延迟绑定PLT</strong></p>
<p>动态链接灵活，但是牺牲了一点性能，1.因为类静态链接生成可执行文件时没有进行重定位，只是标记了符号，所以要在运行时动态链接,即装载时重定位(PIC代码就进行数据段(包括GOT表)重定位,非PIC代码就要代码和数据都重定位),寻找共享对象进行符号查找,地址重定位 2.因为生成了地址无关代码,访问变量时多了一层GOT表寻址。</p>
<p>符号查找和地址重定位耗时,而且一些错误处理函数等函数不经常用,所以提出了延迟绑定,即<strong>函数第一次被用到时才进行绑定</strong>（符号查找，地址重定位）。</p>
<p>引入<code>PLT表</code>（地址无关，可以合并进可读可执行的Segment），不通过GOT表来跳转,而是先跳到PLT表再跳到GOT表,func@PLT的第一行是jmp func@GOT,未调用过func之前func@GOT地址是plt第二条指令,push <code>符号</code>在重定位表中的下标,push <code>模块</code>ID,调用_dl_runtime_resolve()函数来进行地址绑定工作,根据模块名和函数名(符号名)将真正的地址填入func@GOT。</p>
<hr>
<p><strong>装载的过程（引入动态链接）:</strong></p>
<p>进程建立:创建虚拟空间,虚拟空间与可执行文件映射,加载,</p>
<ul>
<li><code>创建独立的虚拟地址空间</code>(创建映射函数所需要的数据结构,如页目录)</li>
<li>读取可执行<strong>文件头</strong>并建立<strong>虚拟空间与可执行文件的映射关系</strong>(创建可执行文件中的段与虚拟空间中的段VMA对应的数据结构)</li>
<li>静态就控制权给可执行文件,动态就根据.interp段里保存的路径字符串找到动态链接器,将控制权给动态链接器,动态链接完之后再给可执行文件</li>
</ul>
<hr>
<p><strong>动态链接相关结构</strong>:</p>
<p>.interp段里保存动态链接器路径字符串</p>
<p>.dynamic段保存动态链接需要的信息,如符号表地址,字符串表地址,重定位表地址等等</p>
<h2 id="Linux共享库的组织"><a href="#Linux共享库的组织" class="headerlink" title="Linux共享库的组织"></a>Linux共享库的组织</h2><h2 id="Windows下的动态链接"><a href="#Windows下的动态链接" class="headerlink" title="Windows下的动态链接"></a>Windows下的动态链接</h2><h1 id="库与运行库"><a href="#库与运行库" class="headerlink" title="库与运行库"></a>库与运行库</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h2 id="运行库"><a href="#运行库" class="headerlink" title="运行库"></a>运行库</h2><h2 id="系统调用与API"><a href="#系统调用与API" class="headerlink" title="系统调用与API"></a>系统调用与API</h2><h2 id="运行库实现"><a href="#运行库实现" class="headerlink" title="运行库实现"></a>运行库实现</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/re/" rel="tag"># re</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/07/15/ctf/reverse/%E6%AF%8F%E6%97%A5%E5%8D%9A%E5%AE%A2/7.15-flutter_Windows/" rel="next" title="7.15-Flutter windows逆向">
                <i class="fa fa-chevron-left"></i> 7.15-Flutter windows逆向
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/08/07/%E7%BD%91%E8%AF%BE+%E9%98%85%E8%AF%BB/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="prev" title="形式语言与自动机">
                形式语言与自动机 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">108</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0"><span class="nav-number">1.</span> <span class="nav-text">温故而知新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">2.</span> <span class="nav-text">静态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">2.1.</span> <span class="nav-text">编译和链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">ELF目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5-1"><span class="nav-number">2.3.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WindowsPE-COFF"><span class="nav-number">2.4.</span> <span class="nav-text">WindowsPE&#x2F;COFF</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">装载与动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">可执行文件的装载与进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.2.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-number">3.3.</span> <span class="nav-text">Linux共享库的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows%E4%B8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.</span> <span class="nav-text">Windows下的动态链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%93%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">库与运行库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">4.1.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%BA%93"><span class="nav-number">4.2.</span> <span class="nav-text">运行库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8EAPI"><span class="nav-number">4.3.</span> <span class="nav-text">系统调用与API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%BA%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.</span> <span class="nav-text">运行库实现</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzlg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
